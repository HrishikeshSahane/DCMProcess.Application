{"ast":null,"code":"/*! @azure/msal-common v14.5.0 2023-12-01 */\n'use strict';\n\nimport _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BaseClient } from './BaseClient.mjs';\nimport { RequestParameterBuilder } from '../request/RequestParameterBuilder.mjs';\nimport { Separators, GrantType, AuthenticationScheme, PromptValue, HeaderNames } from '../utils/Constants.mjs';\nimport { CLIENT_ID, RETURN_SPA_CODE } from '../constants/AADServerParamKeys.mjs';\nimport { isOidcProtocolMode } from '../config/ClientConfiguration.mjs';\nimport { ResponseHandler } from '../response/ResponseHandler.mjs';\nimport { StringUtils } from '../utils/StringUtils.mjs';\nimport { createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { UrlString } from '../url/UrlString.mjs';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.mjs';\nimport { TimeUtils } from '../utils/TimeUtils.mjs';\nimport { buildClientInfo, buildClientInfoFromHomeAccountId } from '../account/ClientInfo.mjs';\nimport { CcsCredentialType } from '../account/CcsCredential.mjs';\nimport { createClientConfigurationError } from '../error/ClientConfigurationError.mjs';\nimport { RequestValidator } from '../request/RequestValidator.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { invokeAsync } from '../utils/FunctionWrappers.mjs';\nimport { requestCannotBeMade, authorizationCodeMissingFromServerResponse } from '../error/ClientAuthErrorCodes.mjs';\nimport { logoutRequestEmpty, missingSshJwk } from '../error/ClientConfigurationErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Oauth2.0 Authorization Code client\n * @internal\n */\nclass AuthorizationCodeClient extends BaseClient {\n  constructor(configuration, performanceClient) {\n    super(configuration, performanceClient);\n    // Flag to indicate if client is for hybrid spa auth code redemption\n    this.includeRedirectUri = true;\n    this.oidcDefaultScopes = this.config.authOptions.authority.options.OIDCOptions?.defaultScopes;\n  }\n  /**\n   * Creates the URL of the authorization request letting the user input credentials and consent to the\n   * application. The URL target the /authorize endpoint of the authority configured in the\n   * application object.\n   *\n   * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\n   * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\n   * acquireToken(AuthorizationCodeRequest)\n   * @param request\n   */\n  getAuthCodeUrl(request) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.performanceClient?.addQueueMeasurement(PerformanceEvents.GetAuthCodeUrl, request.correlationId);\n      const queryString = yield invokeAsync(_this.createAuthCodeUrlQueryString.bind(_this), PerformanceEvents.AuthClientCreateQueryString, _this.logger, _this.performanceClient, request.correlationId)(request);\n      return UrlString.appendQueryString(_this.authority.authorizationEndpoint, queryString);\n    })();\n  }\n  /**\n   * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\n   * authorization_code_grant\n   * @param request\n   */\n  acquireToken(request, authCodePayload) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);\n      if (!request.code) {\n        throw createClientAuthError(requestCannotBeMade);\n      }\n      const reqTimestamp = TimeUtils.nowSeconds();\n      const response = yield invokeAsync(_this2.executeTokenRequest.bind(_this2), PerformanceEvents.AuthClientExecuteTokenRequest, _this2.logger, _this2.performanceClient, request.correlationId)(_this2.authority, request);\n      // Retrieve requestId from response headers\n      const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];\n      const responseHandler = new ResponseHandler(_this2.config.authOptions.clientId, _this2.cacheManager, _this2.cryptoUtils, _this2.logger, _this2.config.serializableCache, _this2.config.persistencePlugin, _this2.performanceClient);\n      // Validate response. This function throws a server error if an error is returned by the server.\n      responseHandler.validateTokenResponse(response.body);\n      return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, _this2.logger, _this2.performanceClient, request.correlationId)(response.body, _this2.authority, reqTimestamp, request, authCodePayload, undefined, undefined, undefined, requestId);\n    })();\n  }\n  /**\n   * Handles the hash fragment response from public client code request. Returns a code response used by\n   * the client to exchange for a token in acquireToken.\n   * @param hashFragment\n   */\n  handleFragmentResponse(serverParams, cachedState) {\n    // Handle responses.\n    const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null);\n    // Get code response\n    responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState);\n    // throw when there is no auth code in the response\n    if (!serverParams.code) {\n      throw createClientAuthError(authorizationCodeMissingFromServerResponse);\n    }\n    return serverParams;\n  }\n  /**\n   * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.\n   * Default behaviour is to redirect the user to `window.location.href`.\n   * @param authorityUri\n   */\n  getLogoutUri(logoutRequest) {\n    // Throw error if logoutRequest is null/undefined\n    if (!logoutRequest) {\n      throw createClientConfigurationError(logoutRequestEmpty);\n    }\n    const queryString = this.createLogoutUrlQueryString(logoutRequest);\n    // Construct logout URI\n    return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);\n  }\n  /**\n   * Executes POST request to token endpoint\n   * @param authority\n   * @param request\n   */\n  executeTokenRequest(authority, request) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      _this3.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);\n      const queryParametersString = _this3.createTokenQueryParameters(request);\n      const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);\n      const requestBody = yield invokeAsync(_this3.createTokenRequestBody.bind(_this3), PerformanceEvents.AuthClientCreateTokenRequestBody, _this3.logger, _this3.performanceClient, request.correlationId)(request);\n      let ccsCredential = undefined;\n      if (request.clientInfo) {\n        try {\n          const clientInfo = buildClientInfo(request.clientInfo, _this3.cryptoUtils.base64Decode);\n          ccsCredential = {\n            credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\n            type: CcsCredentialType.HOME_ACCOUNT_ID\n          };\n        } catch (e) {\n          _this3.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n        }\n      }\n      const headers = _this3.createTokenRequestHeaders(ccsCredential || request.ccsCredential);\n      const thumbprint = {\n        clientId: request.tokenBodyParameters?.clientId || _this3.config.authOptions.clientId,\n        authority: authority.canonicalAuthority,\n        scopes: request.scopes,\n        claims: request.claims,\n        authenticationScheme: request.authenticationScheme,\n        resourceRequestMethod: request.resourceRequestMethod,\n        resourceRequestUri: request.resourceRequestUri,\n        shrClaims: request.shrClaims,\n        sshKid: request.sshKid\n      };\n      return invokeAsync(_this3.executePostToTokenEndpoint.bind(_this3), PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint, _this3.logger, _this3.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint);\n    })();\n  }\n  /**\n   * Generates a map for all the params to be sent to the service\n   * @param request\n   */\n  createTokenRequestBody(request) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      _this4.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);\n      const parameterBuilder = new RequestParameterBuilder();\n      parameterBuilder.addClientId(request.tokenBodyParameters?.[CLIENT_ID] || _this4.config.authOptions.clientId);\n      /*\n       * For hybrid spa flow, there will be a code but no verifier\n       * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI\n       */\n      if (!_this4.includeRedirectUri) {\n        // Just validate\n        RequestValidator.validateRedirectUri(request.redirectUri);\n      } else {\n        // Validate and include redirect uri\n        parameterBuilder.addRedirectUri(request.redirectUri);\n      }\n      // Add scope array, parameter builder will add default scopes and dedupe\n      parameterBuilder.addScopes(request.scopes, true, _this4.oidcDefaultScopes);\n      // add code: user set, not validated\n      parameterBuilder.addAuthorizationCode(request.code);\n      // Add library metadata\n      parameterBuilder.addLibraryInfo(_this4.config.libraryInfo);\n      parameterBuilder.addApplicationTelemetry(_this4.config.telemetry.application);\n      parameterBuilder.addThrottling();\n      if (_this4.serverTelemetryManager && !isOidcProtocolMode(_this4.config)) {\n        parameterBuilder.addServerTelemetry(_this4.serverTelemetryManager);\n      }\n      // add code_verifier if passed\n      if (request.codeVerifier) {\n        parameterBuilder.addCodeVerifier(request.codeVerifier);\n      }\n      if (_this4.config.clientCredentials.clientSecret) {\n        parameterBuilder.addClientSecret(_this4.config.clientCredentials.clientSecret);\n      }\n      if (_this4.config.clientCredentials.clientAssertion) {\n        const clientAssertion = _this4.config.clientCredentials.clientAssertion;\n        parameterBuilder.addClientAssertion(clientAssertion.assertion);\n        parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\n      }\n      parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);\n      parameterBuilder.addClientInfo();\n      if (request.authenticationScheme === AuthenticationScheme.POP) {\n        const popTokenGenerator = new PopTokenGenerator(_this4.cryptoUtils, _this4.performanceClient);\n        const reqCnfData = yield invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, _this4.logger, _this4.performanceClient, request.correlationId)(request, _this4.logger);\n        // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\n        parameterBuilder.addPopToken(reqCnfData.reqCnfString);\n      } else if (request.authenticationScheme === AuthenticationScheme.SSH) {\n        if (request.sshJwk) {\n          parameterBuilder.addSshJwk(request.sshJwk);\n        } else {\n          throw createClientConfigurationError(missingSshJwk);\n        }\n      }\n      const correlationId = request.correlationId || _this4.config.cryptoInterface.createNewGuid();\n      parameterBuilder.addCorrelationId(correlationId);\n      if (!StringUtils.isEmptyObj(request.claims) || _this4.config.authOptions.clientCapabilities && _this4.config.authOptions.clientCapabilities.length > 0) {\n        parameterBuilder.addClaims(request.claims, _this4.config.authOptions.clientCapabilities);\n      }\n      let ccsCred = undefined;\n      if (request.clientInfo) {\n        try {\n          const clientInfo = buildClientInfo(request.clientInfo, _this4.cryptoUtils.base64Decode);\n          ccsCred = {\n            credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\n            type: CcsCredentialType.HOME_ACCOUNT_ID\n          };\n        } catch (e) {\n          _this4.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n        }\n      } else {\n        ccsCred = request.ccsCredential;\n      }\n      // Adds these as parameters in the request instead of headers to prevent CORS preflight request\n      if (_this4.config.systemOptions.preventCorsPreflight && ccsCred) {\n        switch (ccsCred.type) {\n          case CcsCredentialType.HOME_ACCOUNT_ID:\n            try {\n              const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);\n              parameterBuilder.addCcsOid(clientInfo);\n            } catch (e) {\n              _this4.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n            }\n            break;\n          case CcsCredentialType.UPN:\n            parameterBuilder.addCcsUpn(ccsCred.credential);\n            break;\n        }\n      }\n      if (request.tokenBodyParameters) {\n        parameterBuilder.addExtraQueryParameters(request.tokenBodyParameters);\n      }\n      // Add hybrid spa parameters if not already provided\n      if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[RETURN_SPA_CODE])) {\n        parameterBuilder.addExtraQueryParameters({\n          [RETURN_SPA_CODE]: \"1\"\n        });\n      }\n      return parameterBuilder.createQueryString();\n    })();\n  }\n  /**\n   * This API validates the `AuthorizationCodeUrlRequest` and creates a URL\n   * @param request\n   */\n  createAuthCodeUrlQueryString(request) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      _this5.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateQueryString, request.correlationId);\n      const parameterBuilder = new RequestParameterBuilder();\n      parameterBuilder.addClientId(request.extraQueryParameters?.[CLIENT_ID] || _this5.config.authOptions.clientId);\n      const requestScopes = [...(request.scopes || []), ...(request.extraScopesToConsent || [])];\n      parameterBuilder.addScopes(requestScopes, true, _this5.oidcDefaultScopes);\n      // validate the redirectUri (to be a non null value)\n      parameterBuilder.addRedirectUri(request.redirectUri);\n      // generate the correlationId if not set by the user and add\n      const correlationId = request.correlationId || _this5.config.cryptoInterface.createNewGuid();\n      parameterBuilder.addCorrelationId(correlationId);\n      // add response_mode. If not passed in it defaults to query.\n      parameterBuilder.addResponseMode(request.responseMode);\n      // add response_type = code\n      parameterBuilder.addResponseTypeCode();\n      // add library info parameters\n      parameterBuilder.addLibraryInfo(_this5.config.libraryInfo);\n      if (!isOidcProtocolMode(_this5.config)) {\n        parameterBuilder.addApplicationTelemetry(_this5.config.telemetry.application);\n      }\n      // add client_info=1\n      parameterBuilder.addClientInfo();\n      if (request.codeChallenge && request.codeChallengeMethod) {\n        parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);\n      }\n      if (request.prompt) {\n        parameterBuilder.addPrompt(request.prompt);\n      }\n      if (request.domainHint) {\n        parameterBuilder.addDomainHint(request.domainHint);\n      }\n      // Add sid or loginHint with preference for login_hint claim (in request) -> sid -> loginHint (upn/email) -> username of AccountInfo object\n      if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\n        // AAD will throw if prompt=select_account is passed with an account hint\n        if (request.sid && request.prompt === PromptValue.NONE) {\n          // SessionID is only used in silent calls\n          _this5.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from request\");\n          parameterBuilder.addSid(request.sid);\n        } else if (request.account) {\n          const accountSid = _this5.extractAccountSid(request.account);\n          const accountLoginHintClaim = _this5.extractLoginHint(request.account);\n          // If login_hint claim is present, use it over sid/username\n          if (accountLoginHintClaim) {\n            _this5.logger.verbose(\"createAuthCodeUrlQueryString: login_hint claim present on account\");\n            parameterBuilder.addLoginHint(accountLoginHintClaim);\n            try {\n              const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n              parameterBuilder.addCcsOid(clientInfo);\n            } catch (e) {\n              _this5.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n            }\n          } else if (accountSid && request.prompt === PromptValue.NONE) {\n            /*\n             * If account and loginHint are provided, we will check account first for sid before adding loginHint\n             * SessionId is only used in silent calls\n             */\n            _this5.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from account\");\n            parameterBuilder.addSid(accountSid);\n            try {\n              const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n              parameterBuilder.addCcsOid(clientInfo);\n            } catch (e) {\n              _this5.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n            }\n          } else if (request.loginHint) {\n            _this5.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from request\");\n            parameterBuilder.addLoginHint(request.loginHint);\n            parameterBuilder.addCcsUpn(request.loginHint);\n          } else if (request.account.username) {\n            // Fallback to account username if provided\n            _this5.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from account\");\n            parameterBuilder.addLoginHint(request.account.username);\n            try {\n              const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n              parameterBuilder.addCcsOid(clientInfo);\n            } catch (e) {\n              _this5.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n            }\n          }\n        } else if (request.loginHint) {\n          _this5.logger.verbose(\"createAuthCodeUrlQueryString: No account, adding login_hint from request\");\n          parameterBuilder.addLoginHint(request.loginHint);\n          parameterBuilder.addCcsUpn(request.loginHint);\n        }\n      } else {\n        _this5.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints\");\n      }\n      if (request.nonce) {\n        parameterBuilder.addNonce(request.nonce);\n      }\n      if (request.state) {\n        parameterBuilder.addState(request.state);\n      }\n      if (request.claims || _this5.config.authOptions.clientCapabilities && _this5.config.authOptions.clientCapabilities.length > 0) {\n        parameterBuilder.addClaims(request.claims, _this5.config.authOptions.clientCapabilities);\n      }\n      if (request.extraQueryParameters) {\n        parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n      }\n      if (request.nativeBroker) {\n        // signal ests that this is a WAM call\n        parameterBuilder.addNativeBroker();\n        // pass the req_cnf for POP\n        if (request.authenticationScheme === AuthenticationScheme.POP) {\n          const popTokenGenerator = new PopTokenGenerator(_this5.cryptoUtils);\n          // to reduce the URL length, it is recommended to send the hash of the req_cnf instead of the whole string\n          const reqCnfData = yield invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, _this5.logger, _this5.performanceClient, request.correlationId)(request, _this5.logger);\n          parameterBuilder.addPopToken(reqCnfData.reqCnfHash);\n        }\n      }\n      return parameterBuilder.createQueryString();\n    })();\n  }\n  /**\n   * This API validates the `EndSessionRequest` and creates a URL\n   * @param request\n   */\n  createLogoutUrlQueryString(request) {\n    const parameterBuilder = new RequestParameterBuilder();\n    if (request.postLogoutRedirectUri) {\n      parameterBuilder.addPostLogoutRedirectUri(request.postLogoutRedirectUri);\n    }\n    if (request.correlationId) {\n      parameterBuilder.addCorrelationId(request.correlationId);\n    }\n    if (request.idTokenHint) {\n      parameterBuilder.addIdTokenHint(request.idTokenHint);\n    }\n    if (request.state) {\n      parameterBuilder.addState(request.state);\n    }\n    if (request.logoutHint) {\n      parameterBuilder.addLogoutHint(request.logoutHint);\n    }\n    if (request.extraQueryParameters) {\n      parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n    }\n    return parameterBuilder.createQueryString();\n  }\n  /**\n   * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\n   * @param account\n   */\n  extractAccountSid(account) {\n    return account.idTokenClaims?.sid || null;\n  }\n  extractLoginHint(account) {\n    return account.idTokenClaims?.login_hint || null;\n  }\n}\nexport { AuthorizationCodeClient };\n//# sourceMappingURL=AuthorizationCodeClient.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}