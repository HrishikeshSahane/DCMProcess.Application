{"ast":null,"code":"/*! @azure/msal-common v14.5.0 2023-12-01 */\n'use strict';\n\nimport _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Constants, ResponseCodes, RegionDiscoverySources } from '../utils/Constants.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { invokeAsync } from '../utils/FunctionWrappers.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nlet RegionDiscovery = /*#__PURE__*/(() => {\n  class RegionDiscovery {\n    constructor(networkInterface, logger, performanceClient, correlationId) {\n      this.networkInterface = networkInterface;\n      this.logger = logger;\n      this.performanceClient = performanceClient;\n      this.correlationId = correlationId;\n    }\n    /**\n     * Detect the region from the application's environment.\n     *\n     * @returns Promise<string | null>\n     */\n    detectRegion(environmentRegion, regionDiscoveryMetadata) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        _this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, _this.correlationId);\n        // Initialize auto detected region with the region from the envrionment\n        let autodetectedRegionName = environmentRegion;\n        // Check if a region was detected from the environment, if not, attempt to get the region from IMDS\n        if (!autodetectedRegionName) {\n          const options = RegionDiscovery.IMDS_OPTIONS;\n          try {\n            const localIMDSVersionResponse = yield invokeAsync(_this.getRegionFromIMDS.bind(_this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, _this.logger, _this.performanceClient, _this.correlationId)(Constants.IMDS_VERSION, options);\n            if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\n              autodetectedRegionName = localIMDSVersionResponse.body;\n              regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n            }\n            // If the response using the local IMDS version failed, try to fetch the current version of IMDS and retry.\n            if (localIMDSVersionResponse.status === ResponseCodes.httpBadRequest) {\n              const currentIMDSVersion = yield invokeAsync(_this.getCurrentVersion.bind(_this), PerformanceEvents.RegionDiscoveryGetCurrentVersion, _this.logger, _this.performanceClient, _this.correlationId)(options);\n              if (!currentIMDSVersion) {\n                regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n                return null;\n              }\n              const currentIMDSVersionResponse = yield invokeAsync(_this.getRegionFromIMDS.bind(_this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, _this.logger, _this.performanceClient, _this.correlationId)(currentIMDSVersion, options);\n              if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\n                autodetectedRegionName = currentIMDSVersionResponse.body;\n                regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n              }\n            }\n          } catch (e) {\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n            return null;\n          }\n        } else {\n          regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;\n        }\n        // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION\n        if (!autodetectedRegionName) {\n          regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n        }\n        return autodetectedRegionName || null;\n      })();\n    }\n    /**\n     * Make the call to the IMDS endpoint\n     *\n     * @param imdsEndpointUrl\n     * @returns Promise<NetworkResponse<string>>\n     */\n    getRegionFromIMDS(version, options) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        _this2.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, _this2.correlationId);\n        return _this2.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?api-version=${version}&format=text`, options, Constants.IMDS_TIMEOUT);\n      })();\n    }\n    /**\n     * Get the most recent version of the IMDS endpoint available\n     *\n     * @returns Promise<string | null>\n     */\n    getCurrentVersion(options) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        _this3.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, _this3.correlationId);\n        try {\n          const response = yield _this3.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?format=json`, options);\n          // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.\n          if (response.status === ResponseCodes.httpBadRequest && response.body && response.body[\"newest-versions\"] && response.body[\"newest-versions\"].length > 0) {\n            return response.body[\"newest-versions\"][0];\n          }\n          return null;\n        } catch (e) {\n          return null;\n        }\n      })();\n    }\n  }\n  // Options for the IMDS endpoint request\n  RegionDiscovery.IMDS_OPTIONS = {\n    headers: {\n      Metadata: \"true\"\n    }\n  };\n  return RegionDiscovery;\n})();\nexport { RegionDiscovery };\n//# sourceMappingURL=RegionDiscovery.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}