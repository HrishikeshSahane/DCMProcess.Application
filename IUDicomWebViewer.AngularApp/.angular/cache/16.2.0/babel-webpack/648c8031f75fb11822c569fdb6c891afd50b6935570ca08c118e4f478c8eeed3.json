{"ast":null,"code":"var Utils = require(\"../util\"),\n  Constants = Utils.Constants;\n\n/* The entries in the end of central directory */\nmodule.exports = function () {\n  var _volumeEntries = 0,\n    _totalEntries = 0,\n    _size = 0,\n    _offset = 0,\n    _commentLength = 0;\n  return {\n    get diskEntries() {\n      return _volumeEntries;\n    },\n    set diskEntries( /*Number*/val) {\n      _volumeEntries = _totalEntries = val;\n    },\n    get totalEntries() {\n      return _totalEntries;\n    },\n    set totalEntries( /*Number*/val) {\n      _totalEntries = _volumeEntries = val;\n    },\n    get size() {\n      return _size;\n    },\n    set size( /*Number*/val) {\n      _size = val;\n    },\n    get offset() {\n      return _offset;\n    },\n    set offset( /*Number*/val) {\n      _offset = val;\n    },\n    get commentLength() {\n      return _commentLength;\n    },\n    set commentLength( /*Number*/val) {\n      _commentLength = val;\n    },\n    get mainHeaderSize() {\n      return Constants.ENDHDR + _commentLength;\n    },\n    loadFromBinary: function ( /*Buffer*/data) {\n      // data should be 22 bytes and start with \"PK 05 06\"\n      // or be 56+ bytes and start with \"PK 06 06\" for Zip64\n      if ((data.length !== Constants.ENDHDR || data.readUInt32LE(0) !== Constants.ENDSIG) && (data.length < Constants.ZIP64HDR || data.readUInt32LE(0) !== Constants.ZIP64SIG)) {\n        throw new Error(Utils.Errors.INVALID_END);\n      }\n      if (data.readUInt32LE(0) === Constants.ENDSIG) {\n        // number of entries on this volume\n        _volumeEntries = data.readUInt16LE(Constants.ENDSUB);\n        // total number of entries\n        _totalEntries = data.readUInt16LE(Constants.ENDTOT);\n        // central directory size in bytes\n        _size = data.readUInt32LE(Constants.ENDSIZ);\n        // offset of first CEN header\n        _offset = data.readUInt32LE(Constants.ENDOFF);\n        // zip file comment length\n        _commentLength = data.readUInt16LE(Constants.ENDCOM);\n      } else {\n        // number of entries on this volume\n        _volumeEntries = Utils.readBigUInt64LE(data, Constants.ZIP64SUB);\n        // total number of entries\n        _totalEntries = Utils.readBigUInt64LE(data, Constants.ZIP64TOT);\n        // central directory size in bytes\n        _size = Utils.readBigUInt64LE(data, Constants.ZIP64SIZE);\n        // offset of first CEN header\n        _offset = Utils.readBigUInt64LE(data, Constants.ZIP64OFF);\n        _commentLength = 0;\n      }\n    },\n    toBinary: function () {\n      var b = Buffer.alloc(Constants.ENDHDR + _commentLength);\n      // \"PK 05 06\" signature\n      b.writeUInt32LE(Constants.ENDSIG, 0);\n      b.writeUInt32LE(0, 4);\n      // number of entries on this volume\n      b.writeUInt16LE(_volumeEntries, Constants.ENDSUB);\n      // total number of entries\n      b.writeUInt16LE(_totalEntries, Constants.ENDTOT);\n      // central directory size in bytes\n      b.writeUInt32LE(_size, Constants.ENDSIZ);\n      // offset of first CEN header\n      b.writeUInt32LE(_offset, Constants.ENDOFF);\n      // zip file comment length\n      b.writeUInt16LE(_commentLength, Constants.ENDCOM);\n      // fill comment memory with spaces so no garbage is left there\n      b.fill(\" \", Constants.ENDHDR);\n      return b;\n    },\n    toJSON: function () {\n      // creates 0x0000 style output\n      const offset = function (nr, len) {\n        let offs = nr.toString(16).toUpperCase();\n        while (offs.length < len) offs = \"0\" + offs;\n        return \"0x\" + offs;\n      };\n      return {\n        diskEntries: _volumeEntries,\n        totalEntries: _totalEntries,\n        size: _size + \" bytes\",\n        offset: offset(_offset, 4),\n        commentLength: _commentLength\n      };\n    },\n    toString: function () {\n      return JSON.stringify(this.toJSON(), null, \"\\t\");\n    }\n  };\n};\n// Misspelled","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}