{"ast":null,"code":"/*! @azure/msal-browser v3.6.0 2023-12-01 */\n'use strict';\n\nimport _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { DB_NAME, DB_VERSION, DB_TABLE_NAME } from '../utils/BrowserConstants.mjs';\nimport { databaseUnavailable, databaseNotOpen } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Storage wrapper for IndexedDB storage in browsers: https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API\n */\nclass DatabaseStorage {\n  constructor() {\n    this.dbName = DB_NAME;\n    this.version = DB_VERSION;\n    this.tableName = DB_TABLE_NAME;\n    this.dbOpen = false;\n  }\n  /**\n   * Opens IndexedDB instance.\n   */\n  open() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        const openDB = window.indexedDB.open(_this.dbName, _this.version);\n        openDB.addEventListener(\"upgradeneeded\", e => {\n          const event = e;\n          event.target.result.createObjectStore(_this.tableName);\n        });\n        openDB.addEventListener(\"success\", e => {\n          const event = e;\n          _this.db = event.target.result;\n          _this.dbOpen = true;\n          resolve();\n        });\n        openDB.addEventListener(\"error\", () => reject(createBrowserAuthError(databaseUnavailable)));\n      });\n    })();\n  }\n  /**\n   * Closes the connection to IndexedDB database when all pending transactions\n   * complete.\n   */\n  closeConnection() {\n    const db = this.db;\n    if (db && this.dbOpen) {\n      db.close();\n      this.dbOpen = false;\n    }\n  }\n  /**\n   * Opens database if it's not already open\n   */\n  validateDbIsOpen() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this2.dbOpen) {\n        return _this2.open();\n      }\n    })();\n  }\n  /**\n   * Retrieves item from IndexedDB instance.\n   * @param key\n   */\n  getItem(key) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      yield _this3.validateDbIsOpen();\n      return new Promise((resolve, reject) => {\n        // TODO: Add timeouts?\n        if (!_this3.db) {\n          return reject(createBrowserAuthError(databaseNotOpen));\n        }\n        const transaction = _this3.db.transaction([_this3.tableName], \"readonly\");\n        const objectStore = transaction.objectStore(_this3.tableName);\n        const dbGet = objectStore.get(key);\n        dbGet.addEventListener(\"success\", e => {\n          const event = e;\n          _this3.closeConnection();\n          resolve(event.target.result);\n        });\n        dbGet.addEventListener(\"error\", e => {\n          _this3.closeConnection();\n          reject(e);\n        });\n      });\n    })();\n  }\n  /**\n   * Adds item to IndexedDB under given key\n   * @param key\n   * @param payload\n   */\n  setItem(key, payload) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      yield _this4.validateDbIsOpen();\n      return new Promise((resolve, reject) => {\n        // TODO: Add timeouts?\n        if (!_this4.db) {\n          return reject(createBrowserAuthError(databaseNotOpen));\n        }\n        const transaction = _this4.db.transaction([_this4.tableName], \"readwrite\");\n        const objectStore = transaction.objectStore(_this4.tableName);\n        const dbPut = objectStore.put(payload, key);\n        dbPut.addEventListener(\"success\", () => {\n          _this4.closeConnection();\n          resolve();\n        });\n        dbPut.addEventListener(\"error\", e => {\n          _this4.closeConnection();\n          reject(e);\n        });\n      });\n    })();\n  }\n  /**\n   * Removes item from IndexedDB under given key\n   * @param key\n   */\n  removeItem(key) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      yield _this5.validateDbIsOpen();\n      return new Promise((resolve, reject) => {\n        if (!_this5.db) {\n          return reject(createBrowserAuthError(databaseNotOpen));\n        }\n        const transaction = _this5.db.transaction([_this5.tableName], \"readwrite\");\n        const objectStore = transaction.objectStore(_this5.tableName);\n        const dbDelete = objectStore.delete(key);\n        dbDelete.addEventListener(\"success\", () => {\n          _this5.closeConnection();\n          resolve();\n        });\n        dbDelete.addEventListener(\"error\", e => {\n          _this5.closeConnection();\n          reject(e);\n        });\n      });\n    })();\n  }\n  /**\n   * Get all the keys from the storage object as an iterable array of strings.\n   */\n  getKeys() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      yield _this6.validateDbIsOpen();\n      return new Promise((resolve, reject) => {\n        if (!_this6.db) {\n          return reject(createBrowserAuthError(databaseNotOpen));\n        }\n        const transaction = _this6.db.transaction([_this6.tableName], \"readonly\");\n        const objectStore = transaction.objectStore(_this6.tableName);\n        const dbGetKeys = objectStore.getAllKeys();\n        dbGetKeys.addEventListener(\"success\", e => {\n          const event = e;\n          _this6.closeConnection();\n          resolve(event.target.result);\n        });\n        dbGetKeys.addEventListener(\"error\", e => {\n          _this6.closeConnection();\n          reject(e);\n        });\n      });\n    })();\n  }\n  /**\n   *\n   * Checks whether there is an object under the search key in the object store\n   */\n  containsKey(key) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      yield _this7.validateDbIsOpen();\n      return new Promise((resolve, reject) => {\n        if (!_this7.db) {\n          return reject(createBrowserAuthError(databaseNotOpen));\n        }\n        const transaction = _this7.db.transaction([_this7.tableName], \"readonly\");\n        const objectStore = transaction.objectStore(_this7.tableName);\n        const dbContainsKey = objectStore.count(key);\n        dbContainsKey.addEventListener(\"success\", e => {\n          const event = e;\n          _this7.closeConnection();\n          resolve(event.target.result === 1);\n        });\n        dbContainsKey.addEventListener(\"error\", e => {\n          _this7.closeConnection();\n          reject(e);\n        });\n      });\n    })();\n  }\n  /**\n   * Deletes the MSAL database. The database is deleted rather than cleared to make it possible\n   * for client applications to downgrade to a previous MSAL version without worrying about forward compatibility issues\n   * with IndexedDB database versions.\n   */\n  deleteDatabase() {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      // Check if database being deleted exists\n      if (_this8.db && _this8.dbOpen) {\n        _this8.closeConnection();\n      }\n      return new Promise((resolve, reject) => {\n        const deleteDbRequest = window.indexedDB.deleteDatabase(DB_NAME);\n        deleteDbRequest.addEventListener(\"success\", () => resolve(true));\n        deleteDbRequest.addEventListener(\"blocked\", () => resolve(true));\n        deleteDbRequest.addEventListener(\"error\", () => reject(false));\n      });\n    })();\n  }\n}\nexport { DatabaseStorage };\n//# sourceMappingURL=DatabaseStorage.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}