{"ast":null,"code":"/*! @azure/msal-browser v3.6.0 2023-12-01 */\n'use strict';\n\nimport _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { PerformanceEvents, JoseHeader } from '@azure/msal-common';\nimport { base64Encode, urlEncode, urlEncodeArr } from '../encode/Base64Encode.mjs';\nimport { base64Decode } from '../encode/Base64Decode.mjs';\nimport { validateCryptoAvailable, createNewGuid, generateKeyPair, exportJwk, importJwk, sign, sha256Digest } from './BrowserCrypto.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { CryptoKeyStore } from '../cache/CryptoKeyStore.mjs';\nimport { cryptoKeyNotFound } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This class implements MSAL's crypto interface, which allows it to perform base64 encoding and decoding, generating cryptographically random GUIDs and\n * implementing Proof Key for Code Exchange specs for the OAuth Authorization Code Flow using PKCE (rfc here: https://tools.ietf.org/html/rfc7636).\n */\nlet CryptoOps = /*#__PURE__*/(() => {\n  class CryptoOps {\n    constructor(logger, performanceClient) {\n      this.logger = logger;\n      // Browser crypto needs to be validated first before any other classes can be set.\n      validateCryptoAvailable(logger);\n      this.cache = new CryptoKeyStore(this.logger);\n      this.performanceClient = performanceClient;\n    }\n    /**\n     * Creates a new random GUID - used to populate state and nonce.\n     * @returns string (GUID)\n     */\n    createNewGuid() {\n      return createNewGuid();\n    }\n    /**\n     * Encodes input string to base64.\n     * @param input\n     */\n    base64Encode(input) {\n      return base64Encode(input);\n    }\n    /**\n     * Decodes input string from base64.\n     * @param input\n     */\n    base64Decode(input) {\n      return base64Decode(input);\n    }\n    /**\n     * Generates a keypair, stores it and returns a thumbprint\n     * @param request\n     */\n    getPublicKeyThumbprint(request) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        const publicKeyThumbMeasurement = _this.performanceClient?.startMeasurement(PerformanceEvents.CryptoOptsGetPublicKeyThumbprint, request.correlationId);\n        // Generate Keypair\n        const keyPair = yield generateKeyPair(CryptoOps.EXTRACTABLE, CryptoOps.POP_KEY_USAGES);\n        // Generate Thumbprint for Public Key\n        const publicKeyJwk = yield exportJwk(keyPair.publicKey);\n        const pubKeyThumprintObj = {\n          e: publicKeyJwk.e,\n          kty: publicKeyJwk.kty,\n          n: publicKeyJwk.n\n        };\n        const publicJwkString = getSortedObjectString(pubKeyThumprintObj);\n        const publicJwkHash = yield _this.hashString(publicJwkString);\n        // Generate Thumbprint for Private Key\n        const privateKeyJwk = yield exportJwk(keyPair.privateKey);\n        // Re-import private key to make it unextractable\n        const unextractablePrivateKey = yield importJwk(privateKeyJwk, false, [\"sign\"]);\n        // Store Keypair data in keystore\n        yield _this.cache.asymmetricKeys.setItem(publicJwkHash, {\n          privateKey: unextractablePrivateKey,\n          publicKey: keyPair.publicKey,\n          requestMethod: request.resourceRequestMethod,\n          requestUri: request.resourceRequestUri\n        });\n        if (publicKeyThumbMeasurement) {\n          publicKeyThumbMeasurement.end({\n            success: true\n          });\n        }\n        return publicJwkHash;\n      })();\n    }\n    /**\n     * Removes cryptographic keypair from key store matching the keyId passed in\n     * @param kid\n     */\n    removeTokenBindingKey(kid) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        yield _this2.cache.asymmetricKeys.removeItem(kid);\n        const keyFound = yield _this2.cache.asymmetricKeys.containsKey(kid);\n        return !keyFound;\n      })();\n    }\n    /**\n     * Removes all cryptographic keys from IndexedDB storage\n     */\n    clearKeystore() {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        return _this3.cache.clear();\n      })();\n    }\n    /**\n     * Signs the given object as a jwt payload with private key retrieved by given kid.\n     * @param payload\n     * @param kid\n     */\n    signJwt(payload, kid, shrOptions, correlationId) {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        const signJwtMeasurement = _this4.performanceClient?.startMeasurement(PerformanceEvents.CryptoOptsSignJwt, correlationId);\n        const cachedKeyPair = yield _this4.cache.asymmetricKeys.getItem(kid);\n        if (!cachedKeyPair) {\n          throw createBrowserAuthError(cryptoKeyNotFound);\n        }\n        // Get public key as JWK\n        const publicKeyJwk = yield exportJwk(cachedKeyPair.publicKey);\n        const publicKeyJwkString = getSortedObjectString(publicKeyJwk);\n        // Base64URL encode public key thumbprint with keyId only: BASE64URL({ kid: \"FULL_PUBLIC_KEY_HASH\" })\n        const encodedKeyIdThumbprint = urlEncode(JSON.stringify({\n          kid: kid\n        }));\n        // Generate header\n        const shrHeader = JoseHeader.getShrHeaderString({\n          ...shrOptions?.header,\n          alg: publicKeyJwk.alg,\n          kid: encodedKeyIdThumbprint\n        });\n        const encodedShrHeader = urlEncode(shrHeader);\n        // Generate payload\n        payload.cnf = {\n          jwk: JSON.parse(publicKeyJwkString)\n        };\n        const encodedPayload = urlEncode(JSON.stringify(payload));\n        // Form token string\n        const tokenString = `${encodedShrHeader}.${encodedPayload}`;\n        // Sign token\n        const encoder = new TextEncoder();\n        const tokenBuffer = encoder.encode(tokenString);\n        const signatureBuffer = yield sign(cachedKeyPair.privateKey, tokenBuffer);\n        const encodedSignature = urlEncodeArr(new Uint8Array(signatureBuffer));\n        const signedJwt = `${tokenString}.${encodedSignature}`;\n        if (signJwtMeasurement) {\n          signJwtMeasurement.end({\n            success: true\n          });\n        }\n        return signedJwt;\n      })();\n    }\n    /**\n     * Returns the SHA-256 hash of an input string\n     * @param plainText\n     */\n    hashString(plainText) {\n      return _asyncToGenerator(function* () {\n        const hashBuffer = yield sha256Digest(plainText);\n        const hashBytes = new Uint8Array(hashBuffer);\n        return urlEncodeArr(hashBytes);\n      })();\n    }\n  }\n  CryptoOps.POP_KEY_USAGES = [\"sign\", \"verify\"];\n  CryptoOps.EXTRACTABLE = true;\n  return CryptoOps;\n})();\nfunction getSortedObjectString(obj) {\n  return JSON.stringify(obj, Object.keys(obj).sort());\n}\nexport { CryptoOps };\n//# sourceMappingURL=CryptoOps.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}