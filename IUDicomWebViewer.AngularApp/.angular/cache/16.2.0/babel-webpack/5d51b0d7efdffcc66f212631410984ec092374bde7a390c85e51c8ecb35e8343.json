{"ast":null,"code":"/*! @azure/msal-common v14.5.0 2023-12-01 */\n'use strict';\n\nimport { Separators, CacheAccountType } from '../../utils/Constants.mjs';\nimport { buildClientInfo } from '../../account/ClientInfo.mjs';\nimport { buildTenantProfileFromIdTokenClaims } from '../../account/AccountInfo.mjs';\nimport { createClientAuthError } from '../../error/ClientAuthError.mjs';\nimport { AuthorityType } from '../../authority/AuthorityType.mjs';\nimport { getTenantIdFromIdTokenClaims } from '../../account/TokenClaims.mjs';\nimport { ProtocolMode } from '../../authority/ProtocolMode.mjs';\nimport { invalidCacheEnvironment } from '../../error/ClientAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).\n *\n * Key : Value Schema\n *\n * Key: <home_account_id>-<environment>-<realm*>\n *\n * Value Schema:\n * {\n *      homeAccountId: home account identifier for the auth scheme,\n *      environment: entity that issued the token, represented as a full host\n *      realm: Full tenant or organizational identifier that the account belongs to\n *      localAccountId: Original tenant-specific accountID, usually used for legacy cases\n *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt\n *      authorityType: Accounts authority type as a string\n *      name: Full name for the account, including given name and family name,\n *      lastModificationTime: last time this entity was modified in the cache\n *      lastModificationApp:\n *      nativeAccountId: Account identifier on the native device\n *      tenantProfiles: Array of tenant profile objects for each tenant that the account has authenticated with in the browser\n * }\n * @internal\n */\nclass AccountEntity {\n  /**\n   * Generate Account Id key component as per the schema: <home_account_id>-<environment>\n   */\n  generateAccountId() {\n    const accountId = [this.homeAccountId, this.environment];\n    return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  }\n  /**\n   * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>\n   */\n  generateAccountKey() {\n    return AccountEntity.generateAccountCacheKey({\n      homeAccountId: this.homeAccountId,\n      environment: this.environment,\n      tenantId: this.realm,\n      username: this.username,\n      localAccountId: this.localAccountId\n    });\n  }\n  /**\n   * Returns the AccountInfo interface for this account.\n   */\n  getAccountInfo() {\n    return {\n      homeAccountId: this.homeAccountId,\n      environment: this.environment,\n      tenantId: this.realm,\n      username: this.username,\n      localAccountId: this.localAccountId,\n      name: this.name,\n      nativeAccountId: this.nativeAccountId,\n      authorityType: this.authorityType,\n      // Deserialize tenant profiles array into a Map\n      tenantProfiles: new Map((this.tenantProfiles || []).map(tenantProfile => {\n        return [tenantProfile.tenantId, tenantProfile];\n      }))\n    };\n  }\n  /**\n   * Returns true if the account entity is in single tenant format (outdated), false otherwise\n   */\n  isSingleTenant() {\n    return !this.tenantProfiles;\n  }\n  /**\n   * Generates account key from interface\n   * @param accountInterface\n   */\n  static generateAccountCacheKey(accountInterface) {\n    const homeTenantId = accountInterface.homeAccountId.split(\".\")[1];\n    const accountKey = [accountInterface.homeAccountId, accountInterface.environment || \"\", homeTenantId || accountInterface.tenantId || \"\"];\n    return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  }\n  /**\n   * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.\n   * @param accountDetails\n   */\n  static createAccount(accountDetails, authority, base64Decode) {\n    const account = new AccountEntity();\n    if (authority.authorityType === AuthorityType.Adfs) {\n      account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;\n    } else if (authority.protocolMode === ProtocolMode.AAD) {\n      account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;\n    } else {\n      account.authorityType = CacheAccountType.GENERIC_ACCOUNT_TYPE;\n    }\n    let clientInfo;\n    if (accountDetails.clientInfo && base64Decode) {\n      clientInfo = buildClientInfo(accountDetails.clientInfo, base64Decode);\n    }\n    account.clientInfo = accountDetails.clientInfo;\n    account.homeAccountId = accountDetails.homeAccountId;\n    account.nativeAccountId = accountDetails.nativeAccountId;\n    const env = accountDetails.environment || authority && authority.getPreferredCache();\n    if (!env) {\n      throw createClientAuthError(invalidCacheEnvironment);\n    }\n    account.environment = env;\n    // non AAD scenarios can have empty realm\n    account.realm = clientInfo?.utid || getTenantIdFromIdTokenClaims(accountDetails.idTokenClaims) || \"\";\n    // How do you account for MSA CID here?\n    account.localAccountId = clientInfo?.uid || accountDetails.idTokenClaims.oid || accountDetails.idTokenClaims.sub || \"\";\n    /*\n     * In B2C scenarios the emails claim is used instead of preferred_username and it is an array.\n     * In most cases it will contain a single email. This field should not be relied upon if a custom\n     * policy is configured to return more than 1 email.\n     */\n    const preferredUsername = accountDetails.idTokenClaims.preferred_username || accountDetails.idTokenClaims.upn;\n    const email = accountDetails.idTokenClaims.emails ? accountDetails.idTokenClaims.emails[0] : null;\n    account.username = preferredUsername || email || \"\";\n    account.name = accountDetails.idTokenClaims.name;\n    account.cloudGraphHostName = accountDetails.cloudGraphHostName;\n    account.msGraphHost = accountDetails.msGraphHost;\n    if (accountDetails.tenantProfiles) {\n      account.tenantProfiles = accountDetails.tenantProfiles;\n    } else {\n      const tenantProfiles = [];\n      if (accountDetails.idTokenClaims) {\n        const tenantProfile = buildTenantProfileFromIdTokenClaims(accountDetails.homeAccountId, accountDetails.idTokenClaims);\n        tenantProfiles.push(tenantProfile);\n      }\n      account.tenantProfiles = tenantProfiles;\n    }\n    return account;\n  }\n  /**\n   * Creates an AccountEntity object from AccountInfo\n   * @param accountInfo\n   * @param cloudGraphHostName\n   * @param msGraphHost\n   * @returns\n   */\n  static createFromAccountInfo(accountInfo, cloudGraphHostName, msGraphHost) {\n    const account = new AccountEntity();\n    account.authorityType = accountInfo.authorityType || CacheAccountType.GENERIC_ACCOUNT_TYPE;\n    account.homeAccountId = accountInfo.homeAccountId;\n    account.localAccountId = accountInfo.localAccountId;\n    account.nativeAccountId = accountInfo.nativeAccountId;\n    account.realm = accountInfo.tenantId;\n    account.environment = accountInfo.environment;\n    account.username = accountInfo.username;\n    account.name = accountInfo.name;\n    account.cloudGraphHostName = cloudGraphHostName;\n    account.msGraphHost = msGraphHost;\n    // Serialize tenant profiles map into an array\n    account.tenantProfiles = Array.from(accountInfo.tenantProfiles?.values() || []);\n    return account;\n  }\n  /**\n   * Generate HomeAccountId from server response\n   * @param serverClientInfo\n   * @param authType\n   */\n  static generateHomeAccountId(serverClientInfo, authType, logger, cryptoObj, idTokenClaims) {\n    // since ADFS/DSTS do not have tid and does not set client_info\n    if (!(authType === AuthorityType.Adfs || authType === AuthorityType.Dsts)) {\n      // for cases where there is clientInfo\n      if (serverClientInfo) {\n        try {\n          const clientInfo = buildClientInfo(serverClientInfo, cryptoObj.base64Decode);\n          if (clientInfo.uid && clientInfo.utid) {\n            return `${clientInfo.uid}.${clientInfo.utid}`;\n          }\n        } catch (e) {}\n      }\n      logger.warning(\"No client info in response\");\n    }\n    // default to \"sub\" claim\n    return idTokenClaims?.sub || \"\";\n  }\n  /**\n   * Validates an entity: checks for all expected params\n   * @param entity\n   */\n  static isAccountEntity(entity) {\n    if (!entity) {\n      return false;\n    }\n    return entity.hasOwnProperty(\"homeAccountId\") && entity.hasOwnProperty(\"environment\") && entity.hasOwnProperty(\"realm\") && entity.hasOwnProperty(\"localAccountId\") && entity.hasOwnProperty(\"username\") && entity.hasOwnProperty(\"authorityType\");\n  }\n  /**\n   * Helper function to determine whether 2 accountInfo objects represent the same account\n   * @param accountA\n   * @param accountB\n   * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality\n   */\n  static accountInfoIsEqual(accountA, accountB, compareClaims) {\n    if (!accountA || !accountB) {\n      return false;\n    }\n    let claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false\n    if (compareClaims) {\n      const accountAClaims = accountA.idTokenClaims || {};\n      const accountBClaims = accountB.idTokenClaims || {};\n      // issued at timestamp and nonce are expected to change each time a new id token is acquired\n      claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;\n    }\n    return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.environment === accountB.environment && accountA.nativeAccountId === accountB.nativeAccountId && claimsMatch;\n  }\n}\nexport { AccountEntity };\n//# sourceMappingURL=AccountEntity.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}