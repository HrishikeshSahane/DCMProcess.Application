{"ast":null,"code":"/*! @azure/msal-common v14.5.0 2023-12-01 */\n'use strict';\n\nimport { extractTokenClaims } from '../../account/AuthToken.mjs';\nimport { createClientAuthError } from '../../error/ClientAuthError.mjs';\nimport { Separators, CredentialType, AuthenticationScheme, SERVER_TELEM_CONSTANTS } from '../../utils/Constants.mjs';\nimport { TimeUtils } from '../../utils/TimeUtils.mjs';\nimport { tokenClaimsCnfRequiredForSignedJwt } from '../../error/ClientAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Cache Key: <home_account_id>-<environment>-<credential_type>-<client_id or familyId>-<realm>-<scopes>-<claims hash>-<scheme>\n * IdToken Example: uid.utid-login.microsoftonline.com-idtoken-app_client_id-contoso.com\n * AccessToken Example: uid.utid-login.microsoftonline.com-accesstoken-app_client_id-contoso.com-scope1 scope2--pop\n * RefreshToken Example: uid.utid-login.microsoftonline.com-refreshtoken-1-contoso.com\n * @param credentialEntity\n * @returns\n */\nfunction generateCredentialKey(credentialEntity) {\n  const credentialKey = [generateAccountId(credentialEntity), generateCredentialId(credentialEntity), generateTarget(credentialEntity), generateClaimsHash(credentialEntity), generateScheme(credentialEntity)];\n  return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n}\n/**\n * Create IdTokenEntity\n * @param homeAccountId\n * @param authenticationResult\n * @param clientId\n * @param authority\n */\nfunction createIdTokenEntity(homeAccountId, environment, idToken, clientId, tenantId) {\n  const idTokenEntity = {\n    credentialType: CredentialType.ID_TOKEN,\n    homeAccountId: homeAccountId,\n    environment: environment,\n    clientId: clientId,\n    secret: idToken,\n    realm: tenantId\n  };\n  return idTokenEntity;\n}\n/**\n * Create AccessTokenEntity\n * @param homeAccountId\n * @param environment\n * @param accessToken\n * @param clientId\n * @param tenantId\n * @param scopes\n * @param expiresOn\n * @param extExpiresOn\n */\nfunction createAccessTokenEntity(homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, base64Decode, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {\n  const atEntity = {\n    homeAccountId: homeAccountId,\n    credentialType: CredentialType.ACCESS_TOKEN,\n    secret: accessToken,\n    cachedAt: TimeUtils.nowSeconds().toString(),\n    expiresOn: expiresOn.toString(),\n    extendedExpiresOn: extExpiresOn.toString(),\n    environment: environment,\n    clientId: clientId,\n    realm: tenantId,\n    target: scopes,\n    tokenType: tokenType || AuthenticationScheme.BEARER\n  };\n  if (userAssertionHash) {\n    atEntity.userAssertionHash = userAssertionHash;\n  }\n  if (refreshOn) {\n    atEntity.refreshOn = refreshOn.toString();\n  }\n  if (requestedClaims) {\n    atEntity.requestedClaims = requestedClaims;\n    atEntity.requestedClaimsHash = requestedClaimsHash;\n  }\n  /*\n   * Create Access Token With Auth Scheme instead of regular access token\n   * Cast to lower to handle \"bearer\" from ADFS\n   */\n  if (atEntity.tokenType?.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) {\n    atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n    switch (atEntity.tokenType) {\n      case AuthenticationScheme.POP:\n        // Make sure keyId is present and add it to credential\n        const tokenClaims = extractTokenClaims(accessToken, base64Decode);\n        if (!tokenClaims?.cnf?.kid) {\n          throw createClientAuthError(tokenClaimsCnfRequiredForSignedJwt);\n        }\n        atEntity.keyId = tokenClaims.cnf.kid;\n        break;\n      case AuthenticationScheme.SSH:\n        atEntity.keyId = keyId;\n    }\n  }\n  return atEntity;\n}\n/**\n * Create RefreshTokenEntity\n * @param homeAccountId\n * @param authenticationResult\n * @param clientId\n * @param authority\n */\nfunction createRefreshTokenEntity(homeAccountId, environment, refreshToken, clientId, familyId, userAssertionHash) {\n  const rtEntity = {\n    credentialType: CredentialType.REFRESH_TOKEN,\n    homeAccountId: homeAccountId,\n    environment: environment,\n    clientId: clientId,\n    secret: refreshToken\n  };\n  if (userAssertionHash) {\n    rtEntity.userAssertionHash = userAssertionHash;\n  }\n  if (familyId) {\n    rtEntity.familyId = familyId;\n  }\n  return rtEntity;\n}\nfunction isCredentialEntity(entity) {\n  return entity.hasOwnProperty(\"homeAccountId\") && entity.hasOwnProperty(\"environment\") && entity.hasOwnProperty(\"credentialType\") && entity.hasOwnProperty(\"clientId\") && entity.hasOwnProperty(\"secret\");\n}\n/**\n * Validates an entity: checks for all expected params\n * @param entity\n */\nfunction isAccessTokenEntity(entity) {\n  if (!entity) {\n    return false;\n  }\n  return isCredentialEntity(entity) && entity.hasOwnProperty(\"realm\") && entity.hasOwnProperty(\"target\") && (entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN || entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);\n}\n/**\n * Validates an entity: checks for all expected params\n * @param entity\n */\nfunction isIdTokenEntity(entity) {\n  if (!entity) {\n    return false;\n  }\n  return isCredentialEntity(entity) && entity.hasOwnProperty(\"realm\") && entity[\"credentialType\"] === CredentialType.ID_TOKEN;\n}\n/**\n * Validates an entity: checks for all expected params\n * @param entity\n */\nfunction isRefreshTokenEntity(entity) {\n  if (!entity) {\n    return false;\n  }\n  return isCredentialEntity(entity) && entity[\"credentialType\"] === CredentialType.REFRESH_TOKEN;\n}\n/**\n * Generate Account Id key component as per the schema: <home_account_id>-<environment>\n */\nfunction generateAccountId(credentialEntity) {\n  const accountId = [credentialEntity.homeAccountId, credentialEntity.environment];\n  return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n}\n/**\n * Generate Credential Id key component as per the schema: <credential_type>-<client_id>-<realm>\n */\nfunction generateCredentialId(credentialEntity) {\n  const clientOrFamilyId = credentialEntity.credentialType === CredentialType.REFRESH_TOKEN ? credentialEntity.familyId || credentialEntity.clientId : credentialEntity.clientId;\n  const credentialId = [credentialEntity.credentialType, clientOrFamilyId, credentialEntity.realm || \"\"];\n  return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n}\n/**\n * Generate target key component as per schema: <target>\n */\nfunction generateTarget(credentialEntity) {\n  return (credentialEntity.target || \"\").toLowerCase();\n}\n/**\n * Generate requested claims key component as per schema: <requestedClaims>\n */\nfunction generateClaimsHash(credentialEntity) {\n  return (credentialEntity.requestedClaimsHash || \"\").toLowerCase();\n}\n/**\n * Generate scheme key componenet as per schema: <scheme>\n */\nfunction generateScheme(credentialEntity) {\n  /*\n   * PoP Tokens and SSH certs include scheme in cache key\n   * Cast to lowercase to handle \"bearer\" from ADFS\n   */\n  return credentialEntity.tokenType && credentialEntity.tokenType.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? credentialEntity.tokenType.toLowerCase() : \"\";\n}\n/**\n * validates if a given cache entry is \"Telemetry\", parses <key,value>\n * @param key\n * @param entity\n */\nfunction isServerTelemetryEntity(key, entity) {\n  const validateKey = key.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;\n  let validateEntity = true;\n  if (entity) {\n    validateEntity = entity.hasOwnProperty(\"failedRequests\") && entity.hasOwnProperty(\"errors\") && entity.hasOwnProperty(\"cacheHits\");\n  }\n  return validateKey && validateEntity;\n}\nexport { createAccessTokenEntity, createIdTokenEntity, createRefreshTokenEntity, generateCredentialKey, isAccessTokenEntity, isCredentialEntity, isIdTokenEntity, isRefreshTokenEntity, isServerTelemetryEntity };\n//# sourceMappingURL=CacheHelpers.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}