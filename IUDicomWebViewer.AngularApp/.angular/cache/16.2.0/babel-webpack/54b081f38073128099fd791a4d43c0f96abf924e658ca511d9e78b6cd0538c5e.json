{"ast":null,"code":"/*! @azure/msal-browser v3.6.0 2023-12-01 */\n'use strict';\n\nimport _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { PerformanceEvents, PromptValue, invokeAsync, AuthError, invoke, ProtocolUtils } from '@azure/msal-common';\nimport { StandardInteractionClient } from './StandardInteractionClient.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { InteractionType } from '../utils/BrowserConstants.mjs';\nimport { initiateAuthRequest, monitorIframeForHash } from '../interaction_handler/SilentHandler.mjs';\nimport { NativeMessageHandler } from '../broker/nativeBroker/NativeMessageHandler.mjs';\nimport { NativeInteractionClient } from './NativeInteractionClient.mjs';\nimport { InteractionHandler } from '../interaction_handler/InteractionHandler.mjs';\nimport { preconnect } from '../utils/BrowserUtils.mjs';\nimport { deserializeResponse } from '../response/ResponseHandler.mjs';\nimport { silentPromptValueError, silentLogoutUnsupported, nativeConnectionNotEstablished } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass SilentIframeClient extends StandardInteractionClient {\n  constructor(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, apiId, performanceClient, nativeStorageImpl, nativeMessageHandler, correlationId) {\n    super(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId);\n    this.apiId = apiId;\n    this.nativeStorage = nativeStorageImpl;\n  }\n  /**\n   * Acquires a token silently by opening a hidden iframe to the /authorize endpoint with prompt=none or prompt=no_session\n   * @param request\n   */\n  acquireToken(request) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentIframeClientAcquireToken, request.correlationId);\n      // Check that we have some SSO data\n      if (!request.loginHint && !request.sid && (!request.account || !request.account.username)) {\n        _this.logger.warning(\"No user hint provided. The authorization server may need more information to complete this request.\");\n      }\n      // Check that prompt is set to none or no_session, throw error if it is set to anything else.\n      if (request.prompt && request.prompt !== PromptValue.NONE && request.prompt !== PromptValue.NO_SESSION) {\n        throw createBrowserAuthError(silentPromptValueError);\n      }\n      // Create silent request\n      const silentRequest = yield invokeAsync(_this.initializeAuthorizationRequest.bind(_this), PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, _this.logger, _this.performanceClient, request.correlationId)({\n        ...request,\n        prompt: request.prompt || PromptValue.NONE\n      }, InteractionType.Silent);\n      preconnect(silentRequest.authority);\n      const serverTelemetryManager = _this.initializeServerTelemetryManager(_this.apiId);\n      try {\n        // Initialize the client\n        const authClient = yield invokeAsync(_this.createAuthCodeClient.bind(_this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, _this.logger, _this.performanceClient, request.correlationId)(serverTelemetryManager, silentRequest.authority, silentRequest.azureCloudOptions);\n        return yield invokeAsync(_this.silentTokenHelper.bind(_this), PerformanceEvents.SilentIframeClientTokenHelper, _this.logger, _this.performanceClient, request.correlationId)(authClient, silentRequest);\n      } catch (e) {\n        if (e instanceof AuthError) {\n          e.setCorrelationId(_this.correlationId);\n          serverTelemetryManager.cacheFailedRequest(e);\n        }\n        throw e;\n      }\n    })();\n  }\n  /**\n   * Currently Unsupported\n   */\n  logout() {\n    // Synchronous so we must reject\n    return Promise.reject(createBrowserAuthError(silentLogoutUnsupported));\n  }\n  /**\n   * Helper which acquires an authorization code silently using a hidden iframe from given url\n   * using the scopes requested as part of the id, and exchanges the code for a set of OAuth tokens.\n   * @param navigateUrl\n   * @param userRequestScopes\n   */\n  silentTokenHelper(authClient, silentRequest) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const correlationId = silentRequest.correlationId;\n      _this2.performanceClient.addQueueMeasurement(PerformanceEvents.SilentIframeClientTokenHelper, correlationId);\n      // Create auth code request and generate PKCE params\n      const authCodeRequest = yield invokeAsync(_this2.initializeAuthorizationCodeRequest.bind(_this2), PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, _this2.logger, _this2.performanceClient, correlationId)(silentRequest);\n      // Create authorize request url\n      const navigateUrl = yield invokeAsync(authClient.getAuthCodeUrl.bind(authClient), PerformanceEvents.GetAuthCodeUrl, _this2.logger, _this2.performanceClient, correlationId)({\n        ...silentRequest,\n        nativeBroker: NativeMessageHandler.isNativeAvailable(_this2.config, _this2.logger, _this2.nativeMessageHandler, silentRequest.authenticationScheme)\n      });\n      // Create silent handler\n      const interactionHandler = new InteractionHandler(authClient, _this2.browserStorage, authCodeRequest, _this2.logger, _this2.performanceClient);\n      // Get the frame handle for the silent request\n      const msalFrame = yield invokeAsync(initiateAuthRequest, PerformanceEvents.SilentHandlerInitiateAuthRequest, _this2.logger, _this2.performanceClient, correlationId)(navigateUrl, _this2.performanceClient, _this2.logger, correlationId, _this2.config.system.navigateFrameWait);\n      const responseType = _this2.config.auth.OIDCOptions.serverResponseType;\n      // Monitor the window for the hash. Return the string value and close the popup when the hash is received. Default timeout is 60 seconds.\n      const responseString = yield invokeAsync(monitorIframeForHash, PerformanceEvents.SilentHandlerMonitorIframeForHash, _this2.logger, _this2.performanceClient, correlationId)(msalFrame, _this2.config.system.iframeHashTimeout, _this2.config.system.pollIntervalMilliseconds, _this2.performanceClient, _this2.logger, correlationId, responseType);\n      const serverParams = invoke(deserializeResponse, PerformanceEvents.DeserializeResponse, _this2.logger, _this2.performanceClient, _this2.correlationId)(responseString, responseType, _this2.logger);\n      if (serverParams.accountId) {\n        _this2.logger.verbose(\"Account id found in hash, calling WAM for token\");\n        if (!_this2.nativeMessageHandler) {\n          throw createBrowserAuthError(nativeConnectionNotEstablished);\n        }\n        const nativeInteractionClient = new NativeInteractionClient(_this2.config, _this2.browserStorage, _this2.browserCrypto, _this2.logger, _this2.eventHandler, _this2.navigationClient, _this2.apiId, _this2.performanceClient, _this2.nativeMessageHandler, serverParams.accountId, _this2.browserStorage, correlationId);\n        const {\n          userRequestState\n        } = ProtocolUtils.parseRequestState(_this2.browserCrypto, silentRequest.state);\n        return invokeAsync(nativeInteractionClient.acquireToken.bind(nativeInteractionClient), PerformanceEvents.NativeInteractionClientAcquireToken, _this2.logger, _this2.performanceClient, correlationId)({\n          ...silentRequest,\n          state: userRequestState,\n          prompt: silentRequest.prompt || PromptValue.NONE\n        });\n      }\n      // Handle response from hash string\n      return invokeAsync(interactionHandler.handleCodeResponse.bind(interactionHandler), PerformanceEvents.HandleCodeResponse, _this2.logger, _this2.performanceClient, correlationId)(serverParams, silentRequest);\n    })();\n  }\n}\nexport { SilentIframeClient };\n//# sourceMappingURL=SilentIframeClient.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}