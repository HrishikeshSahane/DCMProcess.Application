{"ast":null,"code":"var Utils = require(\"../util\"),\n  Constants = Utils.Constants;\n\n/* The central directory file header */\nmodule.exports = function () {\n  var _verMade = 20,\n    // v2.0\n    _version = 10,\n    // v1.0\n    _flags = 0,\n    _method = 0,\n    _time = 0,\n    _crc = 0,\n    _compressedSize = 0,\n    _size = 0,\n    _fnameLen = 0,\n    _extraLen = 0,\n    _comLen = 0,\n    _diskStart = 0,\n    _inattr = 0,\n    _attr = 0,\n    _offset = 0;\n  _verMade |= Utils.isWin ? 0x0a00 : 0x0300;\n\n  // Set EFS flag since filename and comment fields are all by default encoded using UTF-8.\n  // Without it file names may be corrupted for other apps when file names use unicode chars\n  _flags |= Constants.FLG_EFS;\n  var _dataHeader = {};\n  function setTime(val) {\n    val = new Date(val);\n    _time = (val.getFullYear() - 1980 & 0x7f) << 25 |\n    // b09-16 years from 1980\n    val.getMonth() + 1 << 21 |\n    // b05-08 month\n    val.getDate() << 16 |\n    // b00-04 hour\n    // 2 bytes time\n    val.getHours() << 11 |\n    // b11-15 hour\n    val.getMinutes() << 5 |\n    // b05-10 minute\n    val.getSeconds() >> 1; // b00-04 seconds divided by 2\n  }\n\n  setTime(+new Date());\n  return {\n    get made() {\n      return _verMade;\n    },\n    set made(val) {\n      _verMade = val;\n    },\n    get version() {\n      return _version;\n    },\n    set version(val) {\n      _version = val;\n    },\n    get flags() {\n      return _flags;\n    },\n    set flags(val) {\n      _flags = val;\n    },\n    get method() {\n      return _method;\n    },\n    set method(val) {\n      switch (val) {\n        case Constants.STORED:\n          this.version = 10;\n        case Constants.DEFLATED:\n        default:\n          this.version = 20;\n      }\n      _method = val;\n    },\n    get time() {\n      return new Date((_time >> 25 & 0x7f) + 1980, (_time >> 21 & 0x0f) - 1, _time >> 16 & 0x1f, _time >> 11 & 0x1f, _time >> 5 & 0x3f, (_time & 0x1f) << 1);\n    },\n    set time(val) {\n      setTime(val);\n    },\n    get crc() {\n      return _crc;\n    },\n    set crc(val) {\n      _crc = Math.max(0, val) >>> 0;\n    },\n    get compressedSize() {\n      return _compressedSize;\n    },\n    set compressedSize(val) {\n      _compressedSize = Math.max(0, val) >>> 0;\n    },\n    get size() {\n      return _size;\n    },\n    set size(val) {\n      _size = Math.max(0, val) >>> 0;\n    },\n    get fileNameLength() {\n      return _fnameLen;\n    },\n    set fileNameLength(val) {\n      _fnameLen = val;\n    },\n    get extraLength() {\n      return _extraLen;\n    },\n    set extraLength(val) {\n      _extraLen = val;\n    },\n    get commentLength() {\n      return _comLen;\n    },\n    set commentLength(val) {\n      _comLen = val;\n    },\n    get diskNumStart() {\n      return _diskStart;\n    },\n    set diskNumStart(val) {\n      _diskStart = Math.max(0, val) >>> 0;\n    },\n    get inAttr() {\n      return _inattr;\n    },\n    set inAttr(val) {\n      _inattr = Math.max(0, val) >>> 0;\n    },\n    get attr() {\n      return _attr;\n    },\n    set attr(val) {\n      _attr = Math.max(0, val) >>> 0;\n    },\n    // get Unix file permissions\n    get fileAttr() {\n      return _attr ? (_attr >>> 0 | 0) >> 16 & 0xfff : 0;\n    },\n    get offset() {\n      return _offset;\n    },\n    set offset(val) {\n      _offset = Math.max(0, val) >>> 0;\n    },\n    get encripted() {\n      return (_flags & 1) === 1;\n    },\n    get entryHeaderSize() {\n      return Constants.CENHDR + _fnameLen + _extraLen + _comLen;\n    },\n    get realDataOffset() {\n      return _offset + Constants.LOCHDR + _dataHeader.fnameLen + _dataHeader.extraLen;\n    },\n    get dataHeader() {\n      return _dataHeader;\n    },\n    loadDataHeaderFromBinary: function ( /*Buffer*/input) {\n      var data = input.slice(_offset, _offset + Constants.LOCHDR);\n      // 30 bytes and should start with \"PK\\003\\004\"\n      if (data.readUInt32LE(0) !== Constants.LOCSIG) {\n        throw new Error(Utils.Errors.INVALID_LOC);\n      }\n      _dataHeader = {\n        // version needed to extract\n        version: data.readUInt16LE(Constants.LOCVER),\n        // general purpose bit flag\n        flags: data.readUInt16LE(Constants.LOCFLG),\n        // compression method\n        method: data.readUInt16LE(Constants.LOCHOW),\n        // modification time (2 bytes time, 2 bytes date)\n        time: data.readUInt32LE(Constants.LOCTIM),\n        // uncompressed file crc-32 value\n        crc: data.readUInt32LE(Constants.LOCCRC),\n        // compressed size\n        compressedSize: data.readUInt32LE(Constants.LOCSIZ),\n        // uncompressed size\n        size: data.readUInt32LE(Constants.LOCLEN),\n        // filename length\n        fnameLen: data.readUInt16LE(Constants.LOCNAM),\n        // extra field length\n        extraLen: data.readUInt16LE(Constants.LOCEXT)\n      };\n    },\n    loadFromBinary: function ( /*Buffer*/data) {\n      // data should be 46 bytes and start with \"PK 01 02\"\n      if (data.length !== Constants.CENHDR || data.readUInt32LE(0) !== Constants.CENSIG) {\n        throw new Error(Utils.Errors.INVALID_CEN);\n      }\n      // version made by\n      _verMade = data.readUInt16LE(Constants.CENVEM);\n      // version needed to extract\n      _version = data.readUInt16LE(Constants.CENVER);\n      // encrypt, decrypt flags\n      _flags = data.readUInt16LE(Constants.CENFLG);\n      // compression method\n      _method = data.readUInt16LE(Constants.CENHOW);\n      // modification time (2 bytes time, 2 bytes date)\n      _time = data.readUInt32LE(Constants.CENTIM);\n      // uncompressed file crc-32 value\n      _crc = data.readUInt32LE(Constants.CENCRC);\n      // compressed size\n      _compressedSize = data.readUInt32LE(Constants.CENSIZ);\n      // uncompressed size\n      _size = data.readUInt32LE(Constants.CENLEN);\n      // filename length\n      _fnameLen = data.readUInt16LE(Constants.CENNAM);\n      // extra field length\n      _extraLen = data.readUInt16LE(Constants.CENEXT);\n      // file comment length\n      _comLen = data.readUInt16LE(Constants.CENCOM);\n      // volume number start\n      _diskStart = data.readUInt16LE(Constants.CENDSK);\n      // internal file attributes\n      _inattr = data.readUInt16LE(Constants.CENATT);\n      // external file attributes\n      _attr = data.readUInt32LE(Constants.CENATX);\n      // LOC header offset\n      _offset = data.readUInt32LE(Constants.CENOFF);\n    },\n    dataHeaderToBinary: function () {\n      // LOC header size (30 bytes)\n      var data = Buffer.alloc(Constants.LOCHDR);\n      // \"PK\\003\\004\"\n      data.writeUInt32LE(Constants.LOCSIG, 0);\n      // version needed to extract\n      data.writeUInt16LE(_version, Constants.LOCVER);\n      // general purpose bit flag\n      data.writeUInt16LE(_flags, Constants.LOCFLG);\n      // compression method\n      data.writeUInt16LE(_method, Constants.LOCHOW);\n      // modification time (2 bytes time, 2 bytes date)\n      data.writeUInt32LE(_time, Constants.LOCTIM);\n      // uncompressed file crc-32 value\n      data.writeUInt32LE(_crc, Constants.LOCCRC);\n      // compressed size\n      data.writeUInt32LE(_compressedSize, Constants.LOCSIZ);\n      // uncompressed size\n      data.writeUInt32LE(_size, Constants.LOCLEN);\n      // filename length\n      data.writeUInt16LE(_fnameLen, Constants.LOCNAM);\n      // extra field length\n      data.writeUInt16LE(_extraLen, Constants.LOCEXT);\n      return data;\n    },\n    entryHeaderToBinary: function () {\n      // CEN header size (46 bytes)\n      var data = Buffer.alloc(Constants.CENHDR + _fnameLen + _extraLen + _comLen);\n      // \"PK\\001\\002\"\n      data.writeUInt32LE(Constants.CENSIG, 0);\n      // version made by\n      data.writeUInt16LE(_verMade, Constants.CENVEM);\n      // version needed to extract\n      data.writeUInt16LE(_version, Constants.CENVER);\n      // encrypt, decrypt flags\n      data.writeUInt16LE(_flags, Constants.CENFLG);\n      // compression method\n      data.writeUInt16LE(_method, Constants.CENHOW);\n      // modification time (2 bytes time, 2 bytes date)\n      data.writeUInt32LE(_time, Constants.CENTIM);\n      // uncompressed file crc-32 value\n      data.writeUInt32LE(_crc, Constants.CENCRC);\n      // compressed size\n      data.writeUInt32LE(_compressedSize, Constants.CENSIZ);\n      // uncompressed size\n      data.writeUInt32LE(_size, Constants.CENLEN);\n      // filename length\n      data.writeUInt16LE(_fnameLen, Constants.CENNAM);\n      // extra field length\n      data.writeUInt16LE(_extraLen, Constants.CENEXT);\n      // file comment length\n      data.writeUInt16LE(_comLen, Constants.CENCOM);\n      // volume number start\n      data.writeUInt16LE(_diskStart, Constants.CENDSK);\n      // internal file attributes\n      data.writeUInt16LE(_inattr, Constants.CENATT);\n      // external file attributes\n      data.writeUInt32LE(_attr, Constants.CENATX);\n      // LOC header offset\n      data.writeUInt32LE(_offset, Constants.CENOFF);\n      // fill all with\n      data.fill(0x00, Constants.CENHDR);\n      return data;\n    },\n    toJSON: function () {\n      const bytes = function (nr) {\n        return nr + \" bytes\";\n      };\n      return {\n        made: _verMade,\n        version: _version,\n        flags: _flags,\n        method: Utils.methodToString(_method),\n        time: this.time,\n        crc: \"0x\" + _crc.toString(16).toUpperCase(),\n        compressedSize: bytes(_compressedSize),\n        size: bytes(_size),\n        fileNameLength: bytes(_fnameLen),\n        extraLength: bytes(_extraLen),\n        commentLength: bytes(_comLen),\n        diskNumStart: _diskStart,\n        inAttr: _inattr,\n        attr: _attr,\n        offset: _offset,\n        entryHeaderSize: bytes(Constants.CENHDR + _fnameLen + _extraLen + _comLen)\n      };\n    },\n    toString: function () {\n      return JSON.stringify(this.toJSON(), null, \"\\t\");\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}