{"ast":null,"code":"/*! @azure/msal-browser v3.6.0 2023-12-01 */\n'use strict';\n\nimport { PerformanceClient, Constants, Logger } from '@azure/msal-common';\nimport { BrowserPerformanceMeasurement } from './BrowserPerformanceMeasurement.mjs';\nimport { name, version } from '../packageMetadata.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass BrowserPerformanceClient extends PerformanceClient {\n  constructor(configuration, intFields) {\n    super(configuration.auth.clientId, configuration.auth.authority || `${Constants.DEFAULT_AUTHORITY}`, new Logger(configuration.system?.loggerOptions || {}, name, version), name, version, configuration.telemetry?.application || {\n      appName: \"\",\n      appVersion: \"\"\n    }, intFields);\n  }\n  startPerformanceMeasurement(measureName, correlationId) {\n    return new BrowserPerformanceMeasurement(measureName, correlationId);\n  }\n  generateId() {\n    return window.crypto.randomUUID();\n  }\n  getPageVisibility() {\n    return document.visibilityState?.toString() || null;\n  }\n  deleteIncompleteSubMeasurements(inProgressEvent) {\n    const rootEvent = this.eventsByCorrelationId.get(inProgressEvent.event.correlationId);\n    const isRootEvent = rootEvent && rootEvent.eventId === inProgressEvent.event.eventId;\n    const incompleteMeasurements = [];\n    if (isRootEvent && rootEvent?.incompleteSubMeasurements) {\n      rootEvent.incompleteSubMeasurements.forEach(subMeasurement => {\n        incompleteMeasurements.push({\n          ...subMeasurement\n        });\n      });\n    }\n    // Clean up remaining marks for incomplete sub-measurements\n    if (incompleteMeasurements.length > 0) {\n      BrowserPerformanceMeasurement.flushMeasurements(inProgressEvent.event.correlationId, incompleteMeasurements);\n    }\n  }\n  supportsBrowserPerformanceNow() {\n    return typeof window !== \"undefined\" && typeof window.performance !== \"undefined\" && typeof window.performance.now === \"function\";\n  }\n  /**\n   * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\n   * Also captures browser page visibilityState.\n   *\n   * @param {PerformanceEvents} measureName\n   * @param {?string} [correlationId]\n   * @returns {((event?: Partial<PerformanceEvent>) => PerformanceEvent| null)}\n   */\n  startMeasurement(measureName, correlationId) {\n    // Capture page visibilityState and then invoke start/end measurement\n    const startPageVisibility = this.getPageVisibility();\n    const inProgressEvent = super.startMeasurement(measureName, correlationId);\n    return {\n      ...inProgressEvent,\n      end: event => {\n        const res = inProgressEvent.end({\n          startPageVisibility,\n          endPageVisibility: this.getPageVisibility(),\n          ...event\n        });\n        this.deleteIncompleteSubMeasurements(inProgressEvent);\n        return res;\n      },\n      discard: () => {\n        inProgressEvent.discard();\n        this.deleteIncompleteSubMeasurements(inProgressEvent);\n        inProgressEvent.measurement.flushMeasurement();\n      }\n    };\n  }\n  /**\n   * Adds pre-queue time to preQueueTimeByCorrelationId map.\n   * @param {PerformanceEvents} eventName\n   * @param {?string} correlationId\n   * @returns\n   */\n  setPreQueueTime(eventName, correlationId) {\n    if (!this.supportsBrowserPerformanceNow()) {\n      this.logger.trace(`BrowserPerformanceClient: window performance API not available, unable to set telemetry queue time for ${eventName}`);\n      return;\n    }\n    if (!correlationId) {\n      this.logger.trace(`BrowserPerformanceClient: correlationId for ${eventName} not provided, unable to set telemetry queue time`);\n      return;\n    }\n    const preQueueEvent = this.preQueueTimeByCorrelationId.get(correlationId);\n    /**\n     * Manually complete queue measurement if there is an incomplete pre-queue event.\n     * Incomplete pre-queue events are instrumentation bugs that should be fixed.\n     */\n    if (preQueueEvent) {\n      this.logger.trace(`BrowserPerformanceClient: Incomplete pre-queue ${preQueueEvent.name} found`, correlationId);\n      this.addQueueMeasurement(preQueueEvent.name, correlationId, undefined, true);\n    }\n    this.preQueueTimeByCorrelationId.set(correlationId, {\n      name: eventName,\n      time: window.performance.now()\n    });\n  }\n  /**\n   * Calculates and adds queue time measurement for given performance event.\n   *\n   * @param {PerformanceEvents} eventName\n   * @param {?string} correlationId\n   * @param {?number} queueTime\n   * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements\n   * @returns\n   */\n  addQueueMeasurement(eventName, correlationId, queueTime, manuallyCompleted) {\n    if (!this.supportsBrowserPerformanceNow()) {\n      this.logger.trace(`BrowserPerformanceClient: window performance API not available, unable to add queue measurement for ${eventName}`);\n      return;\n    }\n    if (!correlationId) {\n      this.logger.trace(`BrowserPerformanceClient: correlationId for ${eventName} not provided, unable to add queue measurement`);\n      return;\n    }\n    const preQueueTime = super.getPreQueueTime(eventName, correlationId);\n    if (!preQueueTime) {\n      return;\n    }\n    const currentTime = window.performance.now();\n    const resQueueTime = queueTime || super.calculateQueuedTime(preQueueTime, currentTime);\n    return super.addQueueMeasurement(eventName, correlationId, resQueueTime, manuallyCompleted);\n  }\n}\nexport { BrowserPerformanceClient };\n//# sourceMappingURL=BrowserPerformanceClient.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}