{"ast":null,"code":"import _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AggregateAuthenticationError, CredentialUnavailableError } from \"../errors\";\nimport { credentialLogger, formatError, formatSuccess } from \"../util/logging\";\nimport { tracingClient } from \"../util/tracing\";\n/**\n * @internal\n */\nexport const logger = credentialLogger(\"ChainedTokenCredential\");\n/**\n * Enables multiple `TokenCredential` implementations to be tried in order\n * until one of the getToken methods returns an access token.\n */\nexport class ChainedTokenCredential {\n  /**\n   * Creates an instance of ChainedTokenCredential using the given credentials.\n   *\n   * @param sources - `TokenCredential` implementations to be tried in order.\n   *\n   * Example usage:\n   * ```javascript\n   * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);\n   * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);\n   * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);\n   * ```\n   */\n  constructor(...sources) {\n    this._sources = [];\n    this._sources = sources;\n  }\n  /**\n   * Returns the first access token returned by one of the chained\n   * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}\n   * when one or more credentials throws an {@link AuthenticationError} and\n   * no credentials have returned an access token.\n   *\n   * This method is called automatically by Azure SDK client libraries. You may call this method\n   * directly, but you must also handle token caching and token refreshing.\n   *\n   * @param scopes - The list of scopes for which the token will have access.\n   * @param options - The options used to configure any requests this\n   *                `TokenCredential` implementation might make.\n   */\n  getToken(scopes, options = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const {\n        token\n      } = yield _this.getTokenInternal(scopes, options);\n      return token;\n    })();\n  }\n  getTokenInternal(scopes, options = {}) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      let token = null;\n      let successfulCredential;\n      const errors = [];\n      return tracingClient.withSpan(\"ChainedTokenCredential.getToken\", options, /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (updatedOptions) {\n          for (let i = 0; i < _this2._sources.length && token === null; i++) {\n            try {\n              token = yield _this2._sources[i].getToken(scopes, updatedOptions);\n              successfulCredential = _this2._sources[i];\n            } catch (err) {\n              if (err.name === \"CredentialUnavailableError\" || err.name === \"AuthenticationRequiredError\") {\n                errors.push(err);\n              } else {\n                logger.getToken.info(formatError(scopes, err));\n                throw err;\n              }\n            }\n          }\n          if (!token && errors.length > 0) {\n            const err = new AggregateAuthenticationError(errors, \"ChainedTokenCredential authentication failed.\");\n            logger.getToken.info(formatError(scopes, err));\n            throw err;\n          }\n          logger.getToken.info(`Result for ${successfulCredential.constructor.name}: ${formatSuccess(scopes)}`);\n          if (token === null) {\n            throw new CredentialUnavailableError(\"Failed to retrieve a valid token\");\n          }\n          return {\n            token,\n            successfulCredential\n          };\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n}\n//# sourceMappingURL=chainedTokenCredential.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}