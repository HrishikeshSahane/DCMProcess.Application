{"ast":null,"code":"import _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { initOperation, pollOperation } from \"../poller/operation\";\nimport { logger } from \"../logger\";\nfunction getOperationLocationPollingUrl(inputs) {\n  const {\n    azureAsyncOperation,\n    operationLocation\n  } = inputs;\n  return operationLocation !== null && operationLocation !== void 0 ? operationLocation : azureAsyncOperation;\n}\nfunction getLocationHeader(rawResponse) {\n  return rawResponse.headers[\"location\"];\n}\nfunction getOperationLocationHeader(rawResponse) {\n  return rawResponse.headers[\"operation-location\"];\n}\nfunction getAzureAsyncOperationHeader(rawResponse) {\n  return rawResponse.headers[\"azure-asyncoperation\"];\n}\nfunction findResourceLocation(inputs) {\n  var _a;\n  const {\n    location,\n    requestMethod,\n    requestPath,\n    resourceLocationConfig\n  } = inputs;\n  switch (requestMethod) {\n    case \"PUT\":\n      {\n        return requestPath;\n      }\n    case \"DELETE\":\n      {\n        return undefined;\n      }\n    case \"PATCH\":\n      {\n        return (_a = getDefault()) !== null && _a !== void 0 ? _a : requestPath;\n      }\n    default:\n      {\n        return getDefault();\n      }\n  }\n  function getDefault() {\n    switch (resourceLocationConfig) {\n      case \"azure-async-operation\":\n        {\n          return undefined;\n        }\n      case \"original-uri\":\n        {\n          return requestPath;\n        }\n      case \"location\":\n      default:\n        {\n          return location;\n        }\n    }\n  }\n}\nexport function inferLroMode(inputs) {\n  const {\n    rawResponse,\n    requestMethod,\n    requestPath,\n    resourceLocationConfig\n  } = inputs;\n  const operationLocation = getOperationLocationHeader(rawResponse);\n  const azureAsyncOperation = getAzureAsyncOperationHeader(rawResponse);\n  const pollingUrl = getOperationLocationPollingUrl({\n    operationLocation,\n    azureAsyncOperation\n  });\n  const location = getLocationHeader(rawResponse);\n  const normalizedRequestMethod = requestMethod === null || requestMethod === void 0 ? void 0 : requestMethod.toLocaleUpperCase();\n  if (pollingUrl !== undefined) {\n    return {\n      mode: \"OperationLocation\",\n      operationLocation: pollingUrl,\n      resourceLocation: findResourceLocation({\n        requestMethod: normalizedRequestMethod,\n        location,\n        requestPath,\n        resourceLocationConfig\n      })\n    };\n  } else if (location !== undefined) {\n    return {\n      mode: \"ResourceLocation\",\n      operationLocation: location\n    };\n  } else if (normalizedRequestMethod === \"PUT\" && requestPath) {\n    return {\n      mode: \"Body\",\n      operationLocation: requestPath\n    };\n  } else {\n    return undefined;\n  }\n}\nfunction transformStatus(inputs) {\n  const {\n    status,\n    statusCode\n  } = inputs;\n  if (typeof status !== \"string\" && status !== undefined) {\n    throw new Error(`Polling was unsuccessful. Expected status to have a string value or no value but it has instead: ${status}. This doesn't necessarily indicate the operation has failed. Check your Azure subscription or resource status for more information.`);\n  }\n  switch (status === null || status === void 0 ? void 0 : status.toLocaleLowerCase()) {\n    case undefined:\n      return toOperationStatus(statusCode);\n    case \"succeeded\":\n      return \"succeeded\";\n    case \"failed\":\n      return \"failed\";\n    case \"running\":\n    case \"accepted\":\n    case \"started\":\n    case \"canceling\":\n    case \"cancelling\":\n      return \"running\";\n    case \"canceled\":\n    case \"cancelled\":\n      return \"canceled\";\n    default:\n      {\n        logger.verbose(`LRO: unrecognized operation status: ${status}`);\n        return status;\n      }\n  }\n}\nfunction getStatus(rawResponse) {\n  var _a;\n  const {\n    status\n  } = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {};\n  return transformStatus({\n    status,\n    statusCode: rawResponse.statusCode\n  });\n}\nfunction getProvisioningState(rawResponse) {\n  var _a, _b;\n  const {\n    properties,\n    provisioningState\n  } = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {};\n  const status = (_b = properties === null || properties === void 0 ? void 0 : properties.provisioningState) !== null && _b !== void 0 ? _b : provisioningState;\n  return transformStatus({\n    status,\n    statusCode: rawResponse.statusCode\n  });\n}\nfunction toOperationStatus(statusCode) {\n  if (statusCode === 202) {\n    return \"running\";\n  } else if (statusCode < 300) {\n    return \"succeeded\";\n  } else {\n    return \"failed\";\n  }\n}\nexport function parseRetryAfter({\n  rawResponse\n}) {\n  const retryAfter = rawResponse.headers[\"retry-after\"];\n  if (retryAfter !== undefined) {\n    // Retry-After header value is either in HTTP date format, or in seconds\n    const retryAfterInSeconds = parseInt(retryAfter);\n    return isNaN(retryAfterInSeconds) ? calculatePollingIntervalFromDate(new Date(retryAfter)) : retryAfterInSeconds * 1000;\n  }\n  return undefined;\n}\nexport function getErrorFromResponse(response) {\n  const error = response.flatResponse.error;\n  if (!error) {\n    logger.warning(`The long-running operation failed but there is no error property in the response's body`);\n    return;\n  }\n  if (!error.code || !error.message) {\n    logger.warning(`The long-running operation failed but the error property in the response's body doesn't contain code or message`);\n    return;\n  }\n  return error;\n}\nfunction calculatePollingIntervalFromDate(retryAfterDate) {\n  const timeNow = Math.floor(new Date().getTime());\n  const retryAfterTime = retryAfterDate.getTime();\n  if (timeNow < retryAfterTime) {\n    return retryAfterTime - timeNow;\n  }\n  return undefined;\n}\nexport function getStatusFromInitialResponse(inputs) {\n  const {\n    response,\n    state,\n    operationLocation\n  } = inputs;\n  function helper() {\n    var _a;\n    const mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a[\"mode\"];\n    switch (mode) {\n      case undefined:\n        return toOperationStatus(response.rawResponse.statusCode);\n      case \"Body\":\n        return getOperationStatus(response, state);\n      default:\n        return \"running\";\n    }\n  }\n  const status = helper();\n  return status === \"running\" && operationLocation === undefined ? \"succeeded\" : status;\n}\n/**\n * Initiates the long-running operation.\n */\nexport function initHttpOperation(_x) {\n  return _initHttpOperation.apply(this, arguments);\n}\nfunction _initHttpOperation() {\n  _initHttpOperation = _asyncToGenerator(function* (inputs) {\n    const {\n      stateProxy,\n      resourceLocationConfig,\n      processResult,\n      lro,\n      setErrorAsResult\n    } = inputs;\n    return initOperation({\n      init: function () {\n        var _ref = _asyncToGenerator(function* () {\n          const response = yield lro.sendInitialRequest();\n          const config = inferLroMode({\n            rawResponse: response.rawResponse,\n            requestPath: lro.requestPath,\n            requestMethod: lro.requestMethod,\n            resourceLocationConfig\n          });\n          return Object.assign({\n            response,\n            operationLocation: config === null || config === void 0 ? void 0 : config.operationLocation,\n            resourceLocation: config === null || config === void 0 ? void 0 : config.resourceLocation\n          }, (config === null || config === void 0 ? void 0 : config.mode) ? {\n            metadata: {\n              mode: config.mode\n            }\n          } : {});\n        });\n        return function init() {\n          return _ref.apply(this, arguments);\n        };\n      }(),\n      stateProxy,\n      processResult: processResult ? ({\n        flatResponse\n      }, state) => processResult(flatResponse, state) : ({\n        flatResponse\n      }) => flatResponse,\n      getOperationStatus: getStatusFromInitialResponse,\n      setErrorAsResult\n    });\n  });\n  return _initHttpOperation.apply(this, arguments);\n}\nexport function getOperationLocation({\n  rawResponse\n}, state) {\n  var _a;\n  const mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a[\"mode\"];\n  switch (mode) {\n    case \"OperationLocation\":\n      {\n        return getOperationLocationPollingUrl({\n          operationLocation: getOperationLocationHeader(rawResponse),\n          azureAsyncOperation: getAzureAsyncOperationHeader(rawResponse)\n        });\n      }\n    case \"ResourceLocation\":\n      {\n        return getLocationHeader(rawResponse);\n      }\n    case \"Body\":\n    default:\n      {\n        return undefined;\n      }\n  }\n}\nexport function getOperationStatus({\n  rawResponse\n}, state) {\n  var _a;\n  const mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a[\"mode\"];\n  switch (mode) {\n    case \"OperationLocation\":\n      {\n        return getStatus(rawResponse);\n      }\n    case \"ResourceLocation\":\n      {\n        return toOperationStatus(rawResponse.statusCode);\n      }\n    case \"Body\":\n      {\n        return getProvisioningState(rawResponse);\n      }\n    default:\n      throw new Error(`Internal error: Unexpected operation mode: ${mode}`);\n  }\n}\nexport function getResourceLocation({\n  flatResponse\n}, state) {\n  if (typeof flatResponse === \"object\") {\n    const resourceLocation = flatResponse.resourceLocation;\n    if (resourceLocation !== undefined) {\n      state.config.resourceLocation = resourceLocation;\n    }\n  }\n  return state.config.resourceLocation;\n}\nexport function isOperationError(e) {\n  return e.name === \"RestError\";\n}\n/** Polls the long-running operation. */\nexport function pollHttpOperation(_x2) {\n  return _pollHttpOperation.apply(this, arguments);\n}\n//# sourceMappingURL=operation.js.map\nfunction _pollHttpOperation() {\n  _pollHttpOperation = _asyncToGenerator(function* (inputs) {\n    const {\n      lro,\n      stateProxy,\n      options,\n      processResult,\n      updateState,\n      setDelay,\n      state,\n      setErrorAsResult\n    } = inputs;\n    return pollOperation({\n      state,\n      stateProxy,\n      setDelay,\n      processResult: processResult ? ({\n        flatResponse\n      }, inputState) => processResult(flatResponse, inputState) : ({\n        flatResponse\n      }) => flatResponse,\n      getError: getErrorFromResponse,\n      updateState,\n      getPollingInterval: parseRetryAfter,\n      getOperationLocation,\n      getOperationStatus,\n      isOperationError,\n      getResourceLocation,\n      options,\n      /**\n       * The expansion here is intentional because `lro` could be an object that\n       * references an inner this, so we need to preserve a reference to it.\n       */\n      poll: function () {\n        var _ref2 = _asyncToGenerator(function* (location, inputOptions) {\n          return lro.sendPollRequest(location, inputOptions);\n        });\n        return function poll(_x3, _x4) {\n          return _ref2.apply(this, arguments);\n        };\n      }(),\n      setErrorAsResult\n    });\n  });\n  return _pollHttpOperation.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}