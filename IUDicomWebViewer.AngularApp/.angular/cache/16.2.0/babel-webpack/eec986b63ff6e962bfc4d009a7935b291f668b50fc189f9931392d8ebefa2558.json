{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport * as msalCommon from \"@azure/msal-browser\";\nimport { AuthenticationRequiredError, CredentialUnavailableError } from \"../errors\";\nimport { formatError, formatSuccess } from \"../util/logging\";\nimport { DefaultAuthorityHost, DefaultTenantId } from \"../constants\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { isNode, randomUUID } from \"@azure/core-util\";\n/**\n * Latest AuthenticationRecord version\n * @internal\n */\nconst LatestAuthenticationRecordVersion = \"1.0\";\n/**\n * Ensures the validity of the MSAL token\n * @internal\n */\nexport function ensureValidMsalToken(scopes, logger, msalToken, getTokenOptions) {\n  const error = message => {\n    logger.getToken.info(message);\n    return new AuthenticationRequiredError({\n      scopes: Array.isArray(scopes) ? scopes : [scopes],\n      getTokenOptions,\n      message\n    });\n  };\n  if (!msalToken) {\n    throw error(\"No response\");\n  }\n  if (!msalToken.expiresOn) {\n    throw error(`Response had no \"expiresOn\" property.`);\n  }\n  if (!msalToken.accessToken) {\n    throw error(`Response had no \"accessToken\" property.`);\n  }\n}\n/**\n * Generates a valid authority by combining a host with a tenantId.\n * @internal\n */\nexport function getAuthority(tenantId, host) {\n  if (!host) {\n    host = DefaultAuthorityHost;\n  }\n  if (new RegExp(`${tenantId}/?$`).test(host)) {\n    return host;\n  }\n  if (host.endsWith(\"/\")) {\n    return host + tenantId;\n  } else {\n    return `${host}/${tenantId}`;\n  }\n}\n/**\n * Generates the known authorities.\n * If the Tenant Id is `adfs`, the authority can't be validated since the format won't match the expected one.\n * For that reason, we have to force MSAL to disable validating the authority\n * by sending it within the known authorities in the MSAL configuration.\n * @internal\n */\nexport function getKnownAuthorities(tenantId, authorityHost, disableInstanceDiscovery) {\n  if (tenantId === \"adfs\" && authorityHost || disableInstanceDiscovery) {\n    return [authorityHost];\n  }\n  return [];\n}\n/**\n * Generates a logger that can be passed to the MSAL clients.\n * @param logger - The logger of the credential.\n * @internal\n */\nexport const defaultLoggerCallback = (logger, platform = isNode ? \"Node\" : \"Browser\") => (level, message, containsPii) => {\n  if (containsPii) {\n    return;\n  }\n  switch (level) {\n    case msalCommon.LogLevel.Error:\n      logger.info(`MSAL ${platform} V2 error: ${message}`);\n      return;\n    case msalCommon.LogLevel.Info:\n      logger.info(`MSAL ${platform} V2 info message: ${message}`);\n      return;\n    case msalCommon.LogLevel.Verbose:\n      logger.info(`MSAL ${platform} V2 verbose message: ${message}`);\n      return;\n    case msalCommon.LogLevel.Warning:\n      logger.info(`MSAL ${platform} V2 warning: ${message}`);\n      return;\n  }\n};\n/**\n * @internal\n */\nexport function getMSALLogLevel(logLevel) {\n  switch (logLevel) {\n    case \"error\":\n      return msalCommon.LogLevel.Error;\n    case \"info\":\n      return msalCommon.LogLevel.Info;\n    case \"verbose\":\n      return msalCommon.LogLevel.Verbose;\n    case \"warning\":\n      return msalCommon.LogLevel.Warning;\n    default:\n      // default msal logging level should be Info\n      return msalCommon.LogLevel.Info;\n  }\n}\n/**\n * The common utility functions for the MSAL clients.\n * Defined as a class so that the classes extending this one can have access to its methods and protected properties.\n *\n * It keeps track of a logger and an in-memory copy of the AuthenticationRecord.\n *\n * @internal\n */\nexport class MsalBaseUtilities {\n  constructor(options) {\n    this.logger = options.logger;\n    this.account = options.authenticationRecord;\n  }\n  /**\n   * Generates a UUID\n   */\n  generateUuid() {\n    return randomUUID();\n  }\n  /**\n   * Handles the MSAL authentication result.\n   * If the result has an account, we update the local account reference.\n   * If the token received is invalid, an error will be thrown depending on what's missing.\n   */\n  handleResult(scopes, clientId, result, getTokenOptions) {\n    if (result === null || result === void 0 ? void 0 : result.account) {\n      this.account = msalToPublic(clientId, result.account);\n    }\n    ensureValidMsalToken(scopes, this.logger, result, getTokenOptions);\n    this.logger.getToken.info(formatSuccess(scopes));\n    return {\n      token: result.accessToken,\n      expiresOnTimestamp: result.expiresOn.getTime()\n    };\n  }\n  /**\n   * Handles MSAL errors.\n   */\n  handleError(scopes, error, getTokenOptions) {\n    if (error.name === \"AuthError\" || error.name === \"ClientAuthError\" || error.name === \"BrowserAuthError\") {\n      const msalError = error;\n      switch (msalError.errorCode) {\n        case \"endpoints_resolution_error\":\n          this.logger.info(formatError(scopes, error.message));\n          return new CredentialUnavailableError(error.message);\n        case \"device_code_polling_cancelled\":\n          return new AbortError(\"The authentication has been aborted by the caller.\");\n        case \"consent_required\":\n        case \"interaction_required\":\n        case \"login_required\":\n          this.logger.info(formatError(scopes, `Authentication returned errorCode ${msalError.errorCode}`));\n          break;\n        default:\n          this.logger.info(formatError(scopes, `Failed to acquire token: ${error.message}`));\n          break;\n      }\n    }\n    if (error.name === \"ClientConfigurationError\" || error.name === \"BrowserConfigurationAuthError\" || error.name === \"AbortError\") {\n      return error;\n    }\n    return new AuthenticationRequiredError({\n      scopes,\n      getTokenOptions,\n      message: error.message\n    });\n  }\n}\n// transformations.ts\nexport function publicToMsal(account) {\n  const [environment] = account.authority.match(/([a-z]*\\.[a-z]*\\.[a-z]*)/) || [\"\"];\n  return Object.assign(Object.assign({}, account), {\n    localAccountId: account.homeAccountId,\n    environment\n  });\n}\nexport function msalToPublic(clientId, account) {\n  const record = {\n    authority: getAuthority(account.tenantId, account.environment),\n    homeAccountId: account.homeAccountId,\n    tenantId: account.tenantId || DefaultTenantId,\n    username: account.username,\n    clientId,\n    version: LatestAuthenticationRecordVersion\n  };\n  return record;\n}\n/**\n * Serializes an `AuthenticationRecord` into a string.\n *\n * The output of a serialized authentication record will contain the following properties:\n *\n * - \"authority\"\n * - \"homeAccountId\"\n * - \"clientId\"\n * - \"tenantId\"\n * - \"username\"\n * - \"version\"\n *\n * To later convert this string to a serialized `AuthenticationRecord`, please use the exported function `deserializeAuthenticationRecord()`.\n */\nexport function serializeAuthenticationRecord(record) {\n  return JSON.stringify(record);\n}\n/**\n * Deserializes a previously serialized authentication record from a string into an object.\n *\n * The input string must contain the following properties:\n *\n * - \"authority\"\n * - \"homeAccountId\"\n * - \"clientId\"\n * - \"tenantId\"\n * - \"username\"\n * - \"version\"\n *\n * If the version we receive is unsupported, an error will be thrown.\n *\n * At the moment, the only available version is: \"1.0\", which is always set when the authentication record is serialized.\n *\n * @param serializedRecord - Authentication record previously serialized into string.\n * @returns AuthenticationRecord.\n */\nexport function deserializeAuthenticationRecord(serializedRecord) {\n  const parsed = JSON.parse(serializedRecord);\n  if (parsed.version && parsed.version !== LatestAuthenticationRecordVersion) {\n    throw Error(\"Unsupported AuthenticationRecord version\");\n  }\n  return parsed;\n}\n//# sourceMappingURL=utils.browser.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}