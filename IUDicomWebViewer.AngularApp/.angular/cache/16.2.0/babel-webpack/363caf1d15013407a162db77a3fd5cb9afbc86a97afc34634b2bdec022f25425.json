{"ast":null,"code":"import { __decorate, __metadata } from \"tslib\";\nimport { Component, ViewChild, Input, ViewChildren } from '@angular/core';\nimport { CornerstoneDirective } from './cornerstone.directive';\nimport { ThumbnailDirective } from './thumbnail.directive';\nexport let DICOMViewerComponent = class DICOMViewerComponent {\n  // control enable/disable image scroll buttons\n  get hidePreviousImage() {\n    return {\n      color: this.viewPort.currentIndex < 1 ? 'black' : 'white'\n    };\n  }\n  get hideNextImage() {\n    return {\n      color: this.viewPort.currentIndex >= this.imageCount - 1 ? 'black' : 'white'\n    };\n  }\n  // control message for more images to load\n  get moreImagestoLoad() {\n    if (this.loadedImages.length < this.imageIdList.length && !this.loadingImages) {\n      // are there any more images to load?\n      const imagesToLoad = this.maxImagesToLoad <= 0 ? this.imageIdList.length - this.loadedImages.length : Math.min(this.maxImagesToLoad, this.imageIdList.length - this.loadedImages.length);\n      return imagesToLoad.toString();\n    } else return '';\n  }\n  get showProgress() {\n    return {\n      display: this.loadingImages ? 'inline-block' : 'none'\n    };\n  }\n  constructor() {\n    this.enableViewerTools = false; // enable viewer tools\n    this.enablePlayTools = false; // enable Play Clip tools\n    this.downloadImagesURL = ''; // download images URL\n    this.maxImagesToLoad = 20; // limit for the automatic loading of study images\n    this.seriesList = []; // list of series on the images being displayed\n    this.currentSeriesIndex = 0;\n    this.currentSeries = {};\n    this.imageCount = 0; // total image count being viewed\n    // control exhibition of a loading images progress indicator\n    this.loadingImages = false;\n    this.loadedImages = [];\n    this.imageIdList = [];\n    this.targetImageCount = 0;\n  }\n  ngOnInit() {\n    this.element = this.viewPort.element;\n  }\n  /**\n   * Load dicom images for display\n   *\n   * @param imageIdList list of imageIds to load and display\n   */\n  loadStudyImages(imageIdList) {\n    this.element = this.viewPort.element;\n    this.imageIdList = imageIdList;\n    this.viewPort.resetViewer();\n    this.viewPort.resetImageCache(); // clean up image cache\n    this.seriesList = []; // start a new series list\n    this.currentSeriesIndex = 0; // always display first series\n    this.loadedImages = []; // reset list of images already loaded\n    //\n    // loop thru all imageIds, load and cache them for exhibition (up the the maximum limit defined)\n    //\n    const maxImages = this.maxImagesToLoad <= 0 ? imageIdList.length : Math.min(this.maxImagesToLoad, imageIdList.length);\n    this.loadingImages = true; // activate progress indicator\n    this.targetImageCount = maxImages;\n    for (let index = 0; index < maxImages; index++) {\n      const imageId = imageIdList[index];\n      cornerstone.loadAndCacheImage(imageId).then(imageData => {\n        this.imageLoaded(imageData);\n      });\n    }\n  }\n  /**\n   * Load the next batch of images\n   */\n  loadMoreImages() {\n    this.element = this.viewPort.element;\n    //\n    // loop thru all imageIds, load and cache them for exhibition (up the the maximum limit defined)\n    //\n    const maxImages = this.maxImagesToLoad <= 0 ? this.imageIdList.length - this.loadedImages.length : Math.min(this.maxImagesToLoad, this.imageIdList.length - this.loadedImages.length);\n    this.loadingImages = true; // activate progress indicator\n    this.targetImageCount += maxImages;\n    let nextImageIndex = this.loadedImages.length;\n    for (let index = 0; index < maxImages; index++) {\n      const imageId = this.imageIdList[nextImageIndex++];\n      cornerstone.loadAndCacheImage(imageId).then(imageData => {\n        this.imageLoaded(imageData);\n      }).catch(err => {\n        this.targetImageCount--;\n      });\n    }\n  }\n  /**\n   *\n   * @param imageData the dicom image data\n   */\n  imageLoaded(imageData) {\n    //console.log(imageData.imageId)\n    // build list of series in all loadded images\n    const series = {\n      studyID: imageData.data.string('x0020000d'),\n      seriesID: imageData.data.string('x0020000e'),\n      seriesNumber: imageData.data.intString('x00200011'),\n      studyDescription: imageData.data.string('x00081030'),\n      seriesDescription: imageData.data.string('x0008103e'),\n      imageCount: 1,\n      imageList: [imageData]\n    };\n    // if this is a new series, add it to the list\n    let seriesIndex = this.seriesList.findIndex(item => item.seriesID === series.seriesID);\n    if (seriesIndex < 0) {\n      seriesIndex = this.seriesList.length;\n      this.seriesList.push(series);\n      this.seriesList.sort((a, b) => {\n        if (a.seriesNumber > b.seriesNumber) return 1;\n        if (a.seriesNumber < b.seriesNumber) return -1;\n        return 0;\n      });\n    } else {\n      let seriesItem = this.seriesList[seriesIndex];\n      seriesItem.imageCount++;\n      seriesItem.imageList.push(imageData);\n      seriesItem.imageList.sort((a, b) => {\n        if (a.data.intString('x00200013') > b.data.intString('x00200013')) return 1;\n        if (a.data.intString('x00200013') < b.data.intString('x00200013')) return -1;\n        return 0;\n      });\n    }\n    this.loadedImages.push(imageData); // save to images loaded\n    if (seriesIndex === this.currentSeriesIndex) {\n      //this.currentSeries = this.seriesList[seriesIndex];\n      //this.imageCount = this.currentSeries.imageCount; // get total image count\n      //this.viewPort.addImageData(imageData);\n      this.showSeries(this.currentSeriesIndex);\n    }\n    if (this.loadedImages.length >= this.targetImageCount) {\n      // did we finish loading images?\n      this.loadingImages = false; // deactivate progress indicator\n    }\n  }\n\n  showSeries(index) {\n    //        this.resetAllTools();\n    this.currentSeriesIndex = index;\n    this.currentSeries = this.seriesList[index];\n    this.imageCount = this.currentSeries.imageCount; // get total image count\n    this.viewPort.resetImageCache(); // clean up image cache\n    //        this.loadingImages = true; // activate progress indicator\n    for (let i = 0; i < this.currentSeries.imageList.length; i++) {\n      const imageData = this.currentSeries.imageList[i];\n      this.viewPort.addImageData(imageData);\n    }\n    //        this.loadingImages = false; // de-activate progress indicator\n  }\n\n  saveAs() {\n    cornerstoneTools.saveAs(this.element, \"teste.jpg\");\n  }\n  /**\n   * Image scroll methods\n   */\n  nextImage() {\n    if (this.viewPort.currentIndex < this.imageCount) {\n      this.viewPort.nextImage();\n    }\n  }\n  previousImage() {\n    if (this.viewPort.currentIndex > 0) {\n      this.viewPort.previousImage();\n    }\n  }\n  /**\n   * Methods to activate/deactivate viewer tools\n   */\n  // deactivate all tools\n  resetAllTools() {\n    if (this.imageCount > 0) {\n      this.viewPort.resetAllTools();\n      this.stopClip();\n    }\n  }\n  // activate windowing\n  enableWindowing() {\n    if (this.imageCount > 0) {\n      this.resetAllTools();\n      // cornerstoneTools.wwwc.activate(this.element, 1);\n      // cornerstoneTools.wwwcTouchDrag.activate(this.element);\n      cornerstoneTools.setToolActiveForElement(this.element, 'Wwwc', {\n        mouseButtonMask: 1\n      }, ['Mouse']);\n    }\n  }\n  // activate zoom\n  enableZoom() {\n    if (this.imageCount > 0) {\n      this.resetAllTools();\n      // cornerstoneTools.zoom.activate(this.element, 5); // 5 is right mouse button and left mouse button\n      // cornerstoneTools.zoomTouchDrag.activate(this.element);\n      cornerstoneTools.setToolActiveForElement(this.element, 'Zoom', {\n        mouseButtonMask: 1\n      }, ['Mouse']); // zoom left mouse\n      // cornerstoneTools.setToolActiveForElement(this.element, 'ZoomTouchPinch', { }, ['Mouse']);\n      cornerstoneTools.setToolActiveForElement(this.element, 'Pan', {\n        mouseButtonMask: 2\n      }, ['Mouse']); // pan right mouse\n    }\n  }\n  // activate pan\n  enablePan() {\n    if (this.imageCount > 0) {\n      this.resetAllTools();\n      // cornerstoneTools.pan.activate(this.element, 3); // 3 is middle mouse button and left mouse button\n      // cornerstoneTools.panTouchDrag.activate(this.element);\n      cornerstoneTools.setToolActiveForElement(this.element, 'Pan', {\n        mouseButtonMask: 1\n      }, ['Mouse']);\n    }\n  }\n  // activate image scroll\n  enableScroll() {\n    if (this.imageCount > 0) {\n      this.resetAllTools();\n      // cornerstoneTools.stackScroll.activate(this.element, 1);\n      // cornerstoneTools.stackScrollTouchDrag.activate(this.element);\n      // cornerstoneTools.stackScrollKeyboard.activate(this.element);\n      cornerstoneTools.setToolActiveForElement(this.element, 'StackScroll', {\n        mouseButtonMask: 1\n      }, ['Mouse']);\n    }\n  }\n  // activate length measurement\n  enableLength() {\n    if (this.imageCount > 0) {\n      this.resetAllTools();\n      // cornerstoneTools.length.activate(this.element, 1);\n      cornerstoneTools.setToolActiveForElement(this.element, 'Length', {\n        mouseButtonMask: 1\n      }, ['Mouse']);\n    }\n  }\n  // activate angle measurement\n  enableAngle() {\n    if (this.imageCount > 0) {\n      this.resetAllTools();\n      // cornerstoneTools.simpleAngle.activate(this.element, 1);\n      cornerstoneTools.setToolActiveForElement(this.element, 'Angle', {\n        mouseButtonMask: 1\n      }, ['Mouse']);\n    }\n  }\n  // activate pixel probe\n  enableProbe() {\n    if (this.imageCount > 0) {\n      this.resetAllTools();\n      // cornerstoneTools.probe.activate(this.element, 1);\n      cornerstoneTools.setToolActiveForElement(this.element, 'Probe', {\n        mouseButtonMask: 1\n      }, ['Mouse']);\n    }\n  }\n  // activate Elliptical ROI\n  enableElliptical() {\n    if (this.imageCount > 0) {\n      this.resetAllTools();\n      // cornerstoneTools.ellipticalRoi.activate(this.element, 1);\n      cornerstoneTools.setToolActiveForElement(this.element, 'EllipticalRoi', {\n        mouseButtonMask: 1\n      }, ['Mouse']);\n    }\n  }\n  // activate Rectangle ROI\n  enableRectangle() {\n    if (this.imageCount > 0) {\n      this.resetAllTools();\n      // cornerstoneTools.rectangleRoi.activate(this.element, 1);\n      cornerstoneTools.setToolActiveForElement(this.element, 'RectangleRoi', {\n        mouseButtonMask: 1\n      }, ['Mouse']);\n    }\n  }\n  // Play Clip\n  playClip() {\n    if (this.imageCount > 0) {\n      let frameRate = 10;\n      let stackState = cornerstoneTools.getToolState(this.element, 'stack');\n      if (stackState) {\n        frameRate = stackState.data[0].frameRate;\n        // Play at a default 10 FPS if the framerate is not specified\n        if (frameRate === undefined || frameRate === null || frameRate === 0) {\n          frameRate = 10;\n        }\n      }\n      cornerstoneTools.playClip(this.element, frameRate);\n    }\n  }\n  // Stop Clip\n  stopClip() {\n    cornerstoneTools.stopClip(this.element);\n  }\n  // invert image\n  invertImage() {\n    if (this.imageCount > 0) {\n      let viewport = cornerstone.getViewport(this.element);\n      // Toggle invert\n      if (viewport.invert === true) {\n        viewport.invert = false;\n      } else {\n        viewport.invert = true;\n      }\n      cornerstone.setViewport(this.element, viewport);\n    }\n  }\n  // reset image\n  resetImage() {\n    if (this.imageCount > 0) {\n      let toolStateManager = cornerstoneTools.getElementToolStateManager(this.element);\n      // Note that this only works on ImageId-specific tool state managers (for now)\n      //toolStateManager.clear(this.element);\n      cornerstoneTools.clearToolState(this.element, \"Length\");\n      cornerstoneTools.clearToolState(this.element, \"Angle\");\n      // cornerstoneTools.clearToolState(this.element, \"simpleAngle\");\n      cornerstoneTools.clearToolState(this.element, \"Probe\");\n      cornerstoneTools.clearToolState(this.element, \"EllipticalRoi\");\n      cornerstoneTools.clearToolState(this.element, \"RectangleRoi\");\n      cornerstone.updateImage(this.element);\n      this.resetAllTools();\n    }\n  }\n  clearImage() {\n    this.viewPort.resetViewer();\n    this.viewPort.resetImageCache();\n    this.seriesList = []; // list of series on the images being displayed\n    this.currentSeriesIndex = 0;\n    this.currentSeries = {};\n    this.imageCount = 0; // total image count being viewed\n  }\n};\n\n__decorate([Input(), __metadata(\"design:type\", Object)], DICOMViewerComponent.prototype, \"enableViewerTools\", void 0);\n__decorate([Input(), __metadata(\"design:type\", Object)], DICOMViewerComponent.prototype, \"enablePlayTools\", void 0);\n__decorate([Input(), __metadata(\"design:type\", Object)], DICOMViewerComponent.prototype, \"downloadImagesURL\", void 0);\n__decorate([Input(), __metadata(\"design:type\", Object)], DICOMViewerComponent.prototype, \"maxImagesToLoad\", void 0);\n__decorate([ViewChild(CornerstoneDirective, {\n  static: true\n}), __metadata(\"design:type\", CornerstoneDirective)], DICOMViewerComponent.prototype, \"viewPort\", void 0);\n__decorate([ViewChildren(ThumbnailDirective), __metadata(\"design:type\", Array)], DICOMViewerComponent.prototype, \"thumbnails\", void 0);\nDICOMViewerComponent = __decorate([Component({\n  selector: 'dicom-viewer',\n  templateUrl: './dicom-viewer.component.html',\n  styleUrls: ['./dicom-viewer.component.css']\n}), __metadata(\"design:paramtypes\", [])], DICOMViewerComponent);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}