{"ast":null,"code":"/*! @azure/msal-common v14.5.0 2023-12-01 */\n'use strict';\n\nimport _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { ServerError } from '../error/ServerError.mjs';\nimport { ScopeSet } from '../request/ScopeSet.mjs';\nimport { AccountEntity } from '../cache/entities/AccountEntity.mjs';\nimport { isInteractionRequiredError, InteractionRequiredAuthError } from '../error/InteractionRequiredAuthError.mjs';\nimport { CacheRecord } from '../cache/entities/CacheRecord.mjs';\nimport { ProtocolUtils } from '../utils/ProtocolUtils.mjs';\nimport { HttpStatus, Constants, AuthenticationScheme, THE_FAMILY_ID } from '../utils/Constants.mjs';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.mjs';\nimport { AppMetadataEntity } from '../cache/entities/AppMetadataEntity.mjs';\nimport { TokenCacheContext } from '../cache/persistence/TokenCacheContext.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { extractTokenClaims, checkMaxAge } from '../account/AuthToken.mjs';\nimport { getTenantIdFromIdTokenClaims } from '../account/TokenClaims.mjs';\nimport { updateAccountTenantProfileData, buildTenantProfileFromIdTokenClaims } from '../account/AccountInfo.mjs';\nimport { createAccessTokenEntity, createRefreshTokenEntity, createIdTokenEntity } from '../cache/utils/CacheHelpers.mjs';\nimport { stateNotFound, invalidState, stateMismatch, nonceMismatch, authTimeNotFound, invalidCacheEnvironment, keyIdMissing } from '../error/ClientAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Class that handles response parsing.\n * @internal\n */\nclass ResponseHandler {\n  constructor(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {\n    this.clientId = clientId;\n    this.cacheStorage = cacheStorage;\n    this.cryptoObj = cryptoObj;\n    this.logger = logger;\n    this.serializableCache = serializableCache;\n    this.persistencePlugin = persistencePlugin;\n    this.performanceClient = performanceClient;\n  }\n  /**\n   * Function which validates server authorization code response.\n   * @param serverResponseHash\n   * @param requestState\n   * @param cryptoObj\n   */\n  validateServerAuthorizationCodeResponse(serverResponse, requestState) {\n    if (!serverResponse.state || !requestState) {\n      throw serverResponse.state ? createClientAuthError(stateNotFound, \"Cached State\") : createClientAuthError(stateNotFound, \"Server State\");\n    }\n    let decodedServerResponseState;\n    let decodedRequestState;\n    try {\n      decodedServerResponseState = decodeURIComponent(serverResponse.state);\n    } catch (e) {\n      throw createClientAuthError(invalidState, serverResponse.state);\n    }\n    try {\n      decodedRequestState = decodeURIComponent(requestState);\n    } catch (e) {\n      throw createClientAuthError(invalidState, serverResponse.state);\n    }\n    if (decodedServerResponseState !== decodedRequestState) {\n      throw createClientAuthError(stateMismatch);\n    }\n    // Check for error\n    if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\n      if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponse.error || \"\", serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || \"\", serverResponse.trace_id || \"\", serverResponse.correlation_id || \"\", serverResponse.claims || \"\");\n      }\n      throw new ServerError(serverResponse.error || \"\", serverResponse.error_description, serverResponse.suberror);\n    }\n  }\n  /**\n   * Function which validates server authorization token response.\n   * @param serverResponse\n   * @param refreshAccessToken\n   */\n  validateTokenResponse(serverResponse, refreshAccessToken) {\n    // Check for error\n    if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\n      const errString = `${serverResponse.error_codes} - [${serverResponse.timestamp}]: ${serverResponse.error_description} - Correlation ID: ${serverResponse.correlation_id} - Trace ID: ${serverResponse.trace_id}`;\n      const serverError = new ServerError(serverResponse.error, errString, serverResponse.suberror);\n      // check if 500 error\n      if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.SERVER_ERROR_RANGE_START && serverResponse.status <= HttpStatus.SERVER_ERROR_RANGE_END) {\n        this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently unavailable and the access token is unable to be refreshed.\\n${serverError}`);\n        // don't throw an exception, but alert the user via a log that the token was unable to be refreshed\n        return;\n        // check if 400 error\n      } else if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.CLIENT_ERROR_RANGE_START && serverResponse.status <= HttpStatus.CLIENT_ERROR_RANGE_END) {\n        this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently available but is unable to refresh the access token.\\n${serverError}`);\n        // don't throw an exception, but alert the user via a log that the token was unable to be refreshed\n        return;\n      }\n      if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING);\n      }\n      throw serverError;\n    }\n  }\n  /**\n   * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\n   * @param serverTokenResponse\n   * @param authority\n   */\n  handleServerTokenResponse(serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.performanceClient?.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);\n      // create an idToken object (not entity)\n      let idTokenClaims;\n      if (serverTokenResponse.id_token) {\n        idTokenClaims = extractTokenClaims(serverTokenResponse.id_token || Constants.EMPTY_STRING, _this.cryptoObj.base64Decode);\n        // token nonce check (TODO: Add a warning if no nonce is given?)\n        if (authCodePayload && authCodePayload.nonce) {\n          if (idTokenClaims.nonce !== authCodePayload.nonce) {\n            throw createClientAuthError(nonceMismatch);\n          }\n        }\n        // token max_age check\n        if (request.maxAge || request.maxAge === 0) {\n          const authTime = idTokenClaims.auth_time;\n          if (!authTime) {\n            throw createClientAuthError(authTimeNotFound);\n          }\n          checkMaxAge(authTime, request.maxAge);\n        }\n      }\n      // generate homeAccountId\n      _this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, _this.logger, _this.cryptoObj, idTokenClaims);\n      // save the response tokens\n      let requestStateObj;\n      if (!!authCodePayload && !!authCodePayload.state) {\n        requestStateObj = ProtocolUtils.parseRequestState(_this.cryptoObj, authCodePayload.state);\n      }\n      // Add keyId from request to serverTokenResponse if defined\n      serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || undefined;\n      const cacheRecord = _this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload);\n      let cacheContext;\n      try {\n        if (_this.persistencePlugin && _this.serializableCache) {\n          _this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\n          cacheContext = new TokenCacheContext(_this.serializableCache, true);\n          yield _this.persistencePlugin.beforeCacheAccess(cacheContext);\n        }\n        /*\n         * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\n         * If not present, we should return null, as it's the case that another application called removeAccount in between\n         * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\n         * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\n         */\n        if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {\n          const key = cacheRecord.account.generateAccountKey();\n          const account = _this.cacheStorage.getAccount(key, _this.logger);\n          if (!account) {\n            _this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\n            return yield ResponseHandler.generateAuthenticationResult(_this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, undefined, serverRequestId);\n          }\n        }\n        yield _this.cacheStorage.saveCacheRecord(cacheRecord, request.storeInCache);\n      } finally {\n        if (_this.persistencePlugin && _this.serializableCache && cacheContext) {\n          _this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\n          yield _this.persistencePlugin.afterCacheAccess(cacheContext);\n        }\n      }\n      return ResponseHandler.generateAuthenticationResult(_this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, serverTokenResponse, serverRequestId);\n    })();\n  }\n  /**\n   * Generates CacheRecord\n   * @param serverTokenResponse\n   * @param idTokenObj\n   * @param authority\n   */\n  generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload) {\n    const env = authority.getPreferredCache();\n    if (!env) {\n      throw createClientAuthError(invalidCacheEnvironment);\n    }\n    const claimsTenantId = getTenantIdFromIdTokenClaims(idTokenClaims);\n    // IdToken: non AAD scenarios can have empty realm\n    let cachedIdToken;\n    let cachedAccount;\n    if (serverTokenResponse.id_token && !!idTokenClaims) {\n      cachedIdToken = createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token, this.clientId, claimsTenantId || \"\");\n      cachedAccount = buildAccountToCache(this.cacheStorage, authority, this.homeAccountIdentifier, idTokenClaims, this.cryptoObj.base64Decode, serverTokenResponse.client_info, claimsTenantId, authCodePayload, undefined, this.logger);\n    }\n    // AccessToken\n    let cachedAccessToken = null;\n    if (serverTokenResponse.access_token) {\n      // If scopes not returned in server response, use request scopes\n      const responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);\n      /*\n       * Use timestamp calculated before request\n       * Server may return timestamps as strings, parse to numbers if so.\n       */\n      const expiresIn = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\n      const extExpiresIn = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\n      const refreshIn = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\n      const tokenExpirationSeconds = reqTimestamp + expiresIn;\n      const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\n      const refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined;\n      // non AAD scenarios can have empty realm\n      cachedAccessToken = createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token, this.clientId, claimsTenantId || authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj.base64Decode, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);\n    }\n    // refreshToken\n    let cachedRefreshToken = null;\n    if (serverTokenResponse.refresh_token) {\n      cachedRefreshToken = createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token, this.clientId, serverTokenResponse.foci, userAssertionHash);\n    }\n    // appMetadata\n    let cachedAppMetadata = null;\n    if (serverTokenResponse.foci) {\n      cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);\n    }\n    return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\n  }\n  /**\n   * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\n   *\n   * Optionally takes a state string that is set as-is in the response.\n   *\n   * @param cacheRecord\n   * @param idTokenObj\n   * @param fromTokenCache\n   * @param stateString\n   */\n  static generateAuthenticationResult(cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenClaims, requestState, serverTokenResponse, requestId) {\n    return _asyncToGenerator(function* () {\n      let accessToken = Constants.EMPTY_STRING;\n      let responseScopes = [];\n      let expiresOn = null;\n      let extExpiresOn;\n      let refreshOn;\n      let familyId = Constants.EMPTY_STRING;\n      if (cacheRecord.accessToken) {\n        if (cacheRecord.accessToken.tokenType === AuthenticationScheme.POP) {\n          const popTokenGenerator = new PopTokenGenerator(cryptoObj);\n          const {\n            secret,\n            keyId\n          } = cacheRecord.accessToken;\n          if (!keyId) {\n            throw createClientAuthError(keyIdMissing);\n          }\n          accessToken = yield popTokenGenerator.signPopToken(secret, keyId, request);\n        } else {\n          accessToken = cacheRecord.accessToken.secret;\n        }\n        responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\n        expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\n        extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\n        if (cacheRecord.accessToken.refreshOn) {\n          refreshOn = new Date(Number(cacheRecord.accessToken.refreshOn) * 1000);\n        }\n      }\n      if (cacheRecord.appMetadata) {\n        familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : \"\";\n      }\n      const uid = idTokenClaims?.oid || idTokenClaims?.sub || \"\";\n      const tid = idTokenClaims?.tid || \"\";\n      // for hybrid + native bridge enablement, send back the native account Id\n      if (serverTokenResponse?.spa_accountid && !!cacheRecord.account) {\n        cacheRecord.account.nativeAccountId = serverTokenResponse?.spa_accountid;\n      }\n      const accountInfo = cacheRecord.account ? updateAccountTenantProfileData(cacheRecord.account.getAccountInfo(), undefined,\n      // tenantProfile optional\n      idTokenClaims) : null;\n      return {\n        authority: authority.canonicalAuthority,\n        uniqueId: uid,\n        tenantId: tid,\n        scopes: responseScopes,\n        account: accountInfo,\n        idToken: cacheRecord?.idToken?.secret || \"\",\n        idTokenClaims: idTokenClaims || {},\n        accessToken: accessToken,\n        fromCache: fromTokenCache,\n        expiresOn: expiresOn,\n        extExpiresOn: extExpiresOn,\n        refreshOn: refreshOn,\n        correlationId: request.correlationId,\n        requestId: requestId || Constants.EMPTY_STRING,\n        familyId: familyId,\n        tokenType: cacheRecord.accessToken?.tokenType || Constants.EMPTY_STRING,\n        state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,\n        cloudGraphHostName: cacheRecord.account?.cloudGraphHostName || Constants.EMPTY_STRING,\n        msGraphHost: cacheRecord.account?.msGraphHost || Constants.EMPTY_STRING,\n        code: serverTokenResponse?.spa_code,\n        fromNativeBroker: false\n      };\n    })();\n  }\n}\nfunction buildAccountToCache(cacheStorage, authority, homeAccountId, idTokenClaims, base64Decode, clientInfo, claimsTenantId, authCodePayload, nativeAccountId, logger) {\n  logger?.verbose(\"setCachedAccount called\");\n  // Check if base account is already cached\n  const accountKeys = cacheStorage.getAccountKeys();\n  const baseAccountKey = accountKeys.find(accountKey => {\n    return accountKey.startsWith(homeAccountId);\n  });\n  let cachedAccount = null;\n  if (baseAccountKey) {\n    cachedAccount = cacheStorage.getAccount(baseAccountKey, logger);\n  }\n  const baseAccount = cachedAccount || AccountEntity.createAccount({\n    homeAccountId: homeAccountId,\n    idTokenClaims: idTokenClaims,\n    clientInfo: clientInfo,\n    cloudGraphHostName: authCodePayload?.cloud_graph_host_name,\n    msGraphHost: authCodePayload?.msgraph_host,\n    nativeAccountId: nativeAccountId\n  }, authority, base64Decode);\n  const tenantProfiles = baseAccount.tenantProfiles || [];\n  if (claimsTenantId && !tenantProfiles.find(tenantProfile => {\n    return tenantProfile.tenantId === claimsTenantId;\n  })) {\n    const newTenantProfile = buildTenantProfileFromIdTokenClaims(homeAccountId, idTokenClaims);\n    tenantProfiles.push(newTenantProfile);\n  }\n  baseAccount.tenantProfiles = tenantProfiles;\n  return baseAccount;\n}\nexport { ResponseHandler, buildAccountToCache };\n//# sourceMappingURL=ResponseHandler.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}