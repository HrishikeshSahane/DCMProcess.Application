{"ast":null,"code":"/*! @azure/msal-browser v3.6.0 2023-12-01 */\n'use strict';\n\nimport _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { NativeConstants, NativeExtensionMethod } from '../../utils/BrowserConstants.mjs';\nimport { PerformanceEvents, createAuthError, AuthErrorCodes, AuthenticationScheme } from '@azure/msal-common';\nimport { createNativeAuthError } from '../../error/NativeAuthError.mjs';\nimport { createBrowserAuthError } from '../../error/BrowserAuthError.mjs';\nimport { createNewGuid } from '../../crypto/BrowserCrypto.mjs';\nimport { nativeHandshakeTimeout, nativeExtensionNotInstalled } from '../../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass NativeMessageHandler {\n  constructor(logger, handshakeTimeoutMs, performanceClient, extensionId) {\n    this.logger = logger;\n    this.handshakeTimeoutMs = handshakeTimeoutMs;\n    this.extensionId = extensionId;\n    this.resolvers = new Map(); // Used for non-handshake messages\n    this.handshakeResolvers = new Map(); // Used for handshake messages\n    this.messageChannel = new MessageChannel();\n    this.windowListener = this.onWindowMessage.bind(this); // Window event callback doesn't have access to 'this' unless it's bound\n    this.performanceClient = performanceClient;\n    this.handshakeEvent = performanceClient.startMeasurement(PerformanceEvents.NativeMessageHandlerHandshake);\n  }\n  /**\n   * Sends a given message to the extension and resolves with the extension response\n   * @param body\n   */\n  sendMessage(body) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.logger.trace(\"NativeMessageHandler - sendMessage called.\");\n      const req = {\n        channel: NativeConstants.CHANNEL_ID,\n        extensionId: _this.extensionId,\n        responseId: createNewGuid(),\n        body: body\n      };\n      _this.logger.trace(\"NativeMessageHandler - Sending request to browser extension\");\n      _this.logger.tracePii(`NativeMessageHandler - Sending request to browser extension: ${JSON.stringify(req)}`);\n      _this.messageChannel.port1.postMessage(req);\n      return new Promise((resolve, reject) => {\n        _this.resolvers.set(req.responseId, {\n          resolve,\n          reject\n        });\n      });\n    })();\n  }\n  /**\n   * Returns an instance of the MessageHandler that has successfully established a connection with an extension\n   * @param {Logger} logger\n   * @param {number} handshakeTimeoutMs\n   * @param {IPerformanceClient} performanceClient\n   * @param {ICrypto} crypto\n   */\n  static createProvider(logger, handshakeTimeoutMs, performanceClient) {\n    return _asyncToGenerator(function* () {\n      logger.trace(\"NativeMessageHandler - createProvider called.\");\n      try {\n        const preferredProvider = new NativeMessageHandler(logger, handshakeTimeoutMs, performanceClient, NativeConstants.PREFERRED_EXTENSION_ID);\n        yield preferredProvider.sendHandshakeRequest();\n        return preferredProvider;\n      } catch (e) {\n        // If preferred extension fails for whatever reason, fallback to using any installed extension\n        const backupProvider = new NativeMessageHandler(logger, handshakeTimeoutMs, performanceClient);\n        yield backupProvider.sendHandshakeRequest();\n        return backupProvider;\n      }\n    })();\n  }\n  /**\n   * Send handshake request helper.\n   */\n  sendHandshakeRequest() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.logger.trace(\"NativeMessageHandler - sendHandshakeRequest called.\");\n      // Register this event listener before sending handshake\n      window.addEventListener(\"message\", _this2.windowListener, false); // false is important, because content script message processing should work first\n      const req = {\n        channel: NativeConstants.CHANNEL_ID,\n        extensionId: _this2.extensionId,\n        responseId: createNewGuid(),\n        body: {\n          method: NativeExtensionMethod.HandshakeRequest\n        }\n      };\n      _this2.handshakeEvent.add({\n        extensionId: _this2.extensionId,\n        extensionHandshakeTimeoutMs: _this2.handshakeTimeoutMs\n      });\n      _this2.messageChannel.port1.onmessage = event => {\n        _this2.onChannelMessage(event);\n      };\n      window.postMessage(req, window.origin, [_this2.messageChannel.port2]);\n      return new Promise((resolve, reject) => {\n        _this2.handshakeResolvers.set(req.responseId, {\n          resolve,\n          reject\n        });\n        _this2.timeoutId = window.setTimeout(() => {\n          /*\n           * Throw an error if neither HandshakeResponse nor original Handshake request are received in a reasonable timeframe.\n           * This typically suggests an event handler stopped propagation of the Handshake request but did not respond to it on the MessageChannel port\n           */\n          window.removeEventListener(\"message\", _this2.windowListener, false);\n          _this2.messageChannel.port1.close();\n          _this2.messageChannel.port2.close();\n          _this2.handshakeEvent.end({\n            extensionHandshakeTimedOut: true,\n            success: false\n          });\n          reject(createBrowserAuthError(nativeHandshakeTimeout));\n          _this2.handshakeResolvers.delete(req.responseId);\n        }, _this2.handshakeTimeoutMs); // Use a reasonable timeout in milliseconds here\n      });\n    })();\n  }\n  /**\n   * Invoked when a message is posted to the window. If a handshake request is received it means the extension is not installed.\n   * @param event\n   */\n  onWindowMessage(event) {\n    this.logger.trace(\"NativeMessageHandler - onWindowMessage called\");\n    // We only accept messages from ourselves\n    if (event.source !== window) {\n      return;\n    }\n    const request = event.data;\n    if (!request.channel || request.channel !== NativeConstants.CHANNEL_ID) {\n      return;\n    }\n    if (request.extensionId && request.extensionId !== this.extensionId) {\n      return;\n    }\n    if (request.body.method === NativeExtensionMethod.HandshakeRequest) {\n      const handshakeResolver = this.handshakeResolvers.get(request.responseId);\n      /*\n       * Filter out responses with no matched resolvers sooner to keep channel ports open while waiting for\n       * the proper response.\n       */\n      if (!handshakeResolver) {\n        this.logger.trace(`NativeMessageHandler.onWindowMessage - resolver can't be found for request ${request.responseId}`);\n        return;\n      }\n      // If we receive this message back it means no extension intercepted the request, meaning no extension supporting handshake protocol is installed\n      this.logger.verbose(request.extensionId ? `Extension with id: ${request.extensionId} not installed` : \"No extension installed\");\n      clearTimeout(this.timeoutId);\n      this.messageChannel.port1.close();\n      this.messageChannel.port2.close();\n      window.removeEventListener(\"message\", this.windowListener, false);\n      this.handshakeEvent.end({\n        success: false,\n        extensionInstalled: false\n      });\n      handshakeResolver.reject(createBrowserAuthError(nativeExtensionNotInstalled));\n    }\n  }\n  /**\n   * Invoked when a message is received from the extension on the MessageChannel port\n   * @param event\n   */\n  onChannelMessage(event) {\n    this.logger.trace(\"NativeMessageHandler - onChannelMessage called.\");\n    const request = event.data;\n    const resolver = this.resolvers.get(request.responseId);\n    const handshakeResolver = this.handshakeResolvers.get(request.responseId);\n    try {\n      const method = request.body.method;\n      if (method === NativeExtensionMethod.Response) {\n        if (!resolver) {\n          return;\n        }\n        const response = request.body.response;\n        this.logger.trace(\"NativeMessageHandler - Received response from browser extension\");\n        this.logger.tracePii(`NativeMessageHandler - Received response from browser extension: ${JSON.stringify(response)}`);\n        if (response.status !== \"Success\") {\n          resolver.reject(createNativeAuthError(response.code, response.description, response.ext));\n        } else if (response.result) {\n          if (response.result[\"code\"] && response.result[\"description\"]) {\n            resolver.reject(createNativeAuthError(response.result[\"code\"], response.result[\"description\"], response.result[\"ext\"]));\n          } else {\n            resolver.resolve(response.result);\n          }\n        } else {\n          throw createAuthError(AuthErrorCodes.unexpectedError, \"Event does not contain result.\");\n        }\n        this.resolvers.delete(request.responseId);\n      } else if (method === NativeExtensionMethod.HandshakeResponse) {\n        if (!handshakeResolver) {\n          this.logger.trace(`NativeMessageHandler.onChannelMessage - resolver can't be found for request ${request.responseId}`);\n          return;\n        }\n        clearTimeout(this.timeoutId); // Clear setTimeout\n        window.removeEventListener(\"message\", this.windowListener, false); // Remove 'No extension' listener\n        this.extensionId = request.extensionId;\n        this.extensionVersion = request.body.version;\n        this.logger.verbose(`NativeMessageHandler - Received HandshakeResponse from extension: ${this.extensionId}`);\n        this.handshakeEvent.end({\n          extensionInstalled: true,\n          success: true\n        });\n        handshakeResolver.resolve();\n        this.handshakeResolvers.delete(request.responseId);\n      }\n      // Do nothing if method is not Response or HandshakeResponse\n    } catch (err) {\n      this.logger.error(\"Error parsing response from WAM Extension\");\n      this.logger.errorPii(`Error parsing response from WAM Extension: ${err}`);\n      this.logger.errorPii(`Unable to parse ${event}`);\n      if (resolver) {\n        resolver.reject(err);\n      } else if (handshakeResolver) {\n        handshakeResolver.reject(err);\n      }\n    }\n  }\n  /**\n   * Returns the Id for the browser extension this handler is communicating with\n   * @returns\n   */\n  getExtensionId() {\n    return this.extensionId;\n  }\n  /**\n   * Returns the version for the browser extension this handler is communicating with\n   * @returns\n   */\n  getExtensionVersion() {\n    return this.extensionVersion;\n  }\n  /**\n   * Returns boolean indicating whether or not the request should attempt to use native broker\n   * @param logger\n   * @param config\n   * @param nativeExtensionProvider\n   * @param authenticationScheme\n   */\n  static isNativeAvailable(config, logger, nativeExtensionProvider, authenticationScheme) {\n    logger.trace(\"isNativeAvailable called\");\n    if (!config.system.allowNativeBroker) {\n      logger.trace(\"isNativeAvailable: allowNativeBroker is not enabled, returning false\");\n      // Developer disabled WAM\n      return false;\n    }\n    if (!nativeExtensionProvider) {\n      logger.trace(\"isNativeAvailable: WAM extension provider is not initialized, returning false\");\n      // Extension is not available\n      return false;\n    }\n    if (authenticationScheme) {\n      switch (authenticationScheme) {\n        case AuthenticationScheme.BEARER:\n        case AuthenticationScheme.POP:\n          logger.trace(\"isNativeAvailable: authenticationScheme is supported, returning true\");\n          return true;\n        default:\n          logger.trace(\"isNativeAvailable: authenticationScheme is not supported, returning false\");\n          return false;\n      }\n    }\n    return true;\n  }\n}\nexport { NativeMessageHandler };\n//# sourceMappingURL=NativeMessageHandler.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}