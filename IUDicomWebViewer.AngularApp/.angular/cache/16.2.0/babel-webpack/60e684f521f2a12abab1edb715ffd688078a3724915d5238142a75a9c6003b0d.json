{"ast":null,"code":"const fsystem = require(\"./fileSystem\").require();\nconst pth = require(\"path\");\nconst Constants = require(\"./constants\");\nconst Errors = require(\"./errors\");\nconst isWin = typeof process === \"object\" && \"win32\" === process.platform;\nconst is_Obj = obj => obj && typeof obj === \"object\";\n\n// generate CRC32 lookup table\nconst crcTable = new Uint32Array(256).map((t, c) => {\n  for (let k = 0; k < 8; k++) {\n    if ((c & 1) !== 0) {\n      c = 0xedb88320 ^ c >>> 1;\n    } else {\n      c >>>= 1;\n    }\n  }\n  return c >>> 0;\n});\n\n// UTILS functions\n\nfunction Utils(opts) {\n  this.sep = pth.sep;\n  this.fs = fsystem;\n  if (is_Obj(opts)) {\n    // custom filesystem\n    if (is_Obj(opts.fs) && typeof opts.fs.statSync === \"function\") {\n      this.fs = opts.fs;\n    }\n  }\n}\nmodule.exports = Utils;\n\n// INSTANCED functions\n\nUtils.prototype.makeDir = function ( /*String*/folder) {\n  const self = this;\n\n  // Sync - make directories tree\n  function mkdirSync( /*String*/fpath) {\n    let resolvedPath = fpath.split(self.sep)[0];\n    fpath.split(self.sep).forEach(function (name) {\n      if (!name || name.substr(-1, 1) === \":\") return;\n      resolvedPath += self.sep + name;\n      var stat;\n      try {\n        stat = self.fs.statSync(resolvedPath);\n      } catch (e) {\n        self.fs.mkdirSync(resolvedPath);\n      }\n      if (stat && stat.isFile()) throw Errors.FILE_IN_THE_WAY.replace(\"%s\", resolvedPath);\n    });\n  }\n  mkdirSync(folder);\n};\nUtils.prototype.writeFileTo = function ( /*String*/path, /*Buffer*/content, /*Boolean*/overwrite, /*Number*/attr) {\n  const self = this;\n  if (self.fs.existsSync(path)) {\n    if (!overwrite) return false; // cannot overwrite\n\n    var stat = self.fs.statSync(path);\n    if (stat.isDirectory()) {\n      return false;\n    }\n  }\n  var folder = pth.dirname(path);\n  if (!self.fs.existsSync(folder)) {\n    self.makeDir(folder);\n  }\n  var fd;\n  try {\n    fd = self.fs.openSync(path, \"w\", 438); // 0666\n  } catch (e) {\n    self.fs.chmodSync(path, 438);\n    fd = self.fs.openSync(path, \"w\", 438);\n  }\n  if (fd) {\n    try {\n      self.fs.writeSync(fd, content, 0, content.length, 0);\n    } finally {\n      self.fs.closeSync(fd);\n    }\n  }\n  self.fs.chmodSync(path, attr || 438);\n  return true;\n};\nUtils.prototype.writeFileToAsync = function ( /*String*/path, /*Buffer*/content, /*Boolean*/overwrite, /*Number*/attr, /*Function*/callback) {\n  if (typeof attr === \"function\") {\n    callback = attr;\n    attr = undefined;\n  }\n  const self = this;\n  self.fs.exists(path, function (exist) {\n    if (exist && !overwrite) return callback(false);\n    self.fs.stat(path, function (err, stat) {\n      if (exist && stat.isDirectory()) {\n        return callback(false);\n      }\n      var folder = pth.dirname(path);\n      self.fs.exists(folder, function (exists) {\n        if (!exists) self.makeDir(folder);\n        self.fs.open(path, \"w\", 438, function (err, fd) {\n          if (err) {\n            self.fs.chmod(path, 438, function () {\n              self.fs.open(path, \"w\", 438, function (err, fd) {\n                self.fs.write(fd, content, 0, content.length, 0, function () {\n                  self.fs.close(fd, function () {\n                    self.fs.chmod(path, attr || 438, function () {\n                      callback(true);\n                    });\n                  });\n                });\n              });\n            });\n          } else if (fd) {\n            self.fs.write(fd, content, 0, content.length, 0, function () {\n              self.fs.close(fd, function () {\n                self.fs.chmod(path, attr || 438, function () {\n                  callback(true);\n                });\n              });\n            });\n          } else {\n            self.fs.chmod(path, attr || 438, function () {\n              callback(true);\n            });\n          }\n        });\n      });\n    });\n  });\n};\nUtils.prototype.findFiles = function ( /*String*/path) {\n  const self = this;\n  function findSync( /*String*/dir, /*RegExp*/pattern, /*Boolean*/recursive) {\n    if (typeof pattern === \"boolean\") {\n      recursive = pattern;\n      pattern = undefined;\n    }\n    let files = [];\n    self.fs.readdirSync(dir).forEach(function (file) {\n      var path = pth.join(dir, file);\n      if (self.fs.statSync(path).isDirectory() && recursive) files = files.concat(findSync(path, pattern, recursive));\n      if (!pattern || pattern.test(path)) {\n        files.push(pth.normalize(path) + (self.fs.statSync(path).isDirectory() ? self.sep : \"\"));\n      }\n    });\n    return files;\n  }\n  return findSync(path, undefined, true);\n};\nUtils.prototype.getAttributes = function () {};\nUtils.prototype.setAttributes = function () {};\n\n// STATIC functions\n\n// crc32 single update (it is part of crc32)\nUtils.crc32update = function (crc, byte) {\n  return crcTable[(crc ^ byte) & 0xff] ^ crc >>> 8;\n};\nUtils.crc32 = function (buf) {\n  if (typeof buf === \"string\") {\n    buf = Buffer.from(buf, \"utf8\");\n  }\n  // Generate crcTable\n  if (!crcTable.length) genCRCTable();\n  let len = buf.length;\n  let crc = ~0;\n  for (let off = 0; off < len;) crc = Utils.crc32update(crc, buf[off++]);\n  // xor and cast as uint32 number\n  return ~crc >>> 0;\n};\nUtils.methodToString = function ( /*Number*/method) {\n  switch (method) {\n    case Constants.STORED:\n      return \"STORED (\" + method + \")\";\n    case Constants.DEFLATED:\n      return \"DEFLATED (\" + method + \")\";\n    default:\n      return \"UNSUPPORTED (\" + method + \")\";\n  }\n};\n\n// removes \"..\" style path elements\nUtils.canonical = function ( /*string*/path) {\n  if (!path) return \"\";\n  // trick normalize think path is absolute\n  var safeSuffix = pth.posix.normalize(\"/\" + path.split(\"\\\\\").join(\"/\"));\n  return pth.join(\".\", safeSuffix);\n};\n\n// make abolute paths taking prefix as root folder\nUtils.sanitize = function ( /*string*/prefix, /*string*/name) {\n  prefix = pth.resolve(pth.normalize(prefix));\n  var parts = name.split(\"/\");\n  for (var i = 0, l = parts.length; i < l; i++) {\n    var path = pth.normalize(pth.join(prefix, parts.slice(i, l).join(pth.sep)));\n    if (path.indexOf(prefix) === 0) {\n      return path;\n    }\n  }\n  return pth.normalize(pth.join(prefix, pth.basename(name)));\n};\n\n// converts buffer, Uint8Array, string types to buffer\nUtils.toBuffer = function toBuffer( /*buffer, Uint8Array, string*/input) {\n  if (Buffer.isBuffer(input)) {\n    return input;\n  } else if (input instanceof Uint8Array) {\n    return Buffer.from(input);\n  } else {\n    // expect string all other values are invalid and return empty buffer\n    return typeof input === \"string\" ? Buffer.from(input, \"utf8\") : Buffer.alloc(0);\n  }\n};\nUtils.readBigUInt64LE = function ( /*Buffer*/buffer, /*int*/index) {\n  var slice = Buffer.from(buffer.slice(index, index + 8));\n  slice.swap64();\n  return parseInt(`0x${slice.toString(\"hex\")}`);\n};\nUtils.isWin = isWin; // Do we have windows system\nUtils.crcTable = crcTable;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}