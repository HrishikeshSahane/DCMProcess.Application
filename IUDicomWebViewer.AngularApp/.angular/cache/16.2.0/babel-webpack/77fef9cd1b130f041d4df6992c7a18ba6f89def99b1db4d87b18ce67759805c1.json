{"ast":null,"code":"/*! @azure/msal-browser v3.6.0 2023-12-01 */\n'use strict';\n\nimport { AuthToken, AccountEntity, CacheRecord, Authority, buildAccountToCache, CacheHelpers, ScopeSet, Constants } from '@azure/msal-common';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { base64Decode } from '../encode/Base64Decode.mjs';\nimport { unableToLoadToken } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Token cache manager\n */\nclass TokenCache {\n  constructor(configuration, storage, logger, cryptoObj) {\n    this.isBrowserEnvironment = typeof window !== \"undefined\";\n    this.config = configuration;\n    this.storage = storage;\n    this.logger = logger;\n    this.cryptoObj = cryptoObj;\n  }\n  // Move getAllAccounts here and cache utility APIs\n  /**\n   * API to load tokens to msal-browser cache.\n   * @param request\n   * @param response\n   * @param options\n   * @returns `AuthenticationResult` for the response that was loaded.\n   */\n  loadExternalTokens(request, response, options) {\n    this.logger.info(\"TokenCache - loadExternalTokens called\");\n    if (!response.id_token) {\n      throw createBrowserAuthError(unableToLoadToken);\n    }\n    const idTokenClaims = AuthToken.extractTokenClaims(response.id_token, base64Decode);\n    let cacheRecord;\n    let authority;\n    let cacheRecordAccount;\n    if (request.account) {\n      cacheRecordAccount = AccountEntity.createFromAccountInfo(request.account);\n      cacheRecord = new CacheRecord(cacheRecordAccount, this.loadIdToken(response.id_token, cacheRecordAccount.homeAccountId, request.account.environment, request.account.tenantId), this.loadAccessToken(request, response, cacheRecordAccount.homeAccountId, request.account.environment, request.account.tenantId, options), this.loadRefreshToken(request, response, cacheRecordAccount.homeAccountId, request.account.environment));\n    } else if (request.authority) {\n      const authorityUrl = Authority.generateAuthority(request.authority, request.azureCloudOptions);\n      const authorityOptions = {\n        protocolMode: this.config.auth.protocolMode,\n        knownAuthorities: this.config.auth.knownAuthorities,\n        cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\n        authorityMetadata: this.config.auth.authorityMetadata,\n        skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache\n      };\n      authority = new Authority(authorityUrl, this.config.system.networkClient, this.storage, authorityOptions, this.logger);\n      // \"clientInfo\" from options takes precedence over \"clientInfo\" in response\n      if (options.clientInfo) {\n        this.logger.trace(\"TokenCache - homeAccountId from options\");\n        cacheRecordAccount = this.loadAccount(idTokenClaims, authority, options.clientInfo);\n        cacheRecord = new CacheRecord(cacheRecordAccount, this.loadIdToken(response.id_token, cacheRecordAccount.homeAccountId, authority.hostnameAndPort, authority.tenant), this.loadAccessToken(request, response, cacheRecordAccount.homeAccountId, authority.hostnameAndPort, authority.tenant, options), this.loadRefreshToken(request, response, cacheRecordAccount.homeAccountId, authority.hostnameAndPort));\n      } else if (response.client_info) {\n        this.logger.trace(\"TokenCache - homeAccountId from response\");\n        cacheRecordAccount = this.loadAccount(idTokenClaims, authority, response.client_info);\n        cacheRecord = new CacheRecord(cacheRecordAccount, this.loadIdToken(response.id_token, cacheRecordAccount.homeAccountId, authority.hostnameAndPort, authority.tenant), this.loadAccessToken(request, response, cacheRecordAccount.homeAccountId, authority.hostnameAndPort, authority.tenant, options), this.loadRefreshToken(request, response, cacheRecordAccount.homeAccountId, authority.hostnameAndPort));\n      } else {\n        throw createBrowserAuthError(unableToLoadToken);\n      }\n    } else {\n      throw createBrowserAuthError(unableToLoadToken);\n    }\n    return this.generateAuthenticationResult(request, idTokenClaims, cacheRecord, cacheRecordAccount, authority);\n  }\n  /**\n   * Helper function to load account to msal-browser cache\n   * @param idToken\n   * @param environment\n   * @param clientInfo\n   * @param authorityType\n   * @param requestHomeAccountId\n   * @returns `AccountEntity`\n   */\n  loadAccount(idTokenClaims, authority, clientInfo, requestHomeAccountId) {\n    if (this.isBrowserEnvironment) {\n      this.logger.verbose(\"TokenCache - loading account\");\n      let homeAccountId;\n      if (requestHomeAccountId) {\n        homeAccountId = requestHomeAccountId;\n      } else if (authority.authorityType !== undefined && clientInfo) {\n        homeAccountId = AccountEntity.generateHomeAccountId(clientInfo, authority.authorityType, this.logger, this.cryptoObj, idTokenClaims);\n      }\n      if (!homeAccountId) {\n        throw createBrowserAuthError(unableToLoadToken);\n      }\n      const claimsTenantId = idTokenClaims.tid;\n      const cachedAccount = buildAccountToCache(this.storage, authority, homeAccountId, idTokenClaims, base64Decode, clientInfo, claimsTenantId, undefined, undefined, this.logger);\n      this.storage.setAccount(cachedAccount);\n      return cachedAccount;\n    } else {\n      throw createBrowserAuthError(unableToLoadToken);\n    }\n  }\n  /**\n   * Helper function to load id tokens to msal-browser cache\n   * @param idToken\n   * @param homeAccountId\n   * @param environment\n   * @param tenantId\n   * @returns `IdTokenEntity`\n   */\n  loadIdToken(idToken, homeAccountId, environment, tenantId) {\n    const idTokenEntity = CacheHelpers.createIdTokenEntity(homeAccountId, environment, idToken, this.config.auth.clientId, tenantId);\n    if (this.isBrowserEnvironment) {\n      this.logger.verbose(\"TokenCache - loading id token\");\n      this.storage.setIdTokenCredential(idTokenEntity);\n      return idTokenEntity;\n    } else {\n      throw createBrowserAuthError(unableToLoadToken);\n    }\n  }\n  /**\n   * Helper function to load access tokens to msal-browser cache\n   * @param request\n   * @param response\n   * @param homeAccountId\n   * @param environment\n   * @param tenantId\n   * @returns `AccessTokenEntity`\n   */\n  loadAccessToken(request, response, homeAccountId, environment, tenantId, options) {\n    if (!response.access_token) {\n      this.logger.verbose(\"TokenCache - No access token provided for caching\");\n      return null;\n    }\n    if (!response.expires_in) {\n      throw createBrowserAuthError(unableToLoadToken);\n    }\n    if (!options.extendedExpiresOn) {\n      throw createBrowserAuthError(unableToLoadToken);\n    }\n    const scopes = new ScopeSet(request.scopes).printScopes();\n    const expiresOn = options.expiresOn || response.expires_in + new Date().getTime() / 1000;\n    const extendedExpiresOn = options.extendedExpiresOn;\n    const accessTokenEntity = CacheHelpers.createAccessTokenEntity(homeAccountId, environment, response.access_token, this.config.auth.clientId, tenantId, scopes, expiresOn, extendedExpiresOn, base64Decode);\n    if (this.isBrowserEnvironment) {\n      this.logger.verbose(\"TokenCache - loading access token\");\n      this.storage.setAccessTokenCredential(accessTokenEntity);\n      return accessTokenEntity;\n    } else {\n      throw createBrowserAuthError(unableToLoadToken);\n    }\n  }\n  /**\n   * Helper function to load refresh tokens to msal-browser cache\n   * @param request\n   * @param response\n   * @param homeAccountId\n   * @param environment\n   * @returns `RefreshTokenEntity`\n   */\n  loadRefreshToken(request, response, homeAccountId, environment) {\n    if (!response.refresh_token) {\n      this.logger.verbose(\"TokenCache - No refresh token provided for caching\");\n      return null;\n    }\n    const refreshTokenEntity = CacheHelpers.createRefreshTokenEntity(homeAccountId, environment, response.refresh_token, this.config.auth.clientId);\n    if (this.isBrowserEnvironment) {\n      this.logger.verbose(\"TokenCache - loading refresh token\");\n      this.storage.setRefreshTokenCredential(refreshTokenEntity);\n      return refreshTokenEntity;\n    } else {\n      throw createBrowserAuthError(unableToLoadToken);\n    }\n  }\n  /**\n   * Helper function to generate an `AuthenticationResult` for the result.\n   * @param request\n   * @param idTokenObj\n   * @param cacheRecord\n   * @param authority\n   * @returns `AuthenticationResult`\n   */\n  generateAuthenticationResult(request, idTokenClaims, cacheRecord, accountEntity, authority) {\n    let accessToken = Constants.EMPTY_STRING;\n    let responseScopes = [];\n    let expiresOn = null;\n    let extExpiresOn;\n    if (cacheRecord?.accessToken) {\n      accessToken = cacheRecord.accessToken.secret;\n      responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\n      expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\n      extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\n    }\n    const uid = idTokenClaims.oid || idTokenClaims.sub || Constants.EMPTY_STRING;\n    const tid = idTokenClaims.tid || Constants.EMPTY_STRING;\n    return {\n      authority: authority ? authority.canonicalAuthority : Constants.EMPTY_STRING,\n      uniqueId: uid,\n      tenantId: tid,\n      scopes: responseScopes,\n      account: accountEntity.getAccountInfo(),\n      idToken: cacheRecord.idToken?.secret || \"\",\n      idTokenClaims: idTokenClaims || {},\n      accessToken: accessToken,\n      fromCache: true,\n      expiresOn: expiresOn,\n      correlationId: request.correlationId || Constants.EMPTY_STRING,\n      requestId: Constants.EMPTY_STRING,\n      extExpiresOn: extExpiresOn,\n      familyId: Constants.EMPTY_STRING,\n      tokenType: cacheRecord?.accessToken?.tokenType || Constants.EMPTY_STRING,\n      state: Constants.EMPTY_STRING,\n      cloudGraphHostName: accountEntity.cloudGraphHostName || Constants.EMPTY_STRING,\n      msGraphHost: accountEntity.msGraphHost || Constants.EMPTY_STRING,\n      code: undefined,\n      fromNativeBroker: false\n    };\n  }\n}\nexport { TokenCache };\n//# sourceMappingURL=TokenCache.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}