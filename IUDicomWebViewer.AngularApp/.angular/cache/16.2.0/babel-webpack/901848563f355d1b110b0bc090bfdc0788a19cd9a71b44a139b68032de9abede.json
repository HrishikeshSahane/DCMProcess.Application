{"ast":null,"code":"/*! @azure/msal-common v14.5.0 2023-12-01 */\n'use strict';\n\nimport _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BaseClient } from './BaseClient.mjs';\nimport { TimeUtils } from '../utils/TimeUtils.mjs';\nimport { RefreshTokenClient } from './RefreshTokenClient.mjs';\nimport { ClientAuthError, createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { ResponseHandler } from '../response/ResponseHandler.mjs';\nimport { CacheOutcome } from '../utils/Constants.mjs';\nimport { StringUtils } from '../utils/StringUtils.mjs';\nimport { extractTokenClaims, checkMaxAge } from '../account/AuthToken.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { invokeAsync } from '../utils/FunctionWrappers.mjs';\nimport { tokenRefreshRequired, noAccountInSilentRequest, authTimeNotFound } from '../error/ClientAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/** @internal */\nclass SilentFlowClient extends BaseClient {\n  constructor(configuration, performanceClient) {\n    super(configuration, performanceClient);\n  }\n  /**\n   * Retrieves a token from cache if it is still valid, or uses the cached refresh token to renew\n   * the given token and returns the renewed token\n   * @param request\n   */\n  acquireToken(request) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const [authResponse, cacheOutcome] = yield _this.acquireCachedToken(request);\n        // if the token is not expired but must be refreshed; get a new one in the background\n        if (cacheOutcome === CacheOutcome.PROACTIVELY_REFRESHED) {\n          _this.logger.info(\"SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'. It's not expired, but must be refreshed.\");\n          // refresh the access token in the background\n          const refreshTokenClient = new RefreshTokenClient(_this.config, _this.performanceClient);\n          refreshTokenClient.acquireTokenByRefreshToken(request).catch(() => {\n            // do nothing, this is running in the background and no action is to be taken upon success or failure\n          });\n        }\n        // return the cached token\n        return authResponse;\n      } catch (e) {\n        if (e instanceof ClientAuthError && e.errorCode === tokenRefreshRequired) {\n          const refreshTokenClient = new RefreshTokenClient(_this.config, _this.performanceClient);\n          return refreshTokenClient.acquireTokenByRefreshToken(request);\n        } else {\n          throw e;\n        }\n      }\n    })();\n  }\n  /**\n   * Retrieves token from cache or throws an error if it must be refreshed.\n   * @param request\n   */\n  acquireCachedToken(request) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.performanceClient?.addQueueMeasurement(PerformanceEvents.SilentFlowClientAcquireCachedToken, request.correlationId);\n      let lastCacheOutcome = CacheOutcome.NOT_APPLICABLE;\n      if (request.forceRefresh || !_this2.config.cacheOptions.claimsBasedCachingEnabled && !StringUtils.isEmptyObj(request.claims)) {\n        // Must refresh due to present force_refresh flag.\n        _this2.setCacheOutcome(CacheOutcome.FORCE_REFRESH_OR_CLAIMS, request.correlationId);\n        throw createClientAuthError(tokenRefreshRequired);\n      }\n      // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\n      if (!request.account) {\n        throw createClientAuthError(noAccountInSilentRequest);\n      }\n      const environment = request.authority || _this2.authority.getPreferredCache();\n      const cacheRecord = _this2.cacheManager.readCacheRecord(request.account, request, environment, _this2.performanceClient, request.correlationId);\n      if (!cacheRecord.accessToken) {\n        // must refresh due to non-existent access_token\n        _this2.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN, request.correlationId);\n        throw createClientAuthError(tokenRefreshRequired);\n      } else if (TimeUtils.wasClockTurnedBack(cacheRecord.accessToken.cachedAt) || TimeUtils.isTokenExpired(cacheRecord.accessToken.expiresOn, _this2.config.systemOptions.tokenRenewalOffsetSeconds)) {\n        // must refresh due to the expires_in value\n        _this2.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED, request.correlationId);\n        throw createClientAuthError(tokenRefreshRequired);\n      } else if (cacheRecord.accessToken.refreshOn && TimeUtils.isTokenExpired(cacheRecord.accessToken.refreshOn, 0)) {\n        // must refresh (in the background) due to the refresh_in value\n        lastCacheOutcome = CacheOutcome.PROACTIVELY_REFRESHED;\n        // don't throw ClientAuthError.createRefreshRequiredError(), return cached token instead\n      }\n\n      _this2.setCacheOutcome(lastCacheOutcome, request.correlationId);\n      if (_this2.config.serverTelemetryManager) {\n        _this2.config.serverTelemetryManager.incrementCacheHits();\n      }\n      return [yield invokeAsync(_this2.generateResultFromCacheRecord.bind(_this2), PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, _this2.logger, _this2.performanceClient, request.correlationId)(cacheRecord, request), lastCacheOutcome];\n    })();\n  }\n  setCacheOutcome(cacheOutcome, correlationId) {\n    this.serverTelemetryManager?.setCacheOutcome(cacheOutcome);\n    this.performanceClient?.addFields({\n      cacheOutcome: cacheOutcome\n    }, correlationId);\n    if (cacheOutcome !== CacheOutcome.NOT_APPLICABLE) {\n      this.logger.info(`Token refresh is required due to cache outcome: ${cacheOutcome}`);\n    }\n  }\n  /**\n   * Helper function to build response object from the CacheRecord\n   * @param cacheRecord\n   */\n  generateResultFromCacheRecord(cacheRecord, request) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      _this3.performanceClient?.addQueueMeasurement(PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, request.correlationId);\n      let idTokenClaims;\n      if (cacheRecord.idToken) {\n        idTokenClaims = extractTokenClaims(cacheRecord.idToken.secret, _this3.config.cryptoInterface.base64Decode);\n      }\n      // token max_age check\n      if (request.maxAge || request.maxAge === 0) {\n        const authTime = idTokenClaims?.auth_time;\n        if (!authTime) {\n          throw createClientAuthError(authTimeNotFound);\n        }\n        checkMaxAge(authTime, request.maxAge);\n      }\n      return ResponseHandler.generateAuthenticationResult(_this3.cryptoUtils, _this3.authority, cacheRecord, true, request, idTokenClaims);\n    })();\n  }\n}\nexport { SilentFlowClient };\n//# sourceMappingURL=SilentFlowClient.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}