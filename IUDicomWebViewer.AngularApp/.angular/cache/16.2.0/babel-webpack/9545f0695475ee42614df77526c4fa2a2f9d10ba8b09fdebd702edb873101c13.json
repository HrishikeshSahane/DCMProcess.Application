{"ast":null,"code":"import _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { logger } from \"../logger\";\nimport { terminalStates } from \"./constants\";\n/**\n * Deserializes the state\n */\nexport function deserializeState(serializedState) {\n  try {\n    return JSON.parse(serializedState).state;\n  } catch (e) {\n    throw new Error(`Unable to deserialize input state: ${serializedState}`);\n  }\n}\nfunction setStateError(inputs) {\n  const {\n    state,\n    stateProxy,\n    isOperationError\n  } = inputs;\n  return error => {\n    if (isOperationError(error)) {\n      stateProxy.setError(state, error);\n      stateProxy.setFailed(state);\n    }\n    throw error;\n  };\n}\nfunction appendReadableErrorMessage(currentMessage, innerMessage) {\n  let message = currentMessage;\n  if (message.slice(-1) !== \".\") {\n    message = message + \".\";\n  }\n  return message + \" \" + innerMessage;\n}\nfunction simplifyError(err) {\n  let message = err.message;\n  let code = err.code;\n  let curErr = err;\n  while (curErr.innererror) {\n    curErr = curErr.innererror;\n    code = curErr.code;\n    message = appendReadableErrorMessage(message, curErr.message);\n  }\n  return {\n    code,\n    message\n  };\n}\nfunction processOperationStatus(result) {\n  const {\n    state,\n    stateProxy,\n    status,\n    isDone,\n    processResult,\n    getError,\n    response,\n    setErrorAsResult\n  } = result;\n  switch (status) {\n    case \"succeeded\":\n      {\n        stateProxy.setSucceeded(state);\n        break;\n      }\n    case \"failed\":\n      {\n        const err = getError === null || getError === void 0 ? void 0 : getError(response);\n        let postfix = \"\";\n        if (err) {\n          const {\n            code,\n            message\n          } = simplifyError(err);\n          postfix = `. ${code}. ${message}`;\n        }\n        const errStr = `The long-running operation has failed${postfix}`;\n        stateProxy.setError(state, new Error(errStr));\n        stateProxy.setFailed(state);\n        logger.warning(errStr);\n        break;\n      }\n    case \"canceled\":\n      {\n        stateProxy.setCanceled(state);\n        break;\n      }\n  }\n  if ((isDone === null || isDone === void 0 ? void 0 : isDone(response, state)) || isDone === undefined && [\"succeeded\", \"canceled\"].concat(setErrorAsResult ? [] : [\"failed\"]).includes(status)) {\n    stateProxy.setResult(state, buildResult({\n      response,\n      state,\n      processResult\n    }));\n  }\n}\nfunction buildResult(inputs) {\n  const {\n    processResult,\n    response,\n    state\n  } = inputs;\n  return processResult ? processResult(response, state) : response;\n}\n/**\n * Initiates the long-running operation.\n */\nexport function initOperation(_x) {\n  return _initOperation.apply(this, arguments);\n}\nfunction _initOperation() {\n  _initOperation = _asyncToGenerator(function* (inputs) {\n    const {\n      init,\n      stateProxy,\n      processResult,\n      getOperationStatus,\n      withOperationLocation,\n      setErrorAsResult\n    } = inputs;\n    const {\n      operationLocation,\n      resourceLocation,\n      metadata,\n      response\n    } = yield init();\n    if (operationLocation) withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);\n    const config = {\n      metadata,\n      operationLocation,\n      resourceLocation\n    };\n    logger.verbose(`LRO: Operation description:`, config);\n    const state = stateProxy.initState(config);\n    const status = getOperationStatus({\n      response,\n      state,\n      operationLocation\n    });\n    processOperationStatus({\n      state,\n      status,\n      stateProxy,\n      response,\n      setErrorAsResult,\n      processResult\n    });\n    return state;\n  });\n  return _initOperation.apply(this, arguments);\n}\nfunction pollOperationHelper(_x2) {\n  return _pollOperationHelper.apply(this, arguments);\n}\n/** Polls the long-running operation. */\nfunction _pollOperationHelper() {\n  _pollOperationHelper = _asyncToGenerator(function* (inputs) {\n    const {\n      poll,\n      state,\n      stateProxy,\n      operationLocation,\n      getOperationStatus,\n      getResourceLocation,\n      isOperationError,\n      options\n    } = inputs;\n    const response = yield poll(operationLocation, options).catch(setStateError({\n      state,\n      stateProxy,\n      isOperationError\n    }));\n    const status = getOperationStatus(response, state);\n    logger.verbose(`LRO: Status:\\n\\tPolling from: ${state.config.operationLocation}\\n\\tOperation status: ${status}\\n\\tPolling status: ${terminalStates.includes(status) ? \"Stopped\" : \"Running\"}`);\n    if (status === \"succeeded\") {\n      const resourceLocation = getResourceLocation(response, state);\n      if (resourceLocation !== undefined) {\n        return {\n          response: yield poll(resourceLocation).catch(setStateError({\n            state,\n            stateProxy,\n            isOperationError\n          })),\n          status\n        };\n      }\n    }\n    return {\n      response,\n      status\n    };\n  });\n  return _pollOperationHelper.apply(this, arguments);\n}\nexport function pollOperation(_x3) {\n  return _pollOperation.apply(this, arguments);\n}\n//# sourceMappingURL=operation.js.map\nfunction _pollOperation() {\n  _pollOperation = _asyncToGenerator(function* (inputs) {\n    const {\n      poll,\n      state,\n      stateProxy,\n      options,\n      getOperationStatus,\n      getResourceLocation,\n      getOperationLocation,\n      isOperationError,\n      withOperationLocation,\n      getPollingInterval,\n      processResult,\n      getError,\n      updateState,\n      setDelay,\n      isDone,\n      setErrorAsResult\n    } = inputs;\n    const {\n      operationLocation\n    } = state.config;\n    if (operationLocation !== undefined) {\n      const {\n        response,\n        status\n      } = yield pollOperationHelper({\n        poll,\n        getOperationStatus,\n        state,\n        stateProxy,\n        operationLocation,\n        getResourceLocation,\n        isOperationError,\n        options\n      });\n      processOperationStatus({\n        status,\n        response,\n        state,\n        stateProxy,\n        isDone,\n        processResult,\n        getError,\n        setErrorAsResult\n      });\n      if (!terminalStates.includes(status)) {\n        const intervalInMs = getPollingInterval === null || getPollingInterval === void 0 ? void 0 : getPollingInterval(response);\n        if (intervalInMs) setDelay(intervalInMs);\n        const location = getOperationLocation === null || getOperationLocation === void 0 ? void 0 : getOperationLocation(response, state);\n        if (location !== undefined) {\n          const isUpdated = operationLocation !== location;\n          state.config.operationLocation = location;\n          withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(location, isUpdated);\n        } else withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);\n      }\n      updateState === null || updateState === void 0 ? void 0 : updateState(state, response);\n    }\n  });\n  return _pollOperation.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}