{"ast":null,"code":"/*! @azure/msal-common v14.5.0 2023-12-01 */\n'use strict';\n\nimport { createClientConfigurationError } from '../error/ClientConfigurationError.mjs';\nimport { StringUtils } from '../utils/StringUtils.mjs';\nimport { createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { Constants, OIDC_SCOPES } from '../utils/Constants.mjs';\nimport { emptyInputScopesError } from '../error/ClientConfigurationErrorCodes.mjs';\nimport { cannotAppendScopeSet, cannotRemoveEmptyScope, emptyInputScopeSet } from '../error/ClientAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * The ScopeSet class creates a set of scopes. Scopes are case-insensitive, unique values, so the Set object in JS makes\n * the most sense to implement for this class. All scopes are trimmed and converted to lower case strings in intersection and union functions\n * to ensure uniqueness of strings.\n */\nclass ScopeSet {\n  constructor(inputScopes) {\n    // Filter empty string and null/undefined array items\n    const scopeArr = inputScopes ? StringUtils.trimArrayEntries([...inputScopes]) : [];\n    const filteredInput = scopeArr ? StringUtils.removeEmptyStringsFromArray(scopeArr) : [];\n    // Validate and filter scopes (validate function throws if validation fails)\n    this.validateInputScopes(filteredInput);\n    this.scopes = new Set(); // Iterator in constructor not supported by IE11\n    filteredInput.forEach(scope => this.scopes.add(scope));\n  }\n  /**\n   * Factory method to create ScopeSet from space-delimited string\n   * @param inputScopeString\n   * @param appClientId\n   * @param scopesRequired\n   */\n  static fromString(inputScopeString) {\n    const scopeString = inputScopeString || Constants.EMPTY_STRING;\n    const inputScopes = scopeString.split(\" \");\n    return new ScopeSet(inputScopes);\n  }\n  /**\n   * Creates the set of scopes to search for in cache lookups\n   * @param inputScopeString\n   * @returns\n   */\n  static createSearchScopes(inputScopeString) {\n    const scopeSet = new ScopeSet(inputScopeString);\n    if (!scopeSet.containsOnlyOIDCScopes()) {\n      scopeSet.removeOIDCScopes();\n    } else {\n      scopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);\n    }\n    return scopeSet;\n  }\n  /**\n   * Used to validate the scopes input parameter requested  by the developer.\n   * @param {Array<string>} inputScopes - Developer requested permissions. Not all scopes are guaranteed to be included in the access token returned.\n   * @param {boolean} scopesRequired - Boolean indicating whether the scopes array is required or not\n   */\n  validateInputScopes(inputScopes) {\n    // Check if scopes are required but not given or is an empty array\n    if (!inputScopes || inputScopes.length < 1) {\n      throw createClientConfigurationError(emptyInputScopesError);\n    }\n  }\n  /**\n   * Check if a given scope is present in this set of scopes.\n   * @param scope\n   */\n  containsScope(scope) {\n    const lowerCaseScopes = this.printScopesLowerCase().split(\" \");\n    const lowerCaseScopesSet = new ScopeSet(lowerCaseScopes);\n    // compare lowercase scopes\n    return scope ? lowerCaseScopesSet.scopes.has(scope.toLowerCase()) : false;\n  }\n  /**\n   * Check if a set of scopes is present in this set of scopes.\n   * @param scopeSet\n   */\n  containsScopeSet(scopeSet) {\n    if (!scopeSet || scopeSet.scopes.size <= 0) {\n      return false;\n    }\n    return this.scopes.size >= scopeSet.scopes.size && scopeSet.asArray().every(scope => this.containsScope(scope));\n  }\n  /**\n   * Check if set of scopes contains only the defaults\n   */\n  containsOnlyOIDCScopes() {\n    let defaultScopeCount = 0;\n    OIDC_SCOPES.forEach(defaultScope => {\n      if (this.containsScope(defaultScope)) {\n        defaultScopeCount += 1;\n      }\n    });\n    return this.scopes.size === defaultScopeCount;\n  }\n  /**\n   * Appends single scope if passed\n   * @param newScope\n   */\n  appendScope(newScope) {\n    if (newScope) {\n      this.scopes.add(newScope.trim());\n    }\n  }\n  /**\n   * Appends multiple scopes if passed\n   * @param newScopes\n   */\n  appendScopes(newScopes) {\n    try {\n      newScopes.forEach(newScope => this.appendScope(newScope));\n    } catch (e) {\n      throw createClientAuthError(cannotAppendScopeSet);\n    }\n  }\n  /**\n   * Removes element from set of scopes.\n   * @param scope\n   */\n  removeScope(scope) {\n    if (!scope) {\n      throw createClientAuthError(cannotRemoveEmptyScope);\n    }\n    this.scopes.delete(scope.trim());\n  }\n  /**\n   * Removes default scopes from set of scopes\n   * Primarily used to prevent cache misses if the default scopes are not returned from the server\n   */\n  removeOIDCScopes() {\n    OIDC_SCOPES.forEach(defaultScope => {\n      this.scopes.delete(defaultScope);\n    });\n  }\n  /**\n   * Combines an array of scopes with the current set of scopes.\n   * @param otherScopes\n   */\n  unionScopeSets(otherScopes) {\n    if (!otherScopes) {\n      throw createClientAuthError(emptyInputScopeSet);\n    }\n    const unionScopes = new Set(); // Iterator in constructor not supported in IE11\n    otherScopes.scopes.forEach(scope => unionScopes.add(scope.toLowerCase()));\n    this.scopes.forEach(scope => unionScopes.add(scope.toLowerCase()));\n    return unionScopes;\n  }\n  /**\n   * Check if scopes intersect between this set and another.\n   * @param otherScopes\n   */\n  intersectingScopeSets(otherScopes) {\n    if (!otherScopes) {\n      throw createClientAuthError(emptyInputScopeSet);\n    }\n    // Do not allow OIDC scopes to be the only intersecting scopes\n    if (!otherScopes.containsOnlyOIDCScopes()) {\n      otherScopes.removeOIDCScopes();\n    }\n    const unionScopes = this.unionScopeSets(otherScopes);\n    const sizeOtherScopes = otherScopes.getScopeCount();\n    const sizeThisScopes = this.getScopeCount();\n    const sizeUnionScopes = unionScopes.size;\n    return sizeUnionScopes < sizeThisScopes + sizeOtherScopes;\n  }\n  /**\n   * Returns size of set of scopes.\n   */\n  getScopeCount() {\n    return this.scopes.size;\n  }\n  /**\n   * Returns the scopes as an array of string values\n   */\n  asArray() {\n    const array = [];\n    this.scopes.forEach(val => array.push(val));\n    return array;\n  }\n  /**\n   * Prints scopes into a space-delimited string\n   */\n  printScopes() {\n    if (this.scopes) {\n      const scopeArr = this.asArray();\n      return scopeArr.join(\" \");\n    }\n    return Constants.EMPTY_STRING;\n  }\n  /**\n   * Prints scopes into a space-delimited lower-case string (used for caching)\n   */\n  printScopesLowerCase() {\n    return this.printScopes().toLowerCase();\n  }\n}\nexport { ScopeSet };\n//# sourceMappingURL=ScopeSet.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}