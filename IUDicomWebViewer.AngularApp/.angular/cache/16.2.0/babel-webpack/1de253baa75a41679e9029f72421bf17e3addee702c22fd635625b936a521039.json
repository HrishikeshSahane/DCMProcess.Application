{"ast":null,"code":"/*! @azure/msal-browser v3.6.0 2023-12-01 */\n'use strict';\n\nimport _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { AccountEntity, PerformanceEvents, AuthenticationScheme, createClientConfigurationError, ClientConfigurationErrorCodes, StringUtils, UrlString, ServerTelemetryManager, AuthorityFactory } from '@azure/msal-common';\nimport { version } from '../packageMetadata.mjs';\nimport { BrowserConstants } from '../utils/BrowserConstants.mjs';\nimport { getCurrentUri } from '../utils/BrowserUtils.mjs';\nimport { createNewGuid } from '../crypto/BrowserCrypto.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass BaseInteractionClient {\n  constructor(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId) {\n    this.config = config;\n    this.browserStorage = storageImpl;\n    this.browserCrypto = browserCrypto;\n    this.networkClient = this.config.system.networkClient;\n    this.eventHandler = eventHandler;\n    this.navigationClient = navigationClient;\n    this.nativeMessageHandler = nativeMessageHandler;\n    this.correlationId = correlationId || createNewGuid();\n    this.logger = logger.clone(BrowserConstants.MSAL_SKU, version, this.correlationId);\n    this.performanceClient = performanceClient;\n  }\n  clearCacheOnLogout(account) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (account) {\n        if (AccountEntity.accountInfoIsEqual(account, _this.browserStorage.getActiveAccount(), false)) {\n          _this.logger.verbose(\"Setting active account to null\");\n          _this.browserStorage.setActiveAccount(null);\n        }\n        // Clear given account.\n        try {\n          yield _this.browserStorage.removeAccount(AccountEntity.generateAccountCacheKey(account));\n          _this.logger.verbose(\"Cleared cache items belonging to the account provided in the logout request.\");\n        } catch (error) {\n          _this.logger.error(\"Account provided in logout request was not found. Local cache unchanged.\");\n        }\n      } else {\n        try {\n          _this.logger.verbose(\"No account provided in logout request, clearing all cache items.\", _this.correlationId);\n          // Clear all accounts and tokens\n          yield _this.browserStorage.clear();\n          // Clear any stray keys from IndexedDB\n          yield _this.browserCrypto.clearKeystore();\n        } catch (e) {\n          _this.logger.error(\"Attempted to clear all MSAL cache items and failed. Local cache unchanged.\");\n        }\n      }\n    })();\n  }\n  /**\n   * Initializer function for all request APIs\n   * @param request\n   */\n  initializeBaseRequest(request, account) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.performanceClient.addQueueMeasurement(PerformanceEvents.InitializeBaseRequest, _this2.correlationId);\n      const authority = request.authority || _this2.config.auth.authority;\n      if (account) {\n        yield _this2.validateRequestAuthority(authority, account);\n      }\n      const scopes = [...(request && request.scopes || [])];\n      const validatedRequest = {\n        ...request,\n        correlationId: _this2.correlationId,\n        authority,\n        scopes\n      };\n      // Set authenticationScheme to BEARER if not explicitly set in the request\n      if (!validatedRequest.authenticationScheme) {\n        validatedRequest.authenticationScheme = AuthenticationScheme.BEARER;\n        _this2.logger.verbose('Authentication Scheme wasn\\'t explicitly set in request, defaulting to \"Bearer\" request');\n      } else {\n        if (validatedRequest.authenticationScheme === AuthenticationScheme.SSH) {\n          if (!request.sshJwk) {\n            throw createClientConfigurationError(ClientConfigurationErrorCodes.missingSshJwk);\n          }\n          if (!request.sshKid) {\n            throw createClientConfigurationError(ClientConfigurationErrorCodes.missingSshKid);\n          }\n        }\n        _this2.logger.verbose(`Authentication Scheme set to \"${validatedRequest.authenticationScheme}\" as configured in Auth request`);\n      }\n      // Set requested claims hash if claims-based caching is enabled and claims were requested\n      if (_this2.config.cache.claimsBasedCachingEnabled && request.claims &&\n      // Checks for empty stringified object \"{}\" which doesn't qualify as requested claims\n      !StringUtils.isEmptyObj(request.claims)) {\n        validatedRequest.requestedClaimsHash = yield _this2.browserCrypto.hashString(request.claims);\n      }\n      return validatedRequest;\n    })();\n  }\n  /**\n   *\n   * Use to get the redirect uri configured in MSAL or null.\n   * @param requestRedirectUri\n   * @returns Redirect URL\n   *\n   */\n  getRedirectUri(requestRedirectUri) {\n    this.logger.verbose(\"getRedirectUri called\");\n    const redirectUri = requestRedirectUri || this.config.auth.redirectUri || getCurrentUri();\n    return UrlString.getAbsoluteUrl(redirectUri, getCurrentUri());\n  }\n  /*\n   * If authority provided in the request does not match environment/authority specified\n   * in the account or MSAL config, we throw an error.\n   */\n  validateRequestAuthority(authority, account) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const discoveredAuthority = yield _this3.getDiscoveredAuthority(authority);\n      if (!discoveredAuthority.isAlias(account.environment)) {\n        throw createClientConfigurationError(ClientConfigurationErrorCodes.authorityMismatch);\n      }\n    })();\n  }\n  /**\n   *\n   * @param apiId\n   * @param correlationId\n   * @param forceRefresh\n   */\n  initializeServerTelemetryManager(apiId, forceRefresh) {\n    this.logger.verbose(\"initializeServerTelemetryManager called\");\n    const telemetryPayload = {\n      clientId: this.config.auth.clientId,\n      correlationId: this.correlationId,\n      apiId: apiId,\n      forceRefresh: forceRefresh || false,\n      wrapperSKU: this.browserStorage.getWrapperMetadata()[0],\n      wrapperVer: this.browserStorage.getWrapperMetadata()[1]\n    };\n    return new ServerTelemetryManager(telemetryPayload, this.browserStorage);\n  }\n  /**\n   * Used to get a discovered version of the default authority.\n   * @param requestAuthority\n   */\n  getDiscoveredAuthority(requestAuthority) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      _this4.logger.verbose(\"getDiscoveredAuthority called\");\n      const authorityOptions = {\n        protocolMode: _this4.config.auth.protocolMode,\n        OIDCOptions: _this4.config.auth.OIDCOptions,\n        knownAuthorities: _this4.config.auth.knownAuthorities,\n        cloudDiscoveryMetadata: _this4.config.auth.cloudDiscoveryMetadata,\n        authorityMetadata: _this4.config.auth.authorityMetadata\n      };\n      if (requestAuthority) {\n        _this4.logger.verbose(\"Creating discovered authority with request authority\");\n        return AuthorityFactory.createDiscoveredInstance(requestAuthority, _this4.config.system.networkClient, _this4.browserStorage, authorityOptions, _this4.logger);\n      }\n      _this4.logger.verbose(\"Creating discovered authority with configured authority\");\n      return AuthorityFactory.createDiscoveredInstance(_this4.config.auth.authority, _this4.config.system.networkClient, _this4.browserStorage, authorityOptions, _this4.logger);\n    })();\n  }\n}\nexport { BaseInteractionClient };\n//# sourceMappingURL=BaseInteractionClient.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}