{"ast":null,"code":"/*! @azure/msal-common v14.5.0 2023-12-01 */\n'use strict';\n\nimport { IntFields, PerformanceEventStatus } from './PerformanceEvent.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass PerformanceClient {\n  /**\n   * Creates an instance of PerformanceClient,\n   * an abstract class containing core performance telemetry logic.\n   *\n   * @constructor\n   * @param {string} clientId Client ID of the application\n   * @param {string} authority Authority used by the application\n   * @param {Logger} logger Logger used by the application\n   * @param {string} libraryName Name of the library\n   * @param {string} libraryVersion Version of the library\n   * @param {ApplicationTelemetry} applicationTelemetry application name and version\n   * @param {Set<String>} intFields integer fields to be truncated\n   */\n  constructor(clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry, intFields) {\n    this.authority = authority;\n    this.libraryName = libraryName;\n    this.libraryVersion = libraryVersion;\n    this.applicationTelemetry = applicationTelemetry;\n    this.clientId = clientId;\n    this.logger = logger;\n    this.callbacks = new Map();\n    this.eventsByCorrelationId = new Map();\n    this.queueMeasurements = new Map();\n    this.preQueueTimeByCorrelationId = new Map();\n    this.intFields = intFields || new Set();\n    for (const item of IntFields) {\n      this.intFields.add(item);\n    }\n  }\n  /**\n   * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\n   * Note: this function can be changed to abstract at the next major version bump.\n   *\n   * @param {string} measureName\n   * @param {string} correlationId\n   * @returns {IPerformanceMeasurement}\n   */\n  startPerformanceMeasurement(measureName,\n  // eslint-disable-line @typescript-eslint/no-unused-vars\n  correlationId // eslint-disable-line @typescript-eslint/no-unused-vars\n  ) {\n    return {};\n  }\n  /**\n   * Gets map of pre-queue times by correlation Id\n   *\n   * @param {PerformanceEvents} eventName\n   * @param {string} correlationId\n   * @returns {number}\n   */\n  getPreQueueTime(eventName, correlationId) {\n    const preQueueEvent = this.preQueueTimeByCorrelationId.get(correlationId);\n    if (!preQueueEvent) {\n      this.logger.trace(`PerformanceClient.getPreQueueTime: no pre-queue times found for correlationId: ${correlationId}, unable to add queue measurement`);\n      return;\n    } else if (preQueueEvent.name !== eventName) {\n      this.logger.trace(`PerformanceClient.getPreQueueTime: no pre-queue time found for ${eventName}, unable to add queue measurement`);\n      return;\n    }\n    return preQueueEvent.time;\n  }\n  /**\n   * Calculates the difference between current time and time when function was queued.\n   * Note: It is possible to have 0 as the queue time if the current time and the queued time was the same.\n   *\n   * @param {number} preQueueTime\n   * @param {number} currentTime\n   * @returns {number}\n   */\n  calculateQueuedTime(preQueueTime, currentTime) {\n    if (preQueueTime < 1) {\n      this.logger.trace(`PerformanceClient: preQueueTime should be a positive integer and not ${preQueueTime}`);\n      return 0;\n    }\n    if (currentTime < 1) {\n      this.logger.trace(`PerformanceClient: currentTime should be a positive integer and not ${currentTime}`);\n      return 0;\n    }\n    if (currentTime < preQueueTime) {\n      this.logger.trace(\"PerformanceClient: currentTime is less than preQueueTime, check how time is being retrieved\");\n      return 0;\n    }\n    return currentTime - preQueueTime;\n  }\n  /**\n   * Adds queue measurement time to QueueMeasurements array for given correlation ID.\n   *\n   * @param {PerformanceEvents} eventName\n   * @param {?string} correlationId\n   * @param {?number} queueTime\n   * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements\n   * @returns\n   */\n  addQueueMeasurement(eventName, correlationId, queueTime, manuallyCompleted) {\n    if (!correlationId) {\n      this.logger.trace(`PerformanceClient.addQueueMeasurement: correlationId not provided for ${eventName}, cannot add queue measurement`);\n      return;\n    }\n    if (queueTime === 0) {\n      // Possible for there to be no queue time after calculation\n      this.logger.trace(`PerformanceClient.addQueueMeasurement: queue time provided for ${eventName} is ${queueTime}`);\n    } else if (!queueTime) {\n      this.logger.trace(`PerformanceClient.addQueueMeasurement: no queue time provided for ${eventName}`);\n      return;\n    }\n    const queueMeasurement = {\n      eventName,\n      // Always default queue time to 0 for manually completed (improperly instrumented)\n      queueTime: manuallyCompleted ? 0 : queueTime,\n      manuallyCompleted\n    };\n    // Adds to existing correlation Id if present in queueMeasurements\n    const existingMeasurements = this.queueMeasurements.get(correlationId);\n    if (existingMeasurements) {\n      existingMeasurements.push(queueMeasurement);\n      this.queueMeasurements.set(correlationId, existingMeasurements);\n    } else {\n      // Sets new correlation Id if not present in queueMeasurements\n      this.logger.trace(`PerformanceClient.addQueueMeasurement: adding correlationId ${correlationId} to queue measurements`);\n      const measurementArray = [queueMeasurement];\n      this.queueMeasurements.set(correlationId, measurementArray);\n    }\n    // Delete processed pre-queue event.\n    this.preQueueTimeByCorrelationId.delete(correlationId);\n  }\n  /**\n   * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\n   *\n   * @param {PerformanceEvents} measureName\n   * @param {?string} [correlationId]\n   * @returns {InProgressPerformanceEvent}\n   */\n  startMeasurement(measureName, correlationId) {\n    // Generate a placeholder correlation if the request does not provide one\n    const eventCorrelationId = correlationId || this.generateId();\n    if (!correlationId) {\n      this.logger.info(`PerformanceClient: No correlation id provided for ${measureName}, generating`, eventCorrelationId);\n    }\n    this.logger.trace(`PerformanceClient: Performance measurement started for ${measureName}`, eventCorrelationId);\n    const performanceMeasurement = this.startPerformanceMeasurement(measureName, eventCorrelationId);\n    performanceMeasurement.startMeasurement();\n    const inProgressEvent = {\n      eventId: this.generateId(),\n      status: PerformanceEventStatus.InProgress,\n      authority: this.authority,\n      libraryName: this.libraryName,\n      libraryVersion: this.libraryVersion,\n      clientId: this.clientId,\n      name: measureName,\n      startTimeMs: Date.now(),\n      correlationId: eventCorrelationId,\n      appName: this.applicationTelemetry?.appName,\n      appVersion: this.applicationTelemetry?.appVersion\n    };\n    // Store in progress events so they can be discarded if not ended properly\n    this.cacheEventByCorrelationId(inProgressEvent);\n    // Return the event and functions the caller can use to properly end/flush the measurement\n    return {\n      end: event => {\n        return this.endMeasurement({\n          // Initial set of event properties\n          ...inProgressEvent,\n          // Properties set when event ends\n          ...event\n        }, performanceMeasurement);\n      },\n      discard: () => {\n        return this.discardMeasurements(inProgressEvent.correlationId);\n      },\n      add: fields => {\n        return this.addFields(fields, inProgressEvent.correlationId);\n      },\n      increment: fields => {\n        return this.incrementFields(fields, inProgressEvent.correlationId);\n      },\n      measurement: performanceMeasurement,\n      event: inProgressEvent\n    };\n  }\n  /**\n   * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\n   * as consumers should instead use the function returned by startMeasurement.\n   * Adds a new field named as \"[event name]DurationMs\" for sub-measurements, completes and emits an event\n   * otherwise.\n   *\n   * @param {PerformanceEvent} event\n   * @param {IPerformanceMeasurement} measurement\n   * @returns {(PerformanceEvent | null)}\n   */\n  endMeasurement(event, measurement) {\n    const rootEvent = this.eventsByCorrelationId.get(event.correlationId);\n    if (!rootEvent) {\n      this.logger.trace(`PerformanceClient: Measurement not found for ${event.eventId}`, event.correlationId);\n      return null;\n    }\n    const isRoot = event.eventId === rootEvent.eventId;\n    let queueInfo = {\n      totalQueueTime: 0,\n      totalQueueCount: 0,\n      manuallyCompletedCount: 0\n    };\n    if (isRoot) {\n      queueInfo = this.getQueueInfo(event.correlationId);\n      this.discardCache(rootEvent.correlationId);\n    } else {\n      rootEvent.incompleteSubMeasurements?.delete(event.eventId);\n    }\n    measurement?.endMeasurement();\n    const durationMs = measurement?.flushMeasurement();\n    // null indicates no measurement was taken (e.g. needed performance APIs not present)\n    if (!durationMs) {\n      this.logger.trace(\"PerformanceClient: Performance measurement not taken\", rootEvent.correlationId);\n      return null;\n    }\n    this.logger.trace(`PerformanceClient: Performance measurement ended for ${event.name}: ${durationMs} ms`, event.correlationId);\n    // Add sub-measurement attribute to root event.\n    if (!isRoot) {\n      rootEvent[event.name + \"DurationMs\"] = Math.floor(durationMs);\n      return {\n        ...rootEvent\n      };\n    }\n    let finalEvent = {\n      ...rootEvent,\n      ...event\n    };\n    let incompleteSubsCount = 0;\n    // Incomplete sub-measurements are discarded. They are likely an instrumentation bug that should be fixed.\n    finalEvent.incompleteSubMeasurements?.forEach(subMeasurement => {\n      this.logger.trace(`PerformanceClient: Incomplete submeasurement ${subMeasurement.name} found for ${event.name}`, finalEvent.correlationId);\n      incompleteSubsCount++;\n    });\n    finalEvent.incompleteSubMeasurements = undefined;\n    finalEvent = {\n      ...finalEvent,\n      durationMs: Math.round(durationMs),\n      queuedTimeMs: queueInfo.totalQueueTime,\n      queuedCount: queueInfo.totalQueueCount,\n      queuedManuallyCompletedCount: queueInfo.manuallyCompletedCount,\n      status: PerformanceEventStatus.Completed,\n      incompleteSubsCount\n    };\n    this.truncateIntegralFields(finalEvent);\n    this.emitEvents([finalEvent], event.correlationId);\n    return finalEvent;\n  }\n  /**\n   * Saves extra information to be emitted when the measurements are flushed\n   * @param fields\n   * @param correlationId\n   */\n  addFields(fields, correlationId) {\n    this.logger.trace(\"PerformanceClient: Updating static fields\");\n    const event = this.eventsByCorrelationId.get(correlationId);\n    if (event) {\n      this.eventsByCorrelationId.set(correlationId, {\n        ...event,\n        ...fields\n      });\n    } else {\n      this.logger.trace(\"PerformanceClient: Event not found for\", correlationId);\n    }\n  }\n  /**\n   * Increment counters to be emitted when the measurements are flushed\n   * @param fields {string[]}\n   * @param correlationId {string} correlation identifier\n   */\n  incrementFields(fields, correlationId) {\n    this.logger.trace(\"PerformanceClient: Updating counters\");\n    const event = this.eventsByCorrelationId.get(correlationId);\n    if (event) {\n      for (const counter in fields) {\n        if (!event.hasOwnProperty(counter)) {\n          event[counter] = 0;\n        } else if (isNaN(Number(event[counter]))) {\n          return;\n        }\n        event[counter] += fields[counter];\n      }\n    } else {\n      this.logger.trace(\"PerformanceClient: Event not found for\", correlationId);\n    }\n  }\n  /**\n   * Upserts event into event cache.\n   * First key is the correlation id, second key is the event id.\n   * Allows for events to be grouped by correlation id,\n   * and to easily allow for properties on them to be updated.\n   *\n   * @private\n   * @param {PerformanceEvent} event\n   */\n  cacheEventByCorrelationId(event) {\n    const rootEvent = this.eventsByCorrelationId.get(event.correlationId);\n    if (rootEvent) {\n      this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} added/updated`, event.correlationId);\n      rootEvent.incompleteSubMeasurements = rootEvent.incompleteSubMeasurements || new Map();\n      rootEvent.incompleteSubMeasurements.set(event.eventId, {\n        name: event.name,\n        startTimeMs: event.startTimeMs\n      });\n    } else {\n      this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} started`, event.correlationId);\n      this.eventsByCorrelationId.set(event.correlationId, {\n        ...event\n      });\n    }\n  }\n  getQueueInfo(correlationId) {\n    const queueMeasurementForCorrelationId = this.queueMeasurements.get(correlationId);\n    if (!queueMeasurementForCorrelationId) {\n      this.logger.trace(`PerformanceClient: no queue measurements found for for correlationId: ${correlationId}`);\n    }\n    let totalQueueTime = 0;\n    let totalQueueCount = 0;\n    let manuallyCompletedCount = 0;\n    queueMeasurementForCorrelationId?.forEach(measurement => {\n      totalQueueTime += measurement.queueTime;\n      totalQueueCount++;\n      manuallyCompletedCount += measurement.manuallyCompleted ? 1 : 0;\n    });\n    return {\n      totalQueueTime,\n      totalQueueCount,\n      manuallyCompletedCount\n    };\n  }\n  /**\n   * Removes measurements for a given correlation id.\n   *\n   * @param {string} correlationId\n   */\n  discardMeasurements(correlationId) {\n    this.logger.trace(\"PerformanceClient: Performance measurements discarded\", correlationId);\n    this.eventsByCorrelationId.delete(correlationId);\n  }\n  /**\n   * Removes cache for a given correlation id.\n   *\n   * @param {string} correlationId correlation identifier\n   */\n  discardCache(correlationId) {\n    this.discardMeasurements(correlationId);\n    this.logger.trace(\"PerformanceClient: QueueMeasurements discarded\", correlationId);\n    this.queueMeasurements.delete(correlationId);\n    this.logger.trace(\"PerformanceClient: Pre-queue times discarded\", correlationId);\n    this.preQueueTimeByCorrelationId.delete(correlationId);\n  }\n  /**\n   * Registers a callback function to receive performance events.\n   *\n   * @param {PerformanceCallbackFunction} callback\n   * @returns {string}\n   */\n  addPerformanceCallback(callback) {\n    const callbackId = this.generateId();\n    this.callbacks.set(callbackId, callback);\n    this.logger.verbose(`PerformanceClient: Performance callback registered with id: ${callbackId}`);\n    return callbackId;\n  }\n  /**\n   * Removes a callback registered with addPerformanceCallback.\n   *\n   * @param {string} callbackId\n   * @returns {boolean}\n   */\n  removePerformanceCallback(callbackId) {\n    const result = this.callbacks.delete(callbackId);\n    if (result) {\n      this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} removed.`);\n    } else {\n      this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} not removed.`);\n    }\n    return result;\n  }\n  /**\n   * Emits events to all registered callbacks.\n   *\n   * @param {PerformanceEvent[]} events\n   * @param {?string} [correlationId]\n   */\n  emitEvents(events, correlationId) {\n    this.logger.verbose(\"PerformanceClient: Emitting performance events\", correlationId);\n    this.callbacks.forEach((callback, callbackId) => {\n      this.logger.trace(`PerformanceClient: Emitting event to callback ${callbackId}`, correlationId);\n      callback.apply(null, [events]);\n    });\n  }\n  /**\n   * Enforce truncation of integral fields in performance event.\n   * @param {PerformanceEvent} event performance event to update.\n   * @param {Set<string>} intFields integral fields.\n   */\n  truncateIntegralFields(event) {\n    this.intFields.forEach(key => {\n      if (key in event && typeof event[key] === \"number\") {\n        event[key] = Math.floor(event[key]);\n      }\n    });\n  }\n}\nexport { PerformanceClient };\n//# sourceMappingURL=PerformanceClient.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}