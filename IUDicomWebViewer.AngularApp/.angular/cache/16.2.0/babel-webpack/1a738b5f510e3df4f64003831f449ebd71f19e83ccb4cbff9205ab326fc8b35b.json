{"ast":null,"code":"/*! @azure/msal-common v14.5.0 2023-12-01 */\n'use strict';\n\nimport _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Separators, CredentialType, AuthenticationScheme, THE_FAMILY_ID, APP_METADATA, AUTHORITY_METADATA_CONSTANTS } from '../utils/Constants.mjs';\nimport { generateCredentialKey } from './utils/CacheHelpers.mjs';\nimport { ScopeSet } from '../request/ScopeSet.mjs';\nimport { AccountEntity } from './entities/AccountEntity.mjs';\nimport { createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { updateAccountTenantProfileData, tenantIdMatchesHomeTenant } from '../account/AccountInfo.mjs';\nimport { extractTokenClaims } from '../account/AuthToken.mjs';\nimport { name, version } from '../packageMetadata.mjs';\nimport { getTenantFromAuthorityString } from '../authority/Authority.mjs';\nimport { getAliasesFromStaticSources } from '../authority/AuthorityMetadata.mjs';\nimport { invalidCacheRecord, bindingKeyNotRemoved, multipleMatchingAppMetadata, methodNotImplemented } from '../error/ClientAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\n * @internal\n */\nclass CacheManager {\n  constructor(clientId, cryptoImpl, logger, staticAuthorityOptions) {\n    this.clientId = clientId;\n    this.cryptoImpl = cryptoImpl;\n    this.commonLogger = logger.clone(name, version);\n    this.staticAuthorityOptions = staticAuthorityOptions;\n  }\n  /**\n   * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.\n   * @param accountFilter - (Optional) filter to narrow down the accounts returned\n   * @returns Array of AccountInfo objects in cache\n   */\n  getAllAccounts(accountFilter) {\n    return this.buildTenantProfiles(this.getAccountsFilteredBy(accountFilter || {}), accountFilter);\n  }\n  /**\n   * Gets first tenanted AccountInfo object found based on provided filters\n   */\n  getAccountInfoFilteredBy(accountFilter) {\n    const allAccounts = this.getAllAccounts(accountFilter);\n    if (allAccounts.length > 1) {\n      // If one or more accounts are found, prioritize accounts that have an ID token\n      const sortedAccounts = allAccounts.sort(account => {\n        return account.idTokenClaims ? -1 : 1;\n      });\n      return sortedAccounts[0];\n    } else if (allAccounts.length === 1) {\n      // If only one account is found, return it regardless of whether a matching ID token was found\n      return allAccounts[0];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Returns a single matching\n   * @param accountFilter\n   * @returns\n   */\n  getBaseAccountInfo(accountFilter) {\n    const accountEntities = this.getAccountsFilteredBy(accountFilter);\n    if (accountEntities.length > 0) {\n      return accountEntities[0].getAccountInfo();\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Matches filtered account entities with cached ID tokens that match the tenant profile-specific account filters\n   * and builds the account info objects from the matching ID token's claims\n   * @param cachedAccounts\n   * @param accountFilter\n   * @returns Array of AccountInfo objects that match account and tenant profile filters\n   */\n  buildTenantProfiles(cachedAccounts, accountFilter) {\n    return cachedAccounts.flatMap(accountEntity => {\n      return this.getAccountInfoForTenantProfiles(accountEntity, accountFilter);\n    });\n  }\n  getAccountInfoForTenantProfiles(accountEntity, accountFilter) {\n    return this.getTenantProfilesFromAccountEntity(accountEntity, accountFilter?.tenantId, accountFilter);\n  }\n  getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, tenantProfileFilter) {\n    let tenantedAccountInfo = null;\n    let idTokenClaims;\n    if (tenantProfileFilter) {\n      if (!this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter)) {\n        return null;\n      }\n    }\n    const idToken = this.getIdToken(accountInfo, tokenKeys, tenantProfile.tenantId);\n    if (idToken) {\n      idTokenClaims = extractTokenClaims(idToken.secret, this.cryptoImpl.base64Decode);\n      if (!this.idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter)) {\n        // ID token sourced claims don't match so this tenant profile is not a match\n        return null;\n      }\n    }\n    // Expand tenant profile into account info based on matching tenant profile and if available matching ID token claims\n    tenantedAccountInfo = updateAccountTenantProfileData(accountInfo, tenantProfile, idTokenClaims);\n    return tenantedAccountInfo;\n  }\n  getTenantProfilesFromAccountEntity(accountEntity, targetTenantId, tenantProfileFilter) {\n    const accountInfo = accountEntity.getAccountInfo();\n    let searchTenantProfiles = accountInfo.tenantProfiles || new Map();\n    const tokenKeys = this.getTokenKeys();\n    // If a tenant ID was provided, only return the tenant profile for that tenant ID if it exists\n    if (targetTenantId) {\n      const tenantProfile = searchTenantProfiles.get(targetTenantId);\n      if (tenantProfile) {\n        // Reduce search field to just this tenant profile\n        searchTenantProfiles = new Map([[targetTenantId, tenantProfile]]);\n      } else {\n        // No tenant profile for search tenant ID, return empty array\n        return [];\n      }\n    }\n    const matchingTenantProfiles = [];\n    searchTenantProfiles.forEach(tenantProfile => {\n      const tenantedAccountInfo = this.getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, tenantProfileFilter);\n      if (tenantedAccountInfo) {\n        matchingTenantProfiles.push(tenantedAccountInfo);\n      }\n    });\n    return matchingTenantProfiles;\n  }\n  tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter) {\n    if (!!tenantProfileFilter.localAccountId && !this.matchLocalAccountIdFromTenantProfile(tenantProfile, tenantProfileFilter.localAccountId)) {\n      return false;\n    }\n    if (!!tenantProfileFilter.name && !(tenantProfile.name === tenantProfileFilter.name)) {\n      return false;\n    }\n    if (tenantProfileFilter.isHomeTenant !== undefined && !(tenantProfile.isHomeTenant === tenantProfileFilter.isHomeTenant)) {\n      return false;\n    }\n    return true;\n  }\n  idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter) {\n    // Tenant Profile filtering\n    if (tenantProfileFilter) {\n      if (!!tenantProfileFilter.localAccountId && !this.matchLocalAccountIdFromTokenClaims(idTokenClaims, tenantProfileFilter.localAccountId)) {\n        return false;\n      }\n      if (!!tenantProfileFilter.loginHint && !this.matchLoginHintFromTokenClaims(idTokenClaims, tenantProfileFilter.loginHint)) {\n        return false;\n      }\n      if (!!tenantProfileFilter.username && !this.matchUsername(idTokenClaims.preferred_username, tenantProfileFilter.username)) {\n        return false;\n      }\n      if (!!tenantProfileFilter.name && !this.matchName(idTokenClaims, tenantProfileFilter.name)) {\n        return false;\n      }\n      if (!!tenantProfileFilter.sid && !this.matchSid(idTokenClaims, tenantProfileFilter.sid)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * saves a cache record\n   * @param cacheRecord\n   */\n  saveCacheRecord(cacheRecord, storeInCache) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!cacheRecord) {\n        throw createClientAuthError(invalidCacheRecord);\n      }\n      if (!!cacheRecord.account) {\n        _this.setAccount(cacheRecord.account);\n      }\n      if (!!cacheRecord.idToken && storeInCache?.idToken !== false) {\n        _this.setIdTokenCredential(cacheRecord.idToken);\n      }\n      if (!!cacheRecord.accessToken && storeInCache?.accessToken !== false) {\n        yield _this.saveAccessToken(cacheRecord.accessToken);\n      }\n      if (!!cacheRecord.refreshToken && storeInCache?.refreshToken !== false) {\n        _this.setRefreshTokenCredential(cacheRecord.refreshToken);\n      }\n      if (!!cacheRecord.appMetadata) {\n        _this.setAppMetadata(cacheRecord.appMetadata);\n      }\n    })();\n  }\n  /**\n   * saves access token credential\n   * @param credential\n   */\n  saveAccessToken(credential) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const accessTokenFilter = {\n        clientId: credential.clientId,\n        credentialType: credential.credentialType,\n        environment: credential.environment,\n        homeAccountId: credential.homeAccountId,\n        realm: credential.realm,\n        tokenType: credential.tokenType,\n        requestedClaimsHash: credential.requestedClaimsHash\n      };\n      const tokenKeys = _this2.getTokenKeys();\n      const currentScopes = ScopeSet.fromString(credential.target);\n      const removedAccessTokens = [];\n      tokenKeys.accessToken.forEach(key => {\n        if (!_this2.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {\n          return;\n        }\n        const tokenEntity = _this2.getAccessTokenCredential(key);\n        if (tokenEntity && _this2.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {\n          const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\n          if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\n            removedAccessTokens.push(_this2.removeAccessToken(key));\n          }\n        }\n      });\n      yield Promise.all(removedAccessTokens);\n      _this2.setAccessTokenCredential(credential);\n    })();\n  }\n  /**\n   * Retrieve account entities matching all provided tenant-agnostic filters; if no filter is set, get all account entities in the cache\n   * Not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\n   * @param accountFilter - An object containing Account properties to filter by\n   */\n  getAccountsFilteredBy(accountFilter) {\n    const allAccountKeys = this.getAccountKeys();\n    const matchingAccounts = [];\n    allAccountKeys.forEach(cacheKey => {\n      if (!this.isAccountKey(cacheKey, accountFilter.homeAccountId)) {\n        // Don't parse value if the key doesn't match the account filters\n        return;\n      }\n      const entity = this.getAccount(cacheKey, this.commonLogger);\n      // Match base account fields\n      if (!entity) {\n        return;\n      }\n      if (!!accountFilter.homeAccountId && !this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {\n        return;\n      }\n      if (!!accountFilter.username && !this.matchUsername(entity.username, accountFilter.username)) {\n        return;\n      }\n      if (!!accountFilter.environment && !this.matchEnvironment(entity, accountFilter.environment)) {\n        return;\n      }\n      if (!!accountFilter.realm && !this.matchRealm(entity, accountFilter.realm)) {\n        return;\n      }\n      if (!!accountFilter.nativeAccountId && !this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {\n        return;\n      }\n      if (!!accountFilter.authorityType && !this.matchAuthorityType(entity, accountFilter.authorityType)) {\n        return;\n      }\n      // If at least one tenant profile matches the tenant profile filter, add the account to the list of matching accounts\n      const tenantProfileFilter = {\n        localAccountId: accountFilter?.localAccountId,\n        name: accountFilter?.name\n      };\n      const matchingTenantProfiles = entity.tenantProfiles?.filter(tenantProfile => {\n        return this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter);\n      });\n      if (matchingTenantProfiles && matchingTenantProfiles.length === 0) {\n        // No tenant profile for this account matches filter, don't add to list of matching accounts\n        return;\n      }\n      matchingAccounts.push(entity);\n    });\n    return matchingAccounts;\n  }\n  /**\n   * Returns true if the given key matches our account key schema. Also matches homeAccountId and/or tenantId if provided\n   * @param key\n   * @param homeAccountId\n   * @param tenantId\n   * @returns\n   */\n  isAccountKey(key, homeAccountId, tenantId) {\n    if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {\n      // Account cache keys contain 3 items separated by '-' (each item may also contain '-')\n      return false;\n    }\n    if (homeAccountId && !key.toLowerCase().includes(homeAccountId.toLowerCase())) {\n      return false;\n    }\n    if (tenantId && !key.toLowerCase().includes(tenantId.toLowerCase())) {\n      return false;\n    }\n    // Do not check environment as aliasing can cause false negatives\n    return true;\n  }\n  /**\n   * Returns true if the given key matches our credential key schema.\n   * @param key\n   */\n  isCredentialKey(key) {\n    if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {\n      // Credential cache keys contain 6 items separated by '-' (each item may also contain '-')\n      return false;\n    }\n    const lowerCaseKey = key.toLowerCase();\n    // Credential keys must indicate what credential type they represent\n    if (lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) === -1) {\n      return false;\n    }\n    if (lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) > -1) {\n      // Refresh tokens must contain the client id or family id\n      const clientIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${this.clientId}${Separators.CACHE_KEY_SEPARATOR}`;\n      const familyIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${THE_FAMILY_ID}${Separators.CACHE_KEY_SEPARATOR}`;\n      if (lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 && lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1) {\n        return false;\n      }\n    } else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {\n      // Tokens must contain the clientId\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Returns whether or not the given credential entity matches the filter\n   * @param entity\n   * @param filter\n   * @returns\n   */\n  credentialMatchesFilter(entity, filter) {\n    if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {\n      return false;\n    }\n    if (!!filter.userAssertionHash && !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {\n      return false;\n    }\n    /*\n     * homeAccountId can be undefined, and we want to filter out cached items that have a homeAccountId of \"\"\n     * because we don't want a client_credential request to return a cached token that has a homeAccountId\n     */\n    if (typeof filter.homeAccountId === \"string\" && !this.matchHomeAccountId(entity, filter.homeAccountId)) {\n      return false;\n    }\n    if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {\n      return false;\n    }\n    if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {\n      return false;\n    }\n    if (!!filter.credentialType && !this.matchCredentialType(entity, filter.credentialType)) {\n      return false;\n    }\n    if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {\n      return false;\n    }\n    /*\n     * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\n     * Resource specific refresh tokens case will be added when the support is deemed necessary\n     */\n    if (!!filter.target && !this.matchTarget(entity, filter.target)) {\n      return false;\n    }\n    // If request OR cached entity has requested Claims Hash, check if they match\n    if (filter.requestedClaimsHash || entity.requestedClaimsHash) {\n      // Don't match if either is undefined or they are different\n      if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {\n        return false;\n      }\n    }\n    // Access Token with Auth Scheme specific matching\n    if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\n      if (!!filter.tokenType && !this.matchTokenType(entity, filter.tokenType)) {\n        return false;\n      }\n      // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\n      if (filter.tokenType === AuthenticationScheme.SSH) {\n        if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\n   * @param filter\n   */\n  getAppMetadataFilteredBy(filter) {\n    return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);\n  }\n  /**\n   * Support function to help match appMetadata\n   * @param environment\n   * @param clientId\n   */\n  getAppMetadataFilteredByInternal(environment, clientId) {\n    const allCacheKeys = this.getKeys();\n    const matchingAppMetadata = {};\n    allCacheKeys.forEach(cacheKey => {\n      // don't parse any non-appMetadata type cache entities\n      if (!this.isAppMetadata(cacheKey)) {\n        return;\n      }\n      // Attempt retrieval\n      const entity = this.getAppMetadata(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (!!environment && !this.matchEnvironment(entity, environment)) {\n        return;\n      }\n      if (!!clientId && !this.matchClientId(entity, clientId)) {\n        return;\n      }\n      matchingAppMetadata[cacheKey] = entity;\n    });\n    return matchingAppMetadata;\n  }\n  /**\n   * retrieve authorityMetadata that contains a matching alias\n   * @param filter\n   */\n  getAuthorityMetadataByAlias(host) {\n    const allCacheKeys = this.getAuthorityMetadataKeys();\n    let matchedEntity = null;\n    allCacheKeys.forEach(cacheKey => {\n      // don't parse any non-authorityMetadata type cache entities\n      if (!this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(this.clientId) === -1) {\n        return;\n      }\n      // Attempt retrieval\n      const entity = this.getAuthorityMetadata(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (entity.aliases.indexOf(host) === -1) {\n        return;\n      }\n      matchedEntity = entity;\n    });\n    return matchedEntity;\n  }\n  /**\n   * Removes all accounts and related tokens from cache.\n   */\n  removeAllAccounts() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const allAccountKeys = _this3.getAccountKeys();\n      const removedAccounts = [];\n      allAccountKeys.forEach(cacheKey => {\n        removedAccounts.push(_this3.removeAccount(cacheKey));\n      });\n      yield Promise.all(removedAccounts);\n    })();\n  }\n  /**\n   * Removes the account and related tokens for a given account key\n   * @param account\n   */\n  removeAccount(accountKey) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const account = _this4.getAccount(accountKey, _this4.commonLogger);\n      if (!account) {\n        return;\n      }\n      yield _this4.removeAccountContext(account);\n      _this4.removeItem(accountKey);\n    })();\n  }\n  /**\n   * Removes credentials associated with the provided account\n   * @param account\n   */\n  removeAccountContext(account) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const allTokenKeys = _this5.getTokenKeys();\n      const accountId = account.generateAccountId();\n      const removedCredentials = [];\n      allTokenKeys.idToken.forEach(key => {\n        if (key.indexOf(accountId) === 0) {\n          _this5.removeIdToken(key);\n        }\n      });\n      allTokenKeys.accessToken.forEach(key => {\n        if (key.indexOf(accountId) === 0) {\n          removedCredentials.push(_this5.removeAccessToken(key));\n        }\n      });\n      allTokenKeys.refreshToken.forEach(key => {\n        if (key.indexOf(accountId) === 0) {\n          _this5.removeRefreshToken(key);\n        }\n      });\n      yield Promise.all(removedCredentials);\n    })();\n  }\n  /**\n   * Migrates a single-tenant account and all it's associated alternate cross-tenant account objects in the\n   * cache into a condensed multi-tenant account object with tenant profiles.\n   * @param accountKey\n   * @param accountEntity\n   * @param logger\n   * @returns\n   */\n  updateOutdatedCachedAccount(accountKey, accountEntity, logger) {\n    // Only update if account entity is defined and has no tenantProfiles object (is outdated)\n    if (accountEntity && accountEntity.isSingleTenant()) {\n      this.commonLogger?.verbose(\"updateOutdatedCachedAccount: Found a single-tenant (outdated) account entity in the cache, migrating to multi-tenant account entity\");\n      // Get keys of all accounts belonging to user\n      const matchingAccountKeys = this.getAccountKeys().filter(key => {\n        return key.startsWith(accountEntity.homeAccountId);\n      });\n      // Get all account entities belonging to user\n      const accountsToMerge = [];\n      matchingAccountKeys.forEach(key => {\n        const account = this.getCachedAccountEntity(key);\n        if (account) {\n          accountsToMerge.push(account);\n        }\n      });\n      // Set base account to home account if available, any account if not\n      const baseAccount = accountsToMerge.find(account => {\n        return tenantIdMatchesHomeTenant(account.realm, account.homeAccountId);\n      }) || accountsToMerge[0];\n      // Populate tenant profiles built from each account entity belonging to the user\n      baseAccount.tenantProfiles = accountsToMerge.map(account => {\n        return {\n          tenantId: account.realm,\n          localAccountId: account.localAccountId,\n          name: account.name,\n          isHomeTenant: tenantIdMatchesHomeTenant(account.realm, account.homeAccountId)\n        };\n      });\n      const updatedAccount = CacheManager.toObject(new AccountEntity(), {\n        ...baseAccount\n      });\n      const newAccountKey = updatedAccount.generateAccountKey();\n      // Clear cache of legacy account objects that have been collpsed into tenant profiles\n      matchingAccountKeys.forEach(key => {\n        if (key !== newAccountKey) {\n          this.removeOutdatedAccount(accountKey);\n        }\n      });\n      // Cache updated account object\n      this.setAccount(updatedAccount);\n      logger?.verbose(\"Updated an outdated account entity in the cache\");\n      return updatedAccount;\n    }\n    // No update is necessary\n    return accountEntity;\n  }\n  /**\n   * returns a boolean if the given credential is removed\n   * @param credential\n   */\n  removeAccessToken(key) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const credential = _this6.getAccessTokenCredential(key);\n      if (!credential) {\n        return;\n      }\n      // Remove Token Binding Key from key store for PoP Tokens Credentials\n      if (credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) {\n        if (credential.tokenType === AuthenticationScheme.POP) {\n          const accessTokenWithAuthSchemeEntity = credential;\n          const kid = accessTokenWithAuthSchemeEntity.keyId;\n          if (kid) {\n            try {\n              yield _this6.cryptoImpl.removeTokenBindingKey(kid);\n            } catch (error) {\n              throw createClientAuthError(bindingKeyNotRemoved);\n            }\n          }\n        }\n      }\n      return _this6.removeItem(key);\n    })();\n  }\n  /**\n   * Removes all app metadata objects from cache.\n   */\n  removeAppMetadata() {\n    const allCacheKeys = this.getKeys();\n    allCacheKeys.forEach(cacheKey => {\n      if (this.isAppMetadata(cacheKey)) {\n        this.removeItem(cacheKey);\n      }\n    });\n    return true;\n  }\n  /**\n   * Retrieve the cached credentials into a cacherecord\n   * @param account {AccountInfo}\n   * @param request {BaseAuthRequest}\n   * @param environment {string}\n   * @param performanceClient {?IPerformanceClient}\n   * @param correlationId {?string}\n   */\n  readCacheRecord(account, request, environment, performanceClient, correlationId) {\n    // Use authority tenantId for cache lookup filter if it's defined, otherwise use tenantId from account passed in\n    const requestTenantId = account.tenantId || getTenantFromAuthorityString(request.authority);\n    const tokenKeys = this.getTokenKeys();\n    const cachedAccount = this.readAccountFromCache(account);\n    const cachedIdToken = this.getIdToken(account, tokenKeys, requestTenantId, performanceClient, correlationId);\n    const cachedAccessToken = this.getAccessToken(account, request, tokenKeys, requestTenantId, performanceClient, correlationId);\n    const cachedRefreshToken = this.getRefreshToken(account, false, tokenKeys, performanceClient, correlationId);\n    const cachedAppMetadata = this.readAppMetadataFromCache(environment);\n    return {\n      account: cachedAccount,\n      idToken: cachedIdToken,\n      accessToken: cachedAccessToken,\n      refreshToken: cachedRefreshToken,\n      appMetadata: cachedAppMetadata\n    };\n  }\n  /**\n   * Retrieve AccountEntity from cache\n   * @param account\n   */\n  readAccountFromCache(account) {\n    const accountKey = AccountEntity.generateAccountCacheKey(account);\n    return this.getAccount(accountKey, this.commonLogger);\n  }\n  /**\n   * Retrieve IdTokenEntity from cache\n   * @param account {AccountInfo}\n   * @param tokenKeys {?TokenKeys}\n   * @param targetRealm {?string}\n   * @param performanceClient {?IPerformanceClient}\n   * @param correlationId {?string}\n   */\n  getIdToken(account, tokenKeys, targetRealm, performanceClient, correlationId) {\n    this.commonLogger.trace(\"CacheManager - getIdToken called\");\n    const idTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.ID_TOKEN,\n      clientId: this.clientId,\n      realm: targetRealm\n    };\n    const idTokenMap = this.getIdTokensByFilter(idTokenFilter, tokenKeys);\n    const numIdTokens = idTokenMap.size;\n    if (numIdTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getIdToken - No token found\");\n      return null;\n    } else if (numIdTokens > 1) {\n      let tokensToBeRemoved = idTokenMap;\n      // Multiple tenant profiles and no tenant specified, pick home account\n      if (!targetRealm) {\n        const homeIdTokenMap = new Map();\n        idTokenMap.forEach((idToken, key) => {\n          if (idToken.realm === account.tenantId) {\n            homeIdTokenMap.set(key, idToken);\n          }\n        });\n        const numHomeIdTokens = homeIdTokenMap.size;\n        if (numHomeIdTokens < 1) {\n          this.commonLogger.info(\"CacheManager:getIdToken - Multiple ID tokens found for account but none match account entity tenant id, returning first result\");\n          return idTokenMap.values().next().value;\n        } else if (numHomeIdTokens === 1) {\n          this.commonLogger.info(\"CacheManager:getIdToken - Multiple ID tokens found for account, defaulting to home tenant profile\");\n          return homeIdTokenMap.values().next().value;\n        } else {\n          // Multiple ID tokens for home tenant profile, remove all and return null\n          tokensToBeRemoved = homeIdTokenMap;\n        }\n      }\n      // Multiple tokens for a single tenant profile, remove all and return null\n      this.commonLogger.info(\"CacheManager:getIdToken - Multiple matching ID tokens found, clearing them\");\n      tokensToBeRemoved.forEach((idToken, key) => {\n        this.removeIdToken(key);\n      });\n      if (performanceClient && correlationId) {\n        performanceClient.addFields({\n          multiMatchedID: idTokenMap.size\n        }, correlationId);\n      }\n      return null;\n    }\n    this.commonLogger.info(\"CacheManager:getIdToken - Returning ID token\");\n    return idTokenMap.values().next().value;\n  }\n  /**\n   * Gets all idTokens matching the given filter\n   * @param filter\n   * @returns\n   */\n  getIdTokensByFilter(filter, tokenKeys) {\n    const idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;\n    const idTokens = new Map();\n    idTokenKeys.forEach(key => {\n      if (!this.idTokenKeyMatchesFilter(key, {\n        clientId: this.clientId,\n        ...filter\n      })) {\n        return;\n      }\n      const idToken = this.getIdTokenCredential(key);\n      if (idToken && this.credentialMatchesFilter(idToken, filter)) {\n        idTokens.set(key, idToken);\n      }\n    });\n    return idTokens;\n  }\n  /**\n   * Validate the cache key against filter before retrieving and parsing cache value\n   * @param key\n   * @param filter\n   * @returns\n   */\n  idTokenKeyMatchesFilter(inputKey, filter) {\n    const key = inputKey.toLowerCase();\n    if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Removes idToken from the cache\n   * @param key\n   */\n  removeIdToken(key) {\n    this.removeItem(key);\n  }\n  /**\n   * Removes refresh token from the cache\n   * @param key\n   */\n  removeRefreshToken(key) {\n    this.removeItem(key);\n  }\n  /**\n   * Retrieve AccessTokenEntity from cache\n   * @param account {AccountInfo}\n   * @param request {BaseAuthRequest}\n   * @param tokenKeys {?TokenKeys}\n   * @param performanceClient {?IPerformanceClient}\n   * @param correlationId {?string}\n   */\n  getAccessToken(account, request, tokenKeys, targetRealm, performanceClient, correlationId) {\n    this.commonLogger.trace(\"CacheManager - getAccessToken called\");\n    const scopes = ScopeSet.createSearchScopes(request.scopes);\n    const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\n    /*\n     * Distinguish between Bearer and PoP/SSH token cache types\n     * Cast to lowercase to handle \"bearer\" from ADFS\n     */\n    const credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\n    const accessTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: credentialType,\n      clientId: this.clientId,\n      realm: targetRealm || account.tenantId,\n      target: scopes,\n      tokenType: authScheme,\n      keyId: request.sshKid,\n      requestedClaimsHash: request.requestedClaimsHash\n    };\n    const accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;\n    const accessTokens = [];\n    accessTokenKeys.forEach(key => {\n      // Validate key\n      if (this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {\n        const accessToken = this.getAccessTokenCredential(key);\n        // Validate value\n        if (accessToken && this.credentialMatchesFilter(accessToken, accessTokenFilter)) {\n          accessTokens.push(accessToken);\n        }\n      }\n    });\n    const numAccessTokens = accessTokens.length;\n    if (numAccessTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getAccessToken - No token found\");\n      return null;\n    } else if (numAccessTokens > 1) {\n      this.commonLogger.info(\"CacheManager:getAccessToken - Multiple access tokens found, clearing them\");\n      accessTokens.forEach(accessToken => {\n        void this.removeAccessToken(generateCredentialKey(accessToken));\n      });\n      if (performanceClient && correlationId) {\n        performanceClient.addFields({\n          multiMatchedAT: accessTokens.length\n        }, correlationId);\n      }\n      return null;\n    }\n    this.commonLogger.info(\"CacheManager:getAccessToken - Returning access token\");\n    return accessTokens[0];\n  }\n  /**\n   * Validate the cache key against filter before retrieving and parsing cache value\n   * @param key\n   * @param filter\n   * @param keyMustContainAllScopes\n   * @returns\n   */\n  accessTokenKeyMatchesFilter(inputKey, filter, keyMustContainAllScopes) {\n    const key = inputKey.toLowerCase();\n    if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.requestedClaimsHash && key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.target) {\n      const scopes = filter.target.asArray();\n      for (let i = 0; i < scopes.length; i++) {\n        if (keyMustContainAllScopes && !key.includes(scopes[i].toLowerCase())) {\n          // When performing a cache lookup a missing scope would be a cache miss\n          return false;\n        } else if (!keyMustContainAllScopes && key.includes(scopes[i].toLowerCase())) {\n          // When performing a cache write, any token with a subset of requested scopes should be replaced\n          return true;\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Gets all access tokens matching the filter\n   * @param filter\n   * @returns\n   */\n  getAccessTokensByFilter(filter) {\n    const tokenKeys = this.getTokenKeys();\n    const accessTokens = [];\n    tokenKeys.accessToken.forEach(key => {\n      if (!this.accessTokenKeyMatchesFilter(key, filter, true)) {\n        return;\n      }\n      const accessToken = this.getAccessTokenCredential(key);\n      if (accessToken && this.credentialMatchesFilter(accessToken, filter)) {\n        accessTokens.push(accessToken);\n      }\n    });\n    return accessTokens;\n  }\n  /**\n   * Helper to retrieve the appropriate refresh token from cache\n   * @param account {AccountInfo}\n   * @param familyRT {boolean}\n   * @param tokenKeys {?TokenKeys}\n   * @param performanceClient {?IPerformanceClient}\n   * @param correlationId {?string}\n   */\n  getRefreshToken(account, familyRT, tokenKeys, performanceClient, correlationId) {\n    this.commonLogger.trace(\"CacheManager - getRefreshToken called\");\n    const id = familyRT ? THE_FAMILY_ID : undefined;\n    const refreshTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.REFRESH_TOKEN,\n      clientId: this.clientId,\n      familyId: id\n    };\n    const refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;\n    const refreshTokens = [];\n    refreshTokenKeys.forEach(key => {\n      // Validate key\n      if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {\n        const refreshToken = this.getRefreshTokenCredential(key);\n        // Validate value\n        if (refreshToken && this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {\n          refreshTokens.push(refreshToken);\n        }\n      }\n    });\n    const numRefreshTokens = refreshTokens.length;\n    if (numRefreshTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getRefreshToken - No refresh token found.\");\n      return null;\n    }\n    // address the else case after remove functions address environment aliases\n    if (numRefreshTokens > 1 && performanceClient && correlationId) {\n      performanceClient.addFields({\n        multiMatchedRT: numRefreshTokens\n      }, correlationId);\n    }\n    this.commonLogger.info(\"CacheManager:getRefreshToken - returning refresh token\");\n    return refreshTokens[0];\n  }\n  /**\n   * Validate the cache key against filter before retrieving and parsing cache value\n   * @param key\n   * @param filter\n   */\n  refreshTokenKeyMatchesFilter(inputKey, filter) {\n    const key = inputKey.toLowerCase();\n    if (filter.familyId && key.indexOf(filter.familyId.toLowerCase()) === -1) {\n      return false;\n    }\n    // If familyId is used, clientId is not in the key\n    if (!filter.familyId && filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Retrieve AppMetadataEntity from cache\n   */\n  readAppMetadataFromCache(environment) {\n    const appMetadataFilter = {\n      environment,\n      clientId: this.clientId\n    };\n    const appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);\n    const appMetadataEntries = Object.keys(appMetadata).map(key => appMetadata[key]);\n    const numAppMetadata = appMetadataEntries.length;\n    if (numAppMetadata < 1) {\n      return null;\n    } else if (numAppMetadata > 1) {\n      throw createClientAuthError(multipleMatchingAppMetadata);\n    }\n    return appMetadataEntries[0];\n  }\n  /**\n   * Return the family_id value associated  with FOCI\n   * @param environment\n   * @param clientId\n   */\n  isAppMetadataFOCI(environment) {\n    const appMetadata = this.readAppMetadataFromCache(environment);\n    return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\n  }\n  /**\n   * helper to match account ids\n   * @param value\n   * @param homeAccountId\n   */\n  matchHomeAccountId(entity, homeAccountId) {\n    return !!(typeof entity.homeAccountId === \"string\" && homeAccountId === entity.homeAccountId);\n  }\n  /**\n   * helper to match account ids\n   * @param entity\n   * @param localAccountId\n   * @returns\n   */\n  matchLocalAccountIdFromTokenClaims(tokenClaims, localAccountId) {\n    const idTokenLocalAccountId = tokenClaims.oid || tokenClaims.sub;\n    return localAccountId === idTokenLocalAccountId;\n  }\n  matchLocalAccountIdFromTenantProfile(tenantProfile, localAccountId) {\n    return tenantProfile.localAccountId === localAccountId;\n  }\n  /**\n   * helper to match names\n   * @param entity\n   * @param name\n   * @returns true if the downcased name properties are present and match in the filter and the entity\n   */\n  matchName(claims, name) {\n    return !!(name.toLowerCase() === claims.name?.toLowerCase());\n  }\n  /**\n   * helper to match usernames\n   * @param entity\n   * @param username\n   * @returns\n   */\n  matchUsername(cachedUsername, filterUsername) {\n    return !!(cachedUsername && typeof cachedUsername === \"string\" && filterUsername?.toLowerCase() === cachedUsername.toLowerCase());\n  }\n  /**\n   * helper to match assertion\n   * @param value\n   * @param oboAssertion\n   */\n  matchUserAssertionHash(entity, userAssertionHash) {\n    return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);\n  }\n  /**\n   * helper to match environment\n   * @param value\n   * @param environment\n   */\n  matchEnvironment(entity, environment) {\n    // Check static authority options first for cases where authority metadata has not been resolved and cached yet\n    if (this.staticAuthorityOptions) {\n      const staticAliases = getAliasesFromStaticSources(this.staticAuthorityOptions, this.commonLogger);\n      if (staticAliases.includes(environment) && staticAliases.includes(entity.environment)) {\n        return true;\n      }\n    }\n    // Query metadata cache if no static authority configuration has aliases that match enviroment\n    const cloudMetadata = this.getAuthorityMetadataByAlias(environment);\n    if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * helper to match credential type\n   * @param entity\n   * @param credentialType\n   */\n  matchCredentialType(entity, credentialType) {\n    return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();\n  }\n  /**\n   * helper to match client ids\n   * @param entity\n   * @param clientId\n   */\n  matchClientId(entity, clientId) {\n    return !!(entity.clientId && clientId === entity.clientId);\n  }\n  /**\n   * helper to match family ids\n   * @param entity\n   * @param familyId\n   */\n  matchFamilyId(entity, familyId) {\n    return !!(entity.familyId && familyId === entity.familyId);\n  }\n  /**\n   * helper to match realm\n   * @param entity\n   * @param realm\n   */\n  matchRealm(entity, realm) {\n    return !!(entity.realm?.toLowerCase() === realm.toLowerCase());\n  }\n  /**\n   * helper to match nativeAccountId\n   * @param entity\n   * @param nativeAccountId\n   * @returns boolean indicating the match result\n   */\n  matchNativeAccountId(entity, nativeAccountId) {\n    return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);\n  }\n  /**\n   * helper to match loginHint which can be either:\n   * 1. login_hint ID token claim\n   * 2. username in cached account object\n   * 3. upn in ID token claims\n   * @param entity\n   * @param loginHint\n   * @returns\n   */\n  matchLoginHintFromTokenClaims(tokenClaims, loginHint) {\n    if (tokenClaims.login_hint === loginHint) {\n      return true;\n    }\n    if (tokenClaims.preferred_username === loginHint) {\n      return true;\n    }\n    if (tokenClaims.upn === loginHint) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Helper to match sid\n   * @param entity\n   * @param sid\n   * @returns true if the sid claim is present and matches the filter\n   */\n  matchSid(idTokenClaims, sid) {\n    return idTokenClaims.sid === sid;\n  }\n  matchAuthorityType(entity, authorityType) {\n    return !!(entity.authorityType && authorityType.toLowerCase() === entity.authorityType.toLowerCase());\n  }\n  /**\n   * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\n   * @param entity\n   * @param target\n   */\n  matchTarget(entity, target) {\n    const isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n    if (isNotAccessTokenCredential || !entity.target) {\n      return false;\n    }\n    const entityScopeSet = ScopeSet.fromString(entity.target);\n    return entityScopeSet.containsScopeSet(target);\n  }\n  /**\n   * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\n   * @param entity\n   * @param tokenType\n   */\n  matchTokenType(entity, tokenType) {\n    return !!(entity.tokenType && entity.tokenType === tokenType);\n  }\n  /**\n   * Returns true if the credential's keyId matches the one in the request, false otherwise\n   * @param entity\n   * @param tokenType\n   */\n  matchKeyId(entity, keyId) {\n    return !!(entity.keyId && entity.keyId === keyId);\n  }\n  /**\n   * returns if a given cache entity is of the type appmetadata\n   * @param key\n   */\n  isAppMetadata(key) {\n    return key.indexOf(APP_METADATA) !== -1;\n  }\n  /**\n   * returns if a given cache entity is of the type authoritymetadata\n   * @param key\n   */\n  isAuthorityMetadata(key) {\n    return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\n  }\n  /**\n   * returns cache key used for cloud instance metadata\n   */\n  generateAuthorityMetadataCacheKey(authority) {\n    return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;\n  }\n  /**\n   * Helper to convert serialized data to object\n   * @param obj\n   * @param json\n   */\n  static toObject(obj, json) {\n    for (const propertyName in json) {\n      obj[propertyName] = json[propertyName];\n    }\n    return obj;\n  }\n}\n/** @internal */\nclass DefaultStorageClass extends CacheManager {\n  setAccount() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAccount() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getCachedAccountEntity() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setIdTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getIdTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setAccessTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAccessTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setRefreshTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getRefreshTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setAppMetadata() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAppMetadata() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setServerTelemetry() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getServerTelemetry() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setAuthorityMetadata() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAuthorityMetadata() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAuthorityMetadataKeys() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setThrottlingCache() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getThrottlingCache() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  removeItem() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  containsKey() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getKeys() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAccountKeys() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getTokenKeys() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  clear() {\n    return _asyncToGenerator(function* () {\n      throw createClientAuthError(methodNotImplemented);\n    })();\n  }\n  updateCredentialCacheKey() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  removeOutdatedAccount() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n}\nexport { CacheManager, DefaultStorageClass };\n//# sourceMappingURL=CacheManager.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}