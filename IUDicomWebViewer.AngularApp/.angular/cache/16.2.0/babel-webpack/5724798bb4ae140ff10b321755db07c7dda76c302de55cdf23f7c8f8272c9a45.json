{"ast":null,"code":"/*! @azure/msal-browser v3.6.0 2023-12-01 */\n'use strict';\n\nimport { RequestParameterBuilder, StringUtils, AuthenticationScheme, createClientAuthError, ClientAuthErrorCodes, AuthToken, AuthError, InteractionRequiredAuthError, ServerError, ClientAuthError } from '@azure/msal-common';\nimport { isBridgeError } from '../BridgeError.mjs';\nimport { BridgeStatusCode } from '../BridgeStatusCode.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass NestedAppAuthAdapter {\n  constructor(clientId, clientCapabilities, crypto, logger) {\n    this.clientId = clientId;\n    this.clientCapabilities = clientCapabilities;\n    this.crypto = crypto;\n    this.logger = logger;\n  }\n  toNaaTokenRequest(request) {\n    let extraParams;\n    if (request.extraQueryParameters === undefined) {\n      extraParams = new Map();\n    } else {\n      extraParams = new Map(Object.entries(request.extraQueryParameters));\n    }\n    const requestBuilder = new RequestParameterBuilder();\n    const claims = requestBuilder.addClientCapabilitiesToClaims(request.claims, this.clientCapabilities);\n    const tokenRequest = {\n      userObjectId: request.account?.homeAccountId,\n      clientId: this.clientId,\n      authority: request.authority,\n      scope: request.scopes.join(\" \"),\n      correlationId: request.correlationId !== undefined ? request.correlationId : this.crypto.createNewGuid(),\n      nonce: request.nonce,\n      claims: !StringUtils.isEmptyObj(claims) ? claims : undefined,\n      state: request.state,\n      authenticationScheme: request.authenticationScheme || AuthenticationScheme.BEARER,\n      extraParameters: extraParams\n    };\n    return tokenRequest;\n  }\n  fromNaaTokenResponse(request, response, reqTimestamp) {\n    if (!response.id_token || !response.access_token) {\n      throw createClientAuthError(ClientAuthErrorCodes.nullOrEmptyToken);\n    }\n    const expiresOn = new Date((reqTimestamp + (response.expires_in || 0)) * 1000);\n    const idTokenClaims = AuthToken.extractTokenClaims(response.id_token, this.crypto.base64Decode);\n    const account = this.fromNaaAccountInfo(response.account, idTokenClaims);\n    const authenticationResult = {\n      authority: response.authority || account.environment,\n      uniqueId: account.localAccountId,\n      tenantId: account.tenantId,\n      scopes: response.scope.split(\" \"),\n      account,\n      idToken: response.id_token !== undefined ? response.id_token : \"\",\n      idTokenClaims,\n      accessToken: response.access_token,\n      fromCache: true,\n      expiresOn: expiresOn,\n      tokenType: request.authenticationScheme || AuthenticationScheme.BEARER,\n      correlationId: request.correlationId,\n      extExpiresOn: expiresOn,\n      state: request.state\n    };\n    return authenticationResult;\n  }\n  /*\n   *  export type AccountInfo = {\n   *     homeAccountId: string;\n   *     environment: string;\n   *     tenantId: string;\n   *     username: string;\n   *     localAccountId: string;\n   *     name?: string;\n   *     idToken?: string;\n   *     idTokenClaims?: TokenClaims & {\n   *         [key: string]:\n   *             | string\n   *             | number\n   *             | string[]\n   *             | object\n   *             | undefined\n   *             | unknown;\n   *     };\n   *     nativeAccountId?: string;\n   *     authorityType?: string;\n   * };\n   */\n  fromNaaAccountInfo(fromAccount, idTokenClaims) {\n    const effectiveIdTokenClaims = idTokenClaims || fromAccount.idTokenClaims;\n    const localAccountId = fromAccount.localAccountId || effectiveIdTokenClaims?.oid || effectiveIdTokenClaims?.sub || \"\";\n    const tenantId = fromAccount.tenantId || effectiveIdTokenClaims?.tid || \"\";\n    const homeAccountId = fromAccount.homeAccountId || `${localAccountId}.${tenantId}`;\n    const username = fromAccount.username || effectiveIdTokenClaims?.preferred_username || \"\";\n    const name = fromAccount.name || effectiveIdTokenClaims?.name;\n    const account = {\n      homeAccountId,\n      environment: fromAccount.environment,\n      tenantId,\n      username,\n      localAccountId,\n      name,\n      idToken: fromAccount.idToken,\n      idTokenClaims: effectiveIdTokenClaims\n    };\n    return account;\n  }\n  /**\n   *\n   * @param error BridgeError\n   * @returns AuthError, ClientAuthError, ClientConfigurationError, ServerError, InteractionRequiredError\n   */\n  fromBridgeError(error) {\n    if (isBridgeError(error)) {\n      switch (error.status) {\n        case BridgeStatusCode.USER_CANCEL:\n          return new ClientAuthError(ClientAuthErrorCodes.userCanceled);\n        case BridgeStatusCode.NO_NETWORK:\n          return new ClientAuthError(ClientAuthErrorCodes.noNetworkConnectivity);\n        case BridgeStatusCode.ACCOUNT_UNAVAILABLE:\n          return new ClientAuthError(ClientAuthErrorCodes.noAccountFound);\n        case BridgeStatusCode.DISABLED:\n          return new ClientAuthError(ClientAuthErrorCodes.nestedAppAuthBridgeDisabled);\n        case BridgeStatusCode.NESTED_APP_AUTH_UNAVAILABLE:\n          return new ClientAuthError(error.code || ClientAuthErrorCodes.nestedAppAuthBridgeDisabled, error.description);\n        case BridgeStatusCode.TRANSIENT_ERROR:\n        case BridgeStatusCode.PERSISTENT_ERROR:\n          return new ServerError(error.code, error.description);\n        case BridgeStatusCode.USER_INTERACTION_REQUIRED:\n          return new InteractionRequiredAuthError(error.code, error.description);\n        default:\n          return new AuthError(error.code, error.description);\n      }\n    } else {\n      return new AuthError(\"unknown_error\", \"An unknown error occurred\");\n    }\n  }\n}\nexport { NestedAppAuthAdapter };\n//# sourceMappingURL=NestedAppAuthAdapter.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}