{"ast":null,"code":"const Utils = require(\"./util\");\nconst pth = require(\"path\");\nconst ZipEntry = require(\"./zipEntry\");\nconst ZipFile = require(\"./zipFile\");\nconst get_Bool = (val, def) => typeof val === \"boolean\" ? val : def;\nconst get_Str = (val, def) => typeof val === \"string\" ? val : def;\nconst defaultOptions = {\n  // option \"noSort\" : if true it disables files sorting\n  noSort: false,\n  // read entries during load (initial loading may be slower)\n  readEntries: false,\n  // default method is none\n  method: Utils.Constants.NONE,\n  // file system\n  fs: null\n};\nmodule.exports = function ( /**String*/input, /** object */options) {\n  let inBuffer = null;\n\n  // create object based default options, allowing them to be overwritten\n  const opts = Object.assign(Object.create(null), defaultOptions);\n\n  // test input variable\n  if (input && \"object\" === typeof input) {\n    // if value is not buffer we accept it to be object with options\n    if (!(input instanceof Uint8Array)) {\n      Object.assign(opts, input);\n      input = opts.input ? opts.input : undefined;\n      if (opts.input) delete opts.input;\n    }\n\n    // if input is buffer\n    if (Buffer.isBuffer(input)) {\n      inBuffer = input;\n      opts.method = Utils.Constants.BUFFER;\n      input = undefined;\n    }\n  }\n\n  // assign options\n  Object.assign(opts, options);\n\n  // instanciate utils filesystem\n  const filetools = new Utils(opts);\n\n  // if input is file name we retrieve its content\n  if (input && \"string\" === typeof input) {\n    // load zip file\n    if (filetools.fs.existsSync(input)) {\n      opts.method = Utils.Constants.FILE;\n      opts.filename = input;\n      inBuffer = filetools.fs.readFileSync(input);\n    } else {\n      throw new Error(Utils.Errors.INVALID_FILENAME);\n    }\n  }\n\n  // create variable\n  const _zip = new ZipFile(inBuffer, opts);\n  const {\n    canonical,\n    sanitize\n  } = Utils;\n  function getEntry( /**Object*/entry) {\n    if (entry && _zip) {\n      var item;\n      // If entry was given as a file name\n      if (typeof entry === \"string\") item = _zip.getEntry(entry);\n      // if entry was given as a ZipEntry object\n      if (typeof entry === \"object\" && typeof entry.entryName !== \"undefined\" && typeof entry.header !== \"undefined\") item = _zip.getEntry(entry.entryName);\n      if (item) {\n        return item;\n      }\n    }\n    return null;\n  }\n  function fixPath(zipPath) {\n    const {\n      join,\n      normalize,\n      sep\n    } = pth.posix;\n    // convert windows file separators and normalize\n    return join(\".\", normalize(sep + zipPath.split(\"\\\\\").join(sep) + sep));\n  }\n  return {\n    /**\n     * Extracts the given entry from the archive and returns the content as a Buffer object\n     * @param entry ZipEntry object or String with the full path of the entry\n     *\n     * @return Buffer or Null in case of error\n     */\n    readFile: function ( /**Object*/entry, /*String, Buffer*/pass) {\n      var item = getEntry(entry);\n      return item && item.getData(pass) || null;\n    },\n    /**\n     * Asynchronous readFile\n     * @param entry ZipEntry object or String with the full path of the entry\n     * @param callback\n     *\n     * @return Buffer or Null in case of error\n     */\n    readFileAsync: function ( /**Object*/entry, /**Function*/callback) {\n      var item = getEntry(entry);\n      if (item) {\n        item.getDataAsync(callback);\n      } else {\n        callback(null, \"getEntry failed for:\" + entry);\n      }\n    },\n    /**\n     * Extracts the given entry from the archive and returns the content as plain text in the given encoding\n     * @param entry ZipEntry object or String with the full path of the entry\n     * @param encoding Optional. If no encoding is specified utf8 is used\n     *\n     * @return String\n     */\n    readAsText: function ( /**Object*/entry, /**String=*/encoding) {\n      var item = getEntry(entry);\n      if (item) {\n        var data = item.getData();\n        if (data && data.length) {\n          return data.toString(encoding || \"utf8\");\n        }\n      }\n      return \"\";\n    },\n    /**\n     * Asynchronous readAsText\n     * @param entry ZipEntry object or String with the full path of the entry\n     * @param callback\n     * @param encoding Optional. If no encoding is specified utf8 is used\n     *\n     * @return String\n     */\n    readAsTextAsync: function ( /**Object*/entry, /**Function*/callback, /**String=*/encoding) {\n      var item = getEntry(entry);\n      if (item) {\n        item.getDataAsync(function (data, err) {\n          if (err) {\n            callback(data, err);\n            return;\n          }\n          if (data && data.length) {\n            callback(data.toString(encoding || \"utf8\"));\n          } else {\n            callback(\"\");\n          }\n        });\n      } else {\n        callback(\"\");\n      }\n    },\n    /**\n     * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory\n     *\n     * @param entry\n     */\n    deleteFile: function ( /**Object*/entry) {\n      // @TODO: test deleteFile\n      var item = getEntry(entry);\n      if (item) {\n        _zip.deleteEntry(item.entryName);\n      }\n    },\n    /**\n     * Adds a comment to the zip. The zip must be rewritten after adding the comment.\n     *\n     * @param comment\n     */\n    addZipComment: function ( /**String*/comment) {\n      // @TODO: test addZipComment\n      _zip.comment = comment;\n    },\n    /**\n     * Returns the zip comment\n     *\n     * @return String\n     */\n    getZipComment: function () {\n      return _zip.comment || \"\";\n    },\n    /**\n     * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment\n     * The comment cannot exceed 65535 characters in length\n     *\n     * @param entry\n     * @param comment\n     */\n    addZipEntryComment: function ( /**Object*/entry, /**String*/comment) {\n      var item = getEntry(entry);\n      if (item) {\n        item.comment = comment;\n      }\n    },\n    /**\n     * Returns the comment of the specified entry\n     *\n     * @param entry\n     * @return String\n     */\n    getZipEntryComment: function ( /**Object*/entry) {\n      var item = getEntry(entry);\n      if (item) {\n        return item.comment || \"\";\n      }\n      return \"\";\n    },\n    /**\n     * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content\n     *\n     * @param entry\n     * @param content\n     */\n    updateFile: function ( /**Object*/entry, /**Buffer*/content) {\n      var item = getEntry(entry);\n      if (item) {\n        item.setData(content);\n      }\n    },\n    /**\n     * Adds a file from the disk to the archive\n     *\n     * @param localPath File to add to zip\n     * @param zipPath Optional path inside the zip\n     * @param zipName Optional name for the file\n     */\n    addLocalFile: function ( /**String*/localPath, /**String=*/zipPath, /**String=*/zipName, /**String*/comment) {\n      if (filetools.fs.existsSync(localPath)) {\n        // fix ZipPath\n        zipPath = zipPath ? fixPath(zipPath) : \"\";\n\n        // p - local file name\n        var p = localPath.split(\"\\\\\").join(\"/\").split(\"/\").pop();\n\n        // add file name into zippath\n        zipPath += zipName ? zipName : p;\n\n        // read file attributes\n        const _attr = filetools.fs.statSync(localPath);\n\n        // add file into zip file\n        this.addFile(zipPath, filetools.fs.readFileSync(localPath), comment, _attr);\n      } else {\n        throw new Error(Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n      }\n    },\n    /**\n     * Adds a local directory and all its nested files and directories to the archive\n     *\n     * @param localPath\n     * @param zipPath optional path inside zip\n     * @param filter optional RegExp or Function if files match will\n     *               be included.\n     * @param {number | object} attr - number as unix file permissions, object as filesystem Stats object\n     */\n    addLocalFolder: function ( /**String*/localPath, /**String=*/zipPath, /**=RegExp|Function*/filter, /**=number|object*/attr) {\n      // Prepare filter\n      if (filter instanceof RegExp) {\n        // if filter is RegExp wrap it\n        filter = function (rx) {\n          return function (filename) {\n            return rx.test(filename);\n          };\n        }(filter);\n      } else if (\"function\" !== typeof filter) {\n        // if filter is not function we will replace it\n        filter = function () {\n          return true;\n        };\n      }\n\n      // fix ZipPath\n      zipPath = zipPath ? fixPath(zipPath) : \"\";\n\n      // normalize the path first\n      localPath = pth.normalize(localPath);\n      if (filetools.fs.existsSync(localPath)) {\n        const items = filetools.findFiles(localPath);\n        const self = this;\n        if (items.length) {\n          items.forEach(function (filepath) {\n            var p = pth.relative(localPath, filepath).split(\"\\\\\").join(\"/\"); //windows fix\n            if (filter(p)) {\n              var stats = filetools.fs.statSync(filepath);\n              if (stats.isFile()) {\n                self.addFile(zipPath + p, filetools.fs.readFileSync(filepath), \"\", attr ? attr : stats);\n              } else {\n                self.addFile(zipPath + p + \"/\", Buffer.alloc(0), \"\", attr ? attr : stats);\n              }\n            }\n          });\n        }\n      } else {\n        throw new Error(Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n      }\n    },\n    /**\n     * Asynchronous addLocalFile\n     * @param localPath\n     * @param callback\n     * @param zipPath optional path inside zip\n     * @param filter optional RegExp or Function if files match will\n     *               be included.\n     */\n    addLocalFolderAsync: function ( /*String*/localPath, /*Function*/callback, /*String*/zipPath, /*RegExp|Function*/filter) {\n      if (filter instanceof RegExp) {\n        filter = function (rx) {\n          return function (filename) {\n            return rx.test(filename);\n          };\n        }(filter);\n      } else if (\"function\" !== typeof filter) {\n        filter = function () {\n          return true;\n        };\n      }\n\n      // fix ZipPath\n      zipPath = zipPath ? fixPath(zipPath) : \"\";\n\n      // normalize the path first\n      localPath = pth.normalize(localPath);\n      var self = this;\n      filetools.fs.open(localPath, \"r\", function (err) {\n        if (err && err.code === \"ENOENT\") {\n          callback(undefined, Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n        } else if (err) {\n          callback(undefined, err);\n        } else {\n          var items = filetools.findFiles(localPath);\n          var i = -1;\n          var next = function () {\n            i += 1;\n            if (i < items.length) {\n              var filepath = items[i];\n              var p = pth.relative(localPath, filepath).split(\"\\\\\").join(\"/\"); //windows fix\n              p = p.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\").replace(/[^\\x20-\\x7E]/g, \"\"); // accent fix\n              if (filter(p)) {\n                filetools.fs.stat(filepath, function (er0, stats) {\n                  if (er0) callback(undefined, er0);\n                  if (stats.isFile()) {\n                    filetools.fs.readFile(filepath, function (er1, data) {\n                      if (er1) {\n                        callback(undefined, er1);\n                      } else {\n                        self.addFile(zipPath + p, data, \"\", stats);\n                        next();\n                      }\n                    });\n                  } else {\n                    self.addFile(zipPath + p + \"/\", Buffer.alloc(0), \"\", stats);\n                    next();\n                  }\n                });\n              } else {\n                process.nextTick(() => {\n                  next();\n                });\n              }\n            } else {\n              callback(true, undefined);\n            }\n          };\n          next();\n        }\n      });\n    },\n    /**\n     *\n     * @param {string} localPath - path where files will be extracted\n     * @param {object} props - optional properties\n     * @param {string} props.zipPath - optional path inside zip\n     * @param {regexp, function} props.filter - RegExp or Function if files match will be included.\n     */\n    addLocalFolderPromise: function ( /*String*/localPath, /* object */props) {\n      return new Promise((resolve, reject) => {\n        const {\n          filter,\n          zipPath\n        } = Object.assign({}, props);\n        this.addLocalFolderAsync(localPath, (done, err) => {\n          if (err) reject(err);\n          if (done) resolve(this);\n        }, zipPath, filter);\n      });\n    },\n    /**\n     * Allows you to create a entry (file or directory) in the zip file.\n     * If you want to create a directory the entryName must end in / and a null buffer should be provided.\n     * Comment and attributes are optional\n     *\n     * @param {string} entryName\n     * @param {Buffer | string} content - file content as buffer or utf8 coded string\n     * @param {string} comment - file comment\n     * @param {number | object} attr - number as unix file permissions, object as filesystem Stats object\n     */\n    addFile: function ( /**String*/entryName, /**Buffer*/content, /**String*/comment, /**Number*/attr) {\n      let entry = getEntry(entryName);\n      const update = entry != null;\n\n      // prepare new entry\n      if (!update) {\n        entry = new ZipEntry();\n        entry.entryName = entryName;\n      }\n      entry.comment = comment || \"\";\n      const isStat = \"object\" === typeof attr && attr instanceof filetools.fs.Stats;\n\n      // last modification time from file stats\n      if (isStat) {\n        entry.header.time = attr.mtime;\n      }\n\n      // Set file attribute\n      var fileattr = entry.isDirectory ? 0x10 : 0; // (MS-DOS directory flag)\n\n      // extended attributes field for Unix\n      // set file type either S_IFDIR / S_IFREG\n      let unix = entry.isDirectory ? 0x4000 : 0x8000;\n      if (isStat) {\n        // File attributes from file stats\n        unix |= 0xfff & attr.mode;\n      } else if (\"number\" === typeof attr) {\n        // attr from given attr values\n        unix |= 0xfff & attr;\n      } else {\n        // Default values:\n        unix |= entry.isDirectory ? 0o755 : 0o644; // permissions (drwxr-xr-x) or (-r-wr--r--)\n      }\n\n      fileattr = (fileattr | unix << 16) >>> 0; // add attributes\n\n      entry.attr = fileattr;\n      entry.setData(content);\n      if (!update) _zip.setEntry(entry);\n    },\n    /**\n     * Returns an array of ZipEntry objects representing the files and folders inside the archive\n     *\n     * @return Array\n     */\n    getEntries: function () {\n      return _zip ? _zip.entries : [];\n    },\n    /**\n     * Returns a ZipEntry object representing the file or folder specified by ``name``.\n     *\n     * @param name\n     * @return ZipEntry\n     */\n    getEntry: function ( /**String*/name) {\n      return getEntry(name);\n    },\n    getEntryCount: function () {\n      return _zip.getEntryCount();\n    },\n    forEach: function (callback) {\n      return _zip.forEach(callback);\n    },\n    /**\n     * Extracts the given entry to the given targetPath\n     * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted\n     *\n     * @param entry ZipEntry object or String with the full path of the entry\n     * @param targetPath Target folder where to write the file\n     * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder\n     *                          will be created in targetPath as well. Default is TRUE\n     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\n     *                  Default is FALSE\n     * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.\n     *                  Default is FALSE\n     * @param outFileName String If set will override the filename of the extracted file (Only works if the entry is a file)\n     *\n     * @return Boolean\n     */\n    extractEntryTo: function ( /**Object*/entry, /**String*/targetPath, /**Boolean*/maintainEntryPath, /**Boolean*/overwrite, /**Boolean*/keepOriginalPermission, /**String**/outFileName) {\n      overwrite = get_Bool(overwrite, false);\n      keepOriginalPermission = get_Bool(keepOriginalPermission, false);\n      maintainEntryPath = get_Bool(maintainEntryPath, true);\n      outFileName = get_Str(outFileName, get_Str(keepOriginalPermission, undefined));\n      var item = getEntry(entry);\n      if (!item) {\n        throw new Error(Utils.Errors.NO_ENTRY);\n      }\n      var entryName = canonical(item.entryName);\n      var target = sanitize(targetPath, outFileName && !item.isDirectory ? outFileName : maintainEntryPath ? entryName : pth.basename(entryName));\n      if (item.isDirectory) {\n        var children = _zip.getEntryChildren(item);\n        children.forEach(function (child) {\n          if (child.isDirectory) return;\n          var content = child.getData();\n          if (!content) {\n            throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n          }\n          var name = canonical(child.entryName);\n          var childName = sanitize(targetPath, maintainEntryPath ? name : pth.basename(name));\n          // The reverse operation for attr depend on method addFile()\n          const fileAttr = keepOriginalPermission ? child.header.fileAttr : undefined;\n          filetools.writeFileTo(childName, content, overwrite, fileAttr);\n        });\n        return true;\n      }\n      var content = item.getData();\n      if (!content) throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n      if (filetools.fs.existsSync(target) && !overwrite) {\n        throw new Error(Utils.Errors.CANT_OVERRIDE);\n      }\n      // The reverse operation for attr depend on method addFile()\n      const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n      filetools.writeFileTo(target, content, overwrite, fileAttr);\n      return true;\n    },\n    /**\n     * Test the archive\n     *\n     */\n    test: function (pass) {\n      if (!_zip) {\n        return false;\n      }\n      for (var entry in _zip.entries) {\n        try {\n          if (entry.isDirectory) {\n            continue;\n          }\n          var content = _zip.entries[entry].getData(pass);\n          if (!content) {\n            return false;\n          }\n        } catch (err) {\n          return false;\n        }\n      }\n      return true;\n    },\n    /**\n     * Extracts the entire archive to the given location\n     *\n     * @param targetPath Target location\n     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\n     *                  Default is FALSE\n     * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.\n     *                  Default is FALSE\n     */\n    extractAllTo: function ( /**String*/targetPath, /**Boolean*/overwrite, /**Boolean*/keepOriginalPermission, /*String, Buffer*/pass) {\n      overwrite = get_Bool(overwrite, false);\n      pass = get_Str(keepOriginalPermission, pass);\n      keepOriginalPermission = get_Bool(keepOriginalPermission, false);\n      if (!_zip) {\n        throw new Error(Utils.Errors.NO_ZIP);\n      }\n      _zip.entries.forEach(function (entry) {\n        var entryName = sanitize(targetPath, canonical(entry.entryName.toString()));\n        if (entry.isDirectory) {\n          filetools.makeDir(entryName);\n          return;\n        }\n        var content = entry.getData(pass);\n        if (!content) {\n          throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n        }\n        // The reverse operation for attr depend on method addFile()\n        const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n        filetools.writeFileTo(entryName, content, overwrite, fileAttr);\n        try {\n          filetools.fs.utimesSync(entryName, entry.header.time, entry.header.time);\n        } catch (err) {\n          throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n        }\n      });\n    },\n    /**\n     * Asynchronous extractAllTo\n     *\n     * @param targetPath Target location\n     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\n     *                  Default is FALSE\n     * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.\n     *                  Default is FALSE\n     * @param callback The callback will be executed when all entries are extracted successfully or any error is thrown.\n     */\n    extractAllToAsync: function ( /**String*/targetPath, /**Boolean*/overwrite, /**Boolean*/keepOriginalPermission, /**Function*/callback) {\n      overwrite = get_Bool(overwrite, false);\n      if (typeof keepOriginalPermission === \"function\" && !callback) callback = keepOriginalPermission;\n      keepOriginalPermission = get_Bool(keepOriginalPermission, false);\n      if (!callback) {\n        callback = function (err) {\n          throw new Error(err);\n        };\n      }\n      if (!_zip) {\n        callback(new Error(Utils.Errors.NO_ZIP));\n        return;\n      }\n      targetPath = pth.resolve(targetPath);\n      // convert entryName to\n      const getPath = entry => sanitize(targetPath, pth.normalize(canonical(entry.entryName.toString())));\n      const getError = (msg, file) => new Error(msg + ': \"' + file + '\"');\n\n      // separate directories from files\n      const dirEntries = [];\n      const fileEntries = new Set();\n      _zip.entries.forEach(e => {\n        if (e.isDirectory) {\n          dirEntries.push(e);\n        } else {\n          fileEntries.add(e);\n        }\n      });\n\n      // Create directory entries first synchronously\n      // this prevents race condition and assures folders are there before writing files\n      for (const entry of dirEntries) {\n        const dirPath = getPath(entry);\n        // The reverse operation for attr depend on method addFile()\n        const dirAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n        try {\n          filetools.makeDir(dirPath);\n          if (dirAttr) filetools.fs.chmodSync(dirPath, dirAttr);\n          // in unix timestamp will change if files are later added to folder, but still\n          filetools.fs.utimesSync(dirPath, entry.header.time, entry.header.time);\n        } catch (er) {\n          callback(getError(\"Unable to create folder\", dirPath));\n        }\n      }\n\n      // callback wrapper, for some house keeping\n      const done = () => {\n        if (fileEntries.size === 0) {\n          callback();\n        }\n      };\n\n      // Extract file entries asynchronously\n      for (const entry of fileEntries.values()) {\n        const entryName = pth.normalize(canonical(entry.entryName.toString()));\n        const filePath = sanitize(targetPath, entryName);\n        entry.getDataAsync(function (content, err_1) {\n          if (err_1) {\n            callback(new Error(err_1));\n            return;\n          }\n          if (!content) {\n            callback(new Error(Utils.Errors.CANT_EXTRACT_FILE));\n          } else {\n            // The reverse operation for attr depend on method addFile()\n            const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n            filetools.writeFileToAsync(filePath, content, overwrite, fileAttr, function (succ) {\n              if (!succ) {\n                callback(getError(\"Unable to write file\", filePath));\n                return;\n              }\n              filetools.fs.utimes(filePath, entry.header.time, entry.header.time, function (err_2) {\n                if (err_2) {\n                  callback(getError(\"Unable to set times\", filePath));\n                  return;\n                }\n                fileEntries.delete(entry);\n                // call the callback if it was last entry\n                done();\n              });\n            });\n          }\n        });\n      }\n      // call the callback if fileEntries was empty\n      done();\n    },\n    /**\n     * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip\n     *\n     * @param targetFileName\n     * @param callback\n     */\n    writeZip: function ( /**String*/targetFileName, /**Function*/callback) {\n      if (arguments.length === 1) {\n        if (typeof targetFileName === \"function\") {\n          callback = targetFileName;\n          targetFileName = \"\";\n        }\n      }\n      if (!targetFileName && opts.filename) {\n        targetFileName = opts.filename;\n      }\n      if (!targetFileName) return;\n      var zipData = _zip.compressToBuffer();\n      if (zipData) {\n        var ok = filetools.writeFileTo(targetFileName, zipData, true);\n        if (typeof callback === \"function\") callback(!ok ? new Error(\"failed\") : null, \"\");\n      }\n    },\n    writeZipPromise: function ( /**String*/targetFileName, /* object */props) {\n      const {\n        overwrite,\n        perm\n      } = Object.assign({\n        overwrite: true\n      }, props);\n      return new Promise((resolve, reject) => {\n        // find file name\n        if (!targetFileName && opts.filename) targetFileName = opts.filename;\n        if (!targetFileName) reject(\"ADM-ZIP: ZIP File Name Missing\");\n        this.toBufferPromise().then(zipData => {\n          const ret = done => done ? resolve(done) : reject(\"ADM-ZIP: Wasn't able to write zip file\");\n          filetools.writeFileToAsync(targetFileName, zipData, overwrite, perm, ret);\n        }, reject);\n      });\n    },\n    toBufferPromise: function () {\n      return new Promise((resolve, reject) => {\n        _zip.toAsyncBuffer(resolve, reject);\n      });\n    },\n    /**\n     * Returns the content of the entire zip file as a Buffer object\n     *\n     * @return Buffer\n     */\n    toBuffer: function ( /**Function=*/onSuccess, /**Function=*/onFail, /**Function=*/onItemStart, /**Function=*/onItemEnd) {\n      this.valueOf = 2;\n      if (typeof onSuccess === \"function\") {\n        _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);\n        return null;\n      }\n      return _zip.compressToBuffer();\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}