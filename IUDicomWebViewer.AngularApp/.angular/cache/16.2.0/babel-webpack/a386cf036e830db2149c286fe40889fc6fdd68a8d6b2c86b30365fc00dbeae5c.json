{"ast":null,"code":"import _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { initHttpOperation, pollHttpOperation } from \"../../http/operation\";\nimport { logger } from \"../../logger\";\nconst createStateProxy = () => ({\n  initState: config => ({\n    config,\n    isStarted: true\n  }),\n  setCanceled: state => state.isCancelled = true,\n  setError: (state, error) => state.error = error,\n  setResult: (state, result) => state.result = result,\n  setRunning: state => state.isStarted = true,\n  setSucceeded: state => state.isCompleted = true,\n  setFailed: () => {\n    /** empty body */\n  },\n  getError: state => state.error,\n  getResult: state => state.result,\n  isCanceled: state => !!state.isCancelled,\n  isFailed: state => !!state.error,\n  isRunning: state => !!state.isStarted,\n  isSucceeded: state => Boolean(state.isCompleted && !state.isCancelled && !state.error)\n});\nexport class GenericPollOperation {\n  constructor(state, lro, setErrorAsResult, lroResourceLocationConfig, processResult, updateState, isDone) {\n    this.state = state;\n    this.lro = lro;\n    this.setErrorAsResult = setErrorAsResult;\n    this.lroResourceLocationConfig = lroResourceLocationConfig;\n    this.processResult = processResult;\n    this.updateState = updateState;\n    this.isDone = isDone;\n  }\n  setPollerConfig(pollerConfig) {\n    this.pollerConfig = pollerConfig;\n  }\n  update(options) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      const stateProxy = createStateProxy();\n      if (!_this.state.isStarted) {\n        _this.state = Object.assign(Object.assign({}, _this.state), yield initHttpOperation({\n          lro: _this.lro,\n          stateProxy,\n          resourceLocationConfig: _this.lroResourceLocationConfig,\n          processResult: _this.processResult,\n          setErrorAsResult: _this.setErrorAsResult\n        }));\n      }\n      const updateState = _this.updateState;\n      const isDone = _this.isDone;\n      if (!_this.state.isCompleted && _this.state.error === undefined) {\n        yield pollHttpOperation({\n          lro: _this.lro,\n          state: _this.state,\n          stateProxy,\n          processResult: _this.processResult,\n          updateState: updateState ? (state, {\n            rawResponse\n          }) => updateState(state, rawResponse) : undefined,\n          isDone: isDone ? ({\n            flatResponse\n          }, state) => isDone(flatResponse, state) : undefined,\n          options,\n          setDelay: intervalInMs => {\n            _this.pollerConfig.intervalInMs = intervalInMs;\n          },\n          setErrorAsResult: _this.setErrorAsResult\n        });\n      }\n      (_a = options === null || options === void 0 ? void 0 : options.fireProgress) === null || _a === void 0 ? void 0 : _a.call(options, _this.state);\n      return _this;\n    })();\n  }\n  cancel() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      logger.error(\"`cancelOperation` is deprecated because it wasn't implemented\");\n      return _this2;\n    })();\n  }\n  /**\n   * Serializes the Poller operation.\n   */\n  toString() {\n    return JSON.stringify({\n      state: this.state\n    });\n  }\n}\n//# sourceMappingURL=operation.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}