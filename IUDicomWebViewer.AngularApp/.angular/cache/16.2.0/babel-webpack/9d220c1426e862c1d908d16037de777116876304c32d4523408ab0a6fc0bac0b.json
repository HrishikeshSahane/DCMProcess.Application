{"ast":null,"code":"import _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { ServiceClient } from \"@azure/core-client\";\nimport { isNode } from \"@azure/core-util\";\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { AbortController } from \"@azure/abort-controller\";\nimport { AuthenticationError, AuthenticationErrorName } from \"../errors\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint\";\nimport { DefaultAuthorityHost, SDK_VERSION } from \"../constants\";\nimport { tracingClient } from \"../util/tracing\";\nimport { logger } from \"../util/logging\";\nimport { parseExpirationTimestamp } from \"../credentials/managedIdentityCredential/utils\";\nconst noCorrelationId = \"noCorrelationId\";\n/**\n * @internal\n */\nexport function getIdentityClientAuthorityHost(options) {\n  // The authorityHost can come from options or from the AZURE_AUTHORITY_HOST environment variable.\n  let authorityHost = options === null || options === void 0 ? void 0 : options.authorityHost;\n  // The AZURE_AUTHORITY_HOST environment variable can only be provided in Node.js.\n  if (isNode) {\n    authorityHost = authorityHost !== null && authorityHost !== void 0 ? authorityHost : process.env.AZURE_AUTHORITY_HOST;\n  }\n  // If the authorityHost is not provided, we use the default one from the public cloud: https://login.microsoftonline.com\n  return authorityHost !== null && authorityHost !== void 0 ? authorityHost : DefaultAuthorityHost;\n}\n/**\n * The network module used by the Identity credentials.\n *\n * It allows for credentials to abort any pending request independently of the MSAL flow,\n * by calling to the `abortRequests()` method.\n *\n */\nexport class IdentityClient extends ServiceClient {\n  constructor(options) {\n    var _a, _b;\n    const packageDetails = `azsdk-js-identity/${SDK_VERSION}`;\n    const userAgentPrefix = ((_a = options === null || options === void 0 ? void 0 : options.userAgentOptions) === null || _a === void 0 ? void 0 : _a.userAgentPrefix) ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;\n    const baseUri = getIdentityClientAuthorityHost(options);\n    if (!baseUri.startsWith(\"https:\")) {\n      throw new Error(\"The authorityHost address must use the 'https' protocol.\");\n    }\n    super(Object.assign(Object.assign({\n      requestContentType: \"application/json; charset=utf-8\",\n      retryOptions: {\n        maxRetries: 3\n      }\n    }, options), {\n      userAgentOptions: {\n        userAgentPrefix\n      },\n      baseUri\n    }));\n    this.authorityHost = baseUri;\n    this.abortControllers = new Map();\n    this.allowLoggingAccountIdentifiers = (_b = options === null || options === void 0 ? void 0 : options.loggingOptions) === null || _b === void 0 ? void 0 : _b.allowLoggingAccountIdentifiers;\n    // used for WorkloadIdentity\n    this.tokenCredentialOptions = Object.assign({}, options);\n  }\n  sendTokenRequest(request) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      logger.info(`IdentityClient: sending token request to [${request.url}]`);\n      const response = yield _this.sendRequest(request);\n      if (response.bodyAsText && (response.status === 200 || response.status === 201)) {\n        const parsedBody = JSON.parse(response.bodyAsText);\n        if (!parsedBody.access_token) {\n          return null;\n        }\n        _this.logIdentifiers(response);\n        const token = {\n          accessToken: {\n            token: parsedBody.access_token,\n            expiresOnTimestamp: parseExpirationTimestamp(parsedBody)\n          },\n          refreshToken: parsedBody.refresh_token\n        };\n        logger.info(`IdentityClient: [${request.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);\n        return token;\n      } else {\n        const error = new AuthenticationError(response.status, response.bodyAsText);\n        logger.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);\n        throw error;\n      }\n    })();\n  }\n  refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, options = {}) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (refreshToken === undefined) {\n        return null;\n      }\n      logger.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);\n      const refreshParams = {\n        grant_type: \"refresh_token\",\n        client_id: clientId,\n        refresh_token: refreshToken,\n        scope: scopes\n      };\n      if (clientSecret !== undefined) {\n        refreshParams.client_secret = clientSecret;\n      }\n      const query = new URLSearchParams(refreshParams);\n      return tracingClient.withSpan(\"IdentityClient.refreshAccessToken\", options, /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (updatedOptions) {\n          try {\n            const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);\n            const request = createPipelineRequest({\n              url: `${_this2.authorityHost}/${tenantId}/${urlSuffix}`,\n              method: \"POST\",\n              body: query.toString(),\n              abortSignal: options.abortSignal,\n              headers: createHttpHeaders({\n                Accept: \"application/json\",\n                \"Content-Type\": \"application/x-www-form-urlencoded\"\n              }),\n              tracingOptions: updatedOptions.tracingOptions\n            });\n            const response = yield _this2.sendTokenRequest(request);\n            logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);\n            return response;\n          } catch (err) {\n            if (err.name === AuthenticationErrorName && err.errorResponse.error === \"interaction_required\") {\n              // It's likely that the refresh token has expired, so\n              // return null so that the credential implementation will\n              // initiate the authentication flow again.\n              logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);\n              return null;\n            } else {\n              logger.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);\n              throw err;\n            }\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n  // Here is a custom layer that allows us to abort requests that go through MSAL,\n  // since MSAL doesn't allow us to pass options all the way through.\n  generateAbortSignal(correlationId) {\n    const controller = new AbortController();\n    const controllers = this.abortControllers.get(correlationId) || [];\n    controllers.push(controller);\n    this.abortControllers.set(correlationId, controllers);\n    const existingOnAbort = controller.signal.onabort;\n    controller.signal.onabort = (...params) => {\n      this.abortControllers.set(correlationId, undefined);\n      if (existingOnAbort) {\n        existingOnAbort(...params);\n      }\n    };\n    return controller.signal;\n  }\n  abortRequests(correlationId) {\n    const key = correlationId || noCorrelationId;\n    const controllers = [...(this.abortControllers.get(key) || []),\n    // MSAL passes no correlation ID to the get requests...\n    ...(this.abortControllers.get(noCorrelationId) || [])];\n    if (!controllers.length) {\n      return;\n    }\n    for (const controller of controllers) {\n      controller.abort();\n    }\n    this.abortControllers.set(key, undefined);\n  }\n  getCorrelationId(options) {\n    var _a;\n    const parameter = (_a = options === null || options === void 0 ? void 0 : options.body) === null || _a === void 0 ? void 0 : _a.split(\"&\").map(part => part.split(\"=\")).find(([key]) => key === \"client-request-id\");\n    return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;\n  }\n  // The MSAL network module methods follow\n  sendGetRequestAsync(url, options) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const request = createPipelineRequest({\n        url,\n        method: \"GET\",\n        body: options === null || options === void 0 ? void 0 : options.body,\n        headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n        abortSignal: _this3.generateAbortSignal(noCorrelationId)\n      });\n      const response = yield _this3.sendRequest(request);\n      _this3.logIdentifiers(response);\n      return {\n        body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n        headers: response.headers.toJSON(),\n        status: response.status\n      };\n    })();\n  }\n  sendPostRequestAsync(url, options) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const request = createPipelineRequest({\n        url,\n        method: \"POST\",\n        body: options === null || options === void 0 ? void 0 : options.body,\n        headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n        // MSAL doesn't send the correlation ID on the get requests.\n        abortSignal: _this4.generateAbortSignal(_this4.getCorrelationId(options))\n      });\n      const response = yield _this4.sendRequest(request);\n      _this4.logIdentifiers(response);\n      return {\n        body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n        headers: response.headers.toJSON(),\n        status: response.status\n      };\n    })();\n  }\n  /**\n   *\n   * @internal\n   */\n  getTokenCredentialOptions() {\n    return this.tokenCredentialOptions;\n  }\n  /**\n   * If allowLoggingAccountIdentifiers was set on the constructor options\n   * we try to log the account identifiers by parsing the received access token.\n   *\n   * The account identifiers we try to log are:\n   * - `appid`: The application or Client Identifier.\n   * - `upn`: User Principal Name.\n   *   - It might not be available in some authentication scenarios.\n   *   - If it's not available, we put a placeholder: \"No User Principal Name available\".\n   * - `tid`: Tenant Identifier.\n   * - `oid`: Object Identifier of the authenticated user.\n   */\n  logIdentifiers(response) {\n    if (!this.allowLoggingAccountIdentifiers || !response.bodyAsText) {\n      return;\n    }\n    const unavailableUpn = \"No User Principal Name available\";\n    try {\n      const parsed = response.parsedBody || JSON.parse(response.bodyAsText);\n      const accessToken = parsed.access_token;\n      if (!accessToken) {\n        // Without an access token allowLoggingAccountIdentifiers isn't useful.\n        return;\n      }\n      const base64Metadata = accessToken.split(\".\")[1];\n      const {\n        appid,\n        upn,\n        tid,\n        oid\n      } = JSON.parse(Buffer.from(base64Metadata, \"base64\").toString(\"utf8\"));\n      logger.info(`[Authenticated account] Client ID: ${appid}. Tenant ID: ${tid}. User Principal Name: ${upn || unavailableUpn}. Object ID (user): ${oid}`);\n    } catch (e) {\n      logger.warning(\"allowLoggingAccountIdentifiers was set, but we couldn't log the account information. Error:\", e.message);\n    }\n  }\n}\n//# sourceMappingURL=identityClient.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}