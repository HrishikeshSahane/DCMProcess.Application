{"ast":null,"code":"/*! @azure/msal-browser v3.6.0 2023-12-01 */\n'use strict';\n\nimport _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { DatabaseStorage } from './DatabaseStorage.mjs';\nimport { MemoryStorage } from './MemoryStorage.mjs';\nimport { databaseUnavailable } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This class allows MSAL to store artifacts asynchronously using the DatabaseStorage IndexedDB wrapper,\n * backed up with the more volatile MemoryStorage object for cases in which IndexedDB may be unavailable.\n */\nclass AsyncMemoryStorage {\n  constructor(logger, storeName) {\n    this.inMemoryCache = new MemoryStorage();\n    this.indexedDBCache = new DatabaseStorage();\n    this.logger = logger;\n    this.storeName = storeName;\n  }\n  handleDatabaseAccessError(error) {\n    if (error instanceof BrowserAuthError && error.errorCode === databaseUnavailable) {\n      this.logger.error(\"Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.\");\n    } else {\n      throw error;\n    }\n  }\n  /**\n   * Get the item matching the given key. Tries in-memory cache first, then in the asynchronous\n   * storage object if item isn't found in-memory.\n   * @param key\n   */\n  getItem(key) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const item = _this.inMemoryCache.getItem(key);\n      if (!item) {\n        try {\n          _this.logger.verbose(\"Queried item not found in in-memory cache, now querying persistent storage.\");\n          return yield _this.indexedDBCache.getItem(key);\n        } catch (e) {\n          _this.handleDatabaseAccessError(e);\n        }\n      }\n      return item;\n    })();\n  }\n  /**\n   * Sets the item in the in-memory cache and then tries to set it in the asynchronous\n   * storage object with the given key.\n   * @param key\n   * @param value\n   */\n  setItem(key, value) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.inMemoryCache.setItem(key, value);\n      try {\n        yield _this2.indexedDBCache.setItem(key, value);\n      } catch (e) {\n        _this2.handleDatabaseAccessError(e);\n      }\n    })();\n  }\n  /**\n   * Removes the item matching the key from the in-memory cache, then tries to remove it from the asynchronous storage object.\n   * @param key\n   */\n  removeItem(key) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      _this3.inMemoryCache.removeItem(key);\n      try {\n        yield _this3.indexedDBCache.removeItem(key);\n      } catch (e) {\n        _this3.handleDatabaseAccessError(e);\n      }\n    })();\n  }\n  /**\n   * Get all the keys from the in-memory cache as an iterable array of strings. If no keys are found, query the keys in the\n   * asynchronous storage object.\n   */\n  getKeys() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const cacheKeys = _this4.inMemoryCache.getKeys();\n      if (cacheKeys.length === 0) {\n        try {\n          _this4.logger.verbose(\"In-memory cache is empty, now querying persistent storage.\");\n          return yield _this4.indexedDBCache.getKeys();\n        } catch (e) {\n          _this4.handleDatabaseAccessError(e);\n        }\n      }\n      return cacheKeys;\n    })();\n  }\n  /**\n   * Returns true or false if the given key is present in the cache.\n   * @param key\n   */\n  containsKey(key) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const containsKey = _this5.inMemoryCache.containsKey(key);\n      if (!containsKey) {\n        try {\n          _this5.logger.verbose(\"Key not found in in-memory cache, now querying persistent storage.\");\n          return yield _this5.indexedDBCache.containsKey(key);\n        } catch (e) {\n          _this5.handleDatabaseAccessError(e);\n        }\n      }\n      return containsKey;\n    })();\n  }\n  /**\n   * Clears in-memory Map\n   */\n  clearInMemory() {\n    // InMemory cache is a Map instance, clear is straightforward\n    this.logger.verbose(`Deleting in-memory keystore ${this.storeName}`);\n    this.inMemoryCache.clear();\n    this.logger.verbose(`In-memory keystore ${this.storeName} deleted`);\n  }\n  /**\n   * Tries to delete the IndexedDB database\n   * @returns\n   */\n  clearPersistent() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        _this6.logger.verbose(\"Deleting persistent keystore\");\n        const dbDeleted = yield _this6.indexedDBCache.deleteDatabase();\n        if (dbDeleted) {\n          _this6.logger.verbose(\"Persistent keystore deleted\");\n        }\n        return dbDeleted;\n      } catch (e) {\n        _this6.handleDatabaseAccessError(e);\n        return false;\n      }\n    })();\n  }\n}\nexport { AsyncMemoryStorage };\n//# sourceMappingURL=AsyncMemoryStorage.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}