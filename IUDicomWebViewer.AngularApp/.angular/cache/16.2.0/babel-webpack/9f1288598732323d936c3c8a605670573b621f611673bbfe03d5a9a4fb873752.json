{"ast":null,"code":"/*! @azure/msal-browser v3.6.0 2023-12-01 */\n'use strict';\n\nimport _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { invokeAsync, PerformanceEvents, AuthError, Constants, UrlString, UrlUtils, ProtocolUtils, ThrottlingUtils, ProtocolMode, ServerResponseType } from '@azure/msal-common';\nimport { StandardInteractionClient } from './StandardInteractionClient.mjs';\nimport { InteractionType, ApiId, TemporaryCacheKeys } from '../utils/BrowserConstants.mjs';\nimport { RedirectHandler } from '../interaction_handler/RedirectHandler.mjs';\nimport { replaceHash, isInIframe, getHomepage, clearHash, getCurrentUri } from '../utils/BrowserUtils.mjs';\nimport { EventType } from '../event/EventType.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { NativeInteractionClient } from './NativeInteractionClient.mjs';\nimport { NativeMessageHandler } from '../broker/nativeBroker/NativeMessageHandler.mjs';\nimport { validateInteractionType } from '../response/ResponseHandler.mjs';\nimport { noStateInHash, nativeConnectionNotEstablished, noCachedAuthorityError } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass RedirectClient extends StandardInteractionClient {\n  constructor(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeStorageImpl, nativeMessageHandler, correlationId) {\n    super(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId);\n    this.nativeStorage = nativeStorageImpl;\n  }\n  /**\n   * Redirects the page to the /authorize endpoint of the IDP\n   * @param request\n   */\n  acquireToken(request) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const validRequest = yield invokeAsync(_this.initializeAuthorizationRequest.bind(_this), PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, _this.logger, _this.performanceClient, _this.correlationId)(request, InteractionType.Redirect);\n      _this.browserStorage.updateCacheEntries(validRequest.state, validRequest.nonce, validRequest.authority, validRequest.loginHint || \"\", validRequest.account || null);\n      const serverTelemetryManager = _this.initializeServerTelemetryManager(ApiId.acquireTokenRedirect);\n      const handleBackButton = event => {\n        // Clear temporary cache if the back button is clicked during the redirect flow.\n        if (event.persisted) {\n          _this.logger.verbose(\"Page was restored from back/forward cache. Clearing temporary cache.\");\n          _this.browserStorage.cleanRequestByState(validRequest.state);\n          _this.eventHandler.emitEvent(EventType.RESTORE_FROM_BFCACHE, InteractionType.Redirect);\n        }\n      };\n      try {\n        // Create auth code request and generate PKCE params\n        const authCodeRequest = yield invokeAsync(_this.initializeAuthorizationCodeRequest.bind(_this), PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, _this.logger, _this.performanceClient, _this.correlationId)(validRequest);\n        // Initialize the client\n        const authClient = yield invokeAsync(_this.createAuthCodeClient.bind(_this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, _this.logger, _this.performanceClient, _this.correlationId)(serverTelemetryManager, validRequest.authority, validRequest.azureCloudOptions);\n        // Create redirect interaction handler.\n        const interactionHandler = new RedirectHandler(authClient, _this.browserStorage, authCodeRequest, _this.logger, _this.performanceClient);\n        // Create acquire token url.\n        const navigateUrl = yield authClient.getAuthCodeUrl({\n          ...validRequest,\n          nativeBroker: NativeMessageHandler.isNativeAvailable(_this.config, _this.logger, _this.nativeMessageHandler, request.authenticationScheme)\n        });\n        const redirectStartPage = _this.getRedirectStartPage(request.redirectStartPage);\n        _this.logger.verbosePii(`Redirect start page: ${redirectStartPage}`);\n        // Clear temporary cache if the back button is clicked during the redirect flow.\n        window.addEventListener(\"pageshow\", handleBackButton);\n        // Show the UI once the url has been created. Response will come back in the hash, which will be handled in the handleRedirectCallback function.\n        return yield interactionHandler.initiateAuthRequest(navigateUrl, {\n          navigationClient: _this.navigationClient,\n          redirectTimeout: _this.config.system.redirectNavigationTimeout,\n          redirectStartPage: redirectStartPage,\n          onRedirectNavigate: request.onRedirectNavigate\n        });\n      } catch (e) {\n        if (e instanceof AuthError) {\n          e.setCorrelationId(_this.correlationId);\n          serverTelemetryManager.cacheFailedRequest(e);\n        }\n        window.removeEventListener(\"pageshow\", handleBackButton);\n        _this.browserStorage.cleanRequestByState(validRequest.state);\n        throw e;\n      }\n    })();\n  }\n  /**\n   * Checks if navigateToLoginRequestUrl is set, and:\n   * - if true, performs logic to cache and navigate\n   * - if false, handles hash string and parses response\n   * @param hash\n   */\n  handleRedirectPromise(hash) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const serverTelemetryManager = _this2.initializeServerTelemetryManager(ApiId.handleRedirectPromise);\n      try {\n        if (!_this2.browserStorage.isInteractionInProgress(true)) {\n          _this2.logger.info(\"handleRedirectPromise called but there is no interaction in progress, returning null.\");\n          return null;\n        }\n        const [serverParams, responseString] = _this2.getRedirectResponse(hash || \"\");\n        if (!serverParams) {\n          // Not a recognized server response hash or hash not associated with a redirect request\n          _this2.logger.info(\"handleRedirectPromise did not detect a response as a result of a redirect. Cleaning temporary cache.\");\n          _this2.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\n          return null;\n        }\n        // If navigateToLoginRequestUrl is true, get the url where the redirect request was initiated\n        const loginRequestUrl = _this2.browserStorage.getTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, true) || Constants.EMPTY_STRING;\n        const loginRequestUrlNormalized = UrlString.removeHashFromUrl(loginRequestUrl);\n        const currentUrlNormalized = UrlString.removeHashFromUrl(window.location.href);\n        if (loginRequestUrlNormalized === currentUrlNormalized && _this2.config.auth.navigateToLoginRequestUrl) {\n          // We are on the page we need to navigate to - handle hash\n          _this2.logger.verbose(\"Current page is loginRequestUrl, handling response\");\n          if (loginRequestUrl.indexOf(\"#\") > -1) {\n            // Replace current hash with non-msal hash, if present\n            replaceHash(loginRequestUrl);\n          }\n          const handleHashResult = yield _this2.handleResponse(serverParams, serverTelemetryManager);\n          return handleHashResult;\n        } else if (!_this2.config.auth.navigateToLoginRequestUrl) {\n          _this2.logger.verbose(\"NavigateToLoginRequestUrl set to false, handling response\");\n          return yield _this2.handleResponse(serverParams, serverTelemetryManager);\n        } else if (!isInIframe() || _this2.config.system.allowRedirectInIframe) {\n          /*\n           * Returned from authority using redirect - need to perform navigation before processing response\n           * Cache the hash to be retrieved after the next redirect\n           */\n          _this2.browserStorage.setTemporaryCache(TemporaryCacheKeys.URL_HASH, responseString, true);\n          const navigationOptions = {\n            apiId: ApiId.handleRedirectPromise,\n            timeout: _this2.config.system.redirectNavigationTimeout,\n            noHistory: true\n          };\n          /**\n           * Default behavior is to redirect to the start page and not process the hash now.\n           * The start page is expected to also call handleRedirectPromise which will process the hash in one of the checks above.\n           */\n          let processHashOnRedirect = true;\n          if (!loginRequestUrl || loginRequestUrl === \"null\") {\n            // Redirect to home page if login request url is null (real null or the string null)\n            const homepage = getHomepage();\n            // Cache the homepage under ORIGIN_URI to ensure cached hash is processed on homepage\n            _this2.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, homepage, true);\n            _this2.logger.warning(\"Unable to get valid login request url from cache, redirecting to home page\");\n            processHashOnRedirect = yield _this2.navigationClient.navigateInternal(homepage, navigationOptions);\n          } else {\n            // Navigate to page that initiated the redirect request\n            _this2.logger.verbose(`Navigating to loginRequestUrl: ${loginRequestUrl}`);\n            processHashOnRedirect = yield _this2.navigationClient.navigateInternal(loginRequestUrl, navigationOptions);\n          }\n          // If navigateInternal implementation returns false, handle the hash now\n          if (!processHashOnRedirect) {\n            return yield _this2.handleResponse(serverParams, serverTelemetryManager);\n          }\n        }\n        return null;\n      } catch (e) {\n        if (e instanceof AuthError) {\n          e.setCorrelationId(_this2.correlationId);\n          serverTelemetryManager.cacheFailedRequest(e);\n        }\n        _this2.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\n        throw e;\n      }\n    })();\n  }\n  /**\n   * Gets the response hash for a redirect request\n   * Returns null if interactionType in the state value is not \"redirect\" or the hash does not contain known properties\n   * @param hash\n   */\n  getRedirectResponse(userProvidedResponse) {\n    this.logger.verbose(\"getRedirectResponseHash called\");\n    // Get current location hash from window or cache.\n    let responseString = userProvidedResponse;\n    if (!responseString) {\n      if (this.config.auth.OIDCOptions.serverResponseType === ServerResponseType.QUERY) {\n        responseString = window.location.search;\n      } else {\n        responseString = window.location.hash;\n      }\n    }\n    let response = UrlUtils.getDeserializedResponse(responseString);\n    if (response) {\n      try {\n        validateInteractionType(response, this.browserCrypto, InteractionType.Redirect);\n      } catch (e) {\n        if (e instanceof AuthError) {\n          this.logger.error(`Interaction type validation failed due to ${e.errorCode}: ${e.errorMessage}`);\n        }\n        return [null, \"\"];\n      }\n      clearHash(window);\n      this.logger.verbose(\"Hash contains known properties, returning response hash\");\n      return [response, responseString];\n    }\n    const cachedHash = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.URL_HASH, true);\n    this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n    if (cachedHash) {\n      response = UrlUtils.getDeserializedResponse(cachedHash);\n      if (response) {\n        this.logger.verbose(\"Hash does not contain known properties, returning cached hash\");\n        return [response, cachedHash];\n      }\n    }\n    return [null, \"\"];\n  }\n  /**\n   * Checks if hash exists and handles in window.\n   * @param hash\n   * @param state\n   */\n  handleResponse(serverParams, serverTelemetryManager) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const state = serverParams.state;\n      if (!state) {\n        throw createBrowserAuthError(noStateInHash);\n      }\n      const cachedRequest = _this3.browserStorage.getCachedRequest(state);\n      _this3.logger.verbose(\"handleResponse called, retrieved cached request\");\n      if (serverParams.accountId) {\n        _this3.logger.verbose(\"Account id found in hash, calling WAM for token\");\n        if (!_this3.nativeMessageHandler) {\n          throw createBrowserAuthError(nativeConnectionNotEstablished);\n        }\n        const nativeInteractionClient = new NativeInteractionClient(_this3.config, _this3.browserStorage, _this3.browserCrypto, _this3.logger, _this3.eventHandler, _this3.navigationClient, ApiId.acquireTokenPopup, _this3.performanceClient, _this3.nativeMessageHandler, serverParams.accountId, _this3.nativeStorage, cachedRequest.correlationId);\n        const {\n          userRequestState\n        } = ProtocolUtils.parseRequestState(_this3.browserCrypto, state);\n        return nativeInteractionClient.acquireToken({\n          ...cachedRequest,\n          state: userRequestState,\n          prompt: undefined // Server should handle the prompt, ideally native broker can do this part silently\n        }).finally(() => {\n          _this3.browserStorage.cleanRequestByState(state);\n        });\n      }\n      // Hash contains known properties - handle and return in callback\n      const currentAuthority = _this3.browserStorage.getCachedAuthority(state);\n      if (!currentAuthority) {\n        throw createBrowserAuthError(noCachedAuthorityError);\n      }\n      const authClient = yield invokeAsync(_this3.createAuthCodeClient.bind(_this3), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, _this3.logger, _this3.performanceClient, _this3.correlationId)(serverTelemetryManager, currentAuthority);\n      ThrottlingUtils.removeThrottle(_this3.browserStorage, _this3.config.auth.clientId, cachedRequest);\n      const interactionHandler = new RedirectHandler(authClient, _this3.browserStorage, cachedRequest, _this3.logger, _this3.performanceClient);\n      return interactionHandler.handleCodeResponse(serverParams, state);\n    })();\n  }\n  /**\n   * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\n   * Default behaviour is to redirect the user to `window.location.href`.\n   * @param logoutRequest\n   */\n  logout(logoutRequest) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      _this4.logger.verbose(\"logoutRedirect called\");\n      const validLogoutRequest = _this4.initializeLogoutRequest(logoutRequest);\n      const serverTelemetryManager = _this4.initializeServerTelemetryManager(ApiId.logout);\n      try {\n        _this4.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Redirect, logoutRequest);\n        // Clear cache on logout\n        yield _this4.clearCacheOnLogout(validLogoutRequest.account);\n        const navigationOptions = {\n          apiId: ApiId.logout,\n          timeout: _this4.config.system.redirectNavigationTimeout,\n          noHistory: false\n        };\n        const authClient = yield invokeAsync(_this4.createAuthCodeClient.bind(_this4), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, _this4.logger, _this4.performanceClient, _this4.correlationId)(serverTelemetryManager, logoutRequest && logoutRequest.authority);\n        if (authClient.authority.protocolMode === ProtocolMode.OIDC) {\n          try {\n            authClient.authority.endSessionEndpoint;\n          } catch {\n            if (validLogoutRequest.account?.homeAccountId) {\n              void _this4.browserStorage.removeAccount(validLogoutRequest.account?.homeAccountId);\n              _this4.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, validLogoutRequest);\n              return;\n            }\n          }\n        }\n        // Create logout string and navigate user window to logout.\n        const logoutUri = authClient.getLogoutUri(validLogoutRequest);\n        _this4.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, validLogoutRequest);\n        // Check if onRedirectNavigate is implemented, and invoke it if so\n        if (logoutRequest && typeof logoutRequest.onRedirectNavigate === \"function\") {\n          const navigate = logoutRequest.onRedirectNavigate(logoutUri);\n          if (navigate !== false) {\n            _this4.logger.verbose(\"Logout onRedirectNavigate did not return false, navigating\");\n            // Ensure interaction is in progress\n            if (!_this4.browserStorage.getInteractionInProgress()) {\n              _this4.browserStorage.setInteractionInProgress(true);\n            }\n            yield _this4.navigationClient.navigateExternal(logoutUri, navigationOptions);\n            return;\n          } else {\n            // Ensure interaction is not in progress\n            _this4.browserStorage.setInteractionInProgress(false);\n            _this4.logger.verbose(\"Logout onRedirectNavigate returned false, stopping navigation\");\n          }\n        } else {\n          // Ensure interaction is in progress\n          if (!_this4.browserStorage.getInteractionInProgress()) {\n            _this4.browserStorage.setInteractionInProgress(true);\n          }\n          yield _this4.navigationClient.navigateExternal(logoutUri, navigationOptions);\n          return;\n        }\n      } catch (e) {\n        if (e instanceof AuthError) {\n          e.setCorrelationId(_this4.correlationId);\n          serverTelemetryManager.cacheFailedRequest(e);\n        }\n        _this4.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Redirect, null, e);\n        _this4.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);\n        throw e;\n      }\n      _this4.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);\n    })();\n  }\n  /**\n   * Use to get the redirectStartPage either from request or use current window\n   * @param requestStartPage\n   */\n  getRedirectStartPage(requestStartPage) {\n    const redirectStartPage = requestStartPage || window.location.href;\n    return UrlString.getAbsoluteUrl(redirectStartPage, getCurrentUri());\n  }\n}\nexport { RedirectClient };\n//# sourceMappingURL=RedirectClient.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}