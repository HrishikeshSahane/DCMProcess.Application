{"ast":null,"code":"/*! @azure/msal-browser v3.6.0 2023-12-01 */\n'use strict';\n\nimport _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { PerformanceEvents, invokeAsync, invoke, ServerResponseType } from '@azure/msal-common';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { DEFAULT_IFRAME_TIMEOUT_MS } from '../config/Configuration.mjs';\nimport { emptyNavigateUri, monitorWindowTimeout } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Creates a hidden iframe to given URL using user-requested scopes as an id.\n * @param urlNavigate\n * @param userRequestScopes\n */\nfunction initiateAuthRequest(_x, _x2, _x3, _x4, _x5) {\n  return _initiateAuthRequest.apply(this, arguments);\n}\n/**\n * Monitors an iframe content window until it loads a url with a known hash, or hits a specified timeout.\n * @param iframe\n * @param timeout\n */\nfunction _initiateAuthRequest() {\n  _initiateAuthRequest = _asyncToGenerator(function* (requestUrl, performanceClient, logger, correlationId, navigateFrameWait) {\n    performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerInitiateAuthRequest, correlationId);\n    if (!requestUrl) {\n      // Throw error if request URL is empty.\n      logger.info(\"Navigate url is empty\");\n      throw createBrowserAuthError(emptyNavigateUri);\n    }\n    if (navigateFrameWait) {\n      return invokeAsync(loadFrame, PerformanceEvents.SilentHandlerLoadFrame, logger, performanceClient, correlationId)(requestUrl, navigateFrameWait, performanceClient, correlationId);\n    }\n    return invoke(loadFrameSync, PerformanceEvents.SilentHandlerLoadFrameSync, logger, performanceClient, correlationId)(requestUrl);\n  });\n  return _initiateAuthRequest.apply(this, arguments);\n}\nfunction monitorIframeForHash(_x6, _x7, _x8, _x9, _x10, _x11, _x12) {\n  return _monitorIframeForHash.apply(this, arguments);\n}\n/**\n * @hidden\n * Loads iframe with authorization endpoint URL\n * @ignore\n * @deprecated\n */\nfunction _monitorIframeForHash() {\n  _monitorIframeForHash = _asyncToGenerator(function* (iframe, timeout, pollIntervalMilliseconds, performanceClient, logger, correlationId, responseType) {\n    performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerMonitorIframeForHash, correlationId);\n    return new Promise((resolve, reject) => {\n      if (timeout < DEFAULT_IFRAME_TIMEOUT_MS) {\n        logger.warning(`system.loadFrameTimeout or system.iframeHashTimeout set to lower (${timeout}ms) than the default (${DEFAULT_IFRAME_TIMEOUT_MS}ms). This may result in timeouts.`);\n      }\n      /*\n       * Polling for iframes can be purely timing based,\n       * since we don't need to account for interaction.\n       */\n      const timeoutId = window.setTimeout(() => {\n        window.clearInterval(intervalId);\n        reject(createBrowserAuthError(monitorWindowTimeout));\n      }, timeout);\n      const intervalId = window.setInterval(() => {\n        let href = \"\";\n        const contentWindow = iframe.contentWindow;\n        try {\n          /*\n           * Will throw if cross origin,\n           * which should be caught and ignored\n           * since we need the interval to keep running while on STS UI.\n           */\n          href = contentWindow ? contentWindow.location.href : \"\";\n        } catch (e) {}\n        if (!href || href === \"about:blank\") {\n          return;\n        }\n        let responseString = \"\";\n        if (contentWindow) {\n          if (responseType === ServerResponseType.QUERY) {\n            responseString = contentWindow.location.search;\n          } else {\n            responseString = contentWindow.location.hash;\n          }\n        }\n        window.clearTimeout(timeoutId);\n        window.clearInterval(intervalId);\n        resolve(responseString);\n      }, pollIntervalMilliseconds);\n    }).finally(() => {\n      invoke(removeHiddenIframe, PerformanceEvents.RemoveHiddenIframe, logger, performanceClient, correlationId)(iframe);\n    });\n  });\n  return _monitorIframeForHash.apply(this, arguments);\n}\nfunction loadFrame(urlNavigate, navigateFrameWait, performanceClient, correlationId) {\n  performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerLoadFrame, correlationId);\n  /*\n   * This trick overcomes iframe navigation in IE\n   * IE does not load the page consistently in iframe\n   */\n  return new Promise((resolve, reject) => {\n    const frameHandle = createHiddenIframe();\n    window.setTimeout(() => {\n      if (!frameHandle) {\n        reject(\"Unable to load iframe\");\n        return;\n      }\n      frameHandle.src = urlNavigate;\n      resolve(frameHandle);\n    }, navigateFrameWait);\n  });\n}\n/**\n * @hidden\n * Loads the iframe synchronously when the navigateTimeFrame is set to `0`\n * @param urlNavigate\n * @param frameName\n * @param logger\n */\nfunction loadFrameSync(urlNavigate) {\n  const frameHandle = createHiddenIframe();\n  frameHandle.src = urlNavigate;\n  return frameHandle;\n}\n/**\n * @hidden\n * Creates a new hidden iframe or gets an existing one for silent token renewal.\n * @ignore\n */\nfunction createHiddenIframe() {\n  const authFrame = document.createElement(\"iframe\");\n  authFrame.style.visibility = \"hidden\";\n  authFrame.style.position = \"absolute\";\n  authFrame.style.width = authFrame.style.height = \"0\";\n  authFrame.style.border = \"0\";\n  authFrame.setAttribute(\"sandbox\", \"allow-scripts allow-same-origin allow-forms\");\n  document.body.appendChild(authFrame);\n  return authFrame;\n}\n/**\n * @hidden\n * Removes a hidden iframe from the page.\n * @ignore\n */\nfunction removeHiddenIframe(iframe) {\n  if (document.body === iframe.parentNode) {\n    document.body.removeChild(iframe);\n  }\n}\nexport { initiateAuthRequest, monitorIframeForHash };\n//# sourceMappingURL=SilentHandler.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}