{"ast":null,"code":"/*! @azure/msal-browser v3.6.0 2023-12-01 */\n'use strict';\n\nimport _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { OIDC_DEFAULT_SCOPES, invokeAsync, PerformanceEvents, invoke, ThrottlingUtils, ProtocolUtils, AuthError, ProtocolMode, UrlString, ServerResponseType } from '@azure/msal-common';\nimport { StandardInteractionClient } from './StandardInteractionClient.mjs';\nimport { EventType } from '../event/EventType.mjs';\nimport { ApiId, InteractionType, BrowserConstants } from '../utils/BrowserConstants.mjs';\nimport { preconnect, getCurrentUri } from '../utils/BrowserUtils.mjs';\nimport { NativeInteractionClient } from './NativeInteractionClient.mjs';\nimport { NativeMessageHandler } from '../broker/nativeBroker/NativeMessageHandler.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { InteractionHandler } from '../interaction_handler/InteractionHandler.mjs';\nimport { deserializeResponse } from '../response/ResponseHandler.mjs';\nimport { nativeConnectionNotEstablished, emptyNavigateUri, userCancelled, emptyWindowError, popupWindowError } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass PopupClient extends StandardInteractionClient {\n  constructor(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeStorageImpl, nativeMessageHandler, correlationId) {\n    super(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId);\n    // Properly sets this reference for the unload event.\n    this.unloadWindow = this.unloadWindow.bind(this);\n    this.nativeStorage = nativeStorageImpl;\n  }\n  /**\n   * Acquires tokens by opening a popup window to the /authorize endpoint of the authority\n   * @param request\n   */\n  acquireToken(request) {\n    try {\n      const popupName = this.generatePopupName(request.scopes || OIDC_DEFAULT_SCOPES, request.authority || this.config.auth.authority);\n      const popupWindowAttributes = request.popupWindowAttributes || {};\n      // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.\n      if (this.config.system.asyncPopups) {\n        this.logger.verbose(\"asyncPopups set to true, acquiring token\");\n        // Passes on popup position and dimensions if in request\n        return this.acquireTokenPopupAsync(request, popupName, popupWindowAttributes);\n      } else {\n        // asyncPopups flag is set to false. Opens popup before acquiring token.\n        this.logger.verbose(\"asyncPopup set to false, opening popup before acquiring token\");\n        const popup = this.openSizedPopup(\"about:blank\", popupName, popupWindowAttributes);\n        return this.acquireTokenPopupAsync(request, popupName, popupWindowAttributes, popup);\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  /**\n   * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server\n   * @param logoutRequest\n   */\n  logout(logoutRequest) {\n    try {\n      this.logger.verbose(\"logoutPopup called\");\n      const validLogoutRequest = this.initializeLogoutRequest(logoutRequest);\n      const popupName = this.generateLogoutPopupName(validLogoutRequest);\n      const authority = logoutRequest && logoutRequest.authority;\n      const mainWindowRedirectUri = logoutRequest && logoutRequest.mainWindowRedirectUri;\n      const popupWindowAttributes = logoutRequest?.popupWindowAttributes || {};\n      // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.\n      if (this.config.system.asyncPopups) {\n        this.logger.verbose(\"asyncPopups set to true\");\n        // Passes on popup position and dimensions if in request\n        return this.logoutPopupAsync(validLogoutRequest, popupName, popupWindowAttributes, authority, undefined, mainWindowRedirectUri);\n      } else {\n        // asyncPopups flag is set to false. Opens popup before logging out.\n        this.logger.verbose(\"asyncPopup set to false, opening popup\");\n        const popup = this.openSizedPopup(\"about:blank\", popupName, popupWindowAttributes);\n        return this.logoutPopupAsync(validLogoutRequest, popupName, popupWindowAttributes, authority, popup, mainWindowRedirectUri);\n      }\n    } catch (e) {\n      // Since this function is synchronous we need to reject\n      return Promise.reject(e);\n    }\n  }\n  /**\n   * Helper which obtains an access_token for your API via opening a popup window in the user's browser\n   * @param validRequest\n   * @param popupName\n   * @param popup\n   * @param popupWindowAttributes\n   *\n   * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\n   */\n  acquireTokenPopupAsync(request, popupName, popupWindowAttributes, popup) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.logger.verbose(\"acquireTokenPopupAsync called\");\n      const serverTelemetryManager = _this.initializeServerTelemetryManager(ApiId.acquireTokenPopup);\n      const validRequest = yield invokeAsync(_this.initializeAuthorizationRequest.bind(_this), PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, _this.logger, _this.performanceClient, _this.correlationId)(request, InteractionType.Popup);\n      preconnect(validRequest.authority);\n      try {\n        // Create auth code request and generate PKCE params\n        const authCodeRequest = yield invokeAsync(_this.initializeAuthorizationCodeRequest.bind(_this), PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, _this.logger, _this.performanceClient, _this.correlationId)(validRequest);\n        // Initialize the client\n        const authClient = yield invokeAsync(_this.createAuthCodeClient.bind(_this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, _this.logger, _this.performanceClient, _this.correlationId)(serverTelemetryManager, validRequest.authority, validRequest.azureCloudOptions);\n        const isNativeBroker = NativeMessageHandler.isNativeAvailable(_this.config, _this.logger, _this.nativeMessageHandler, request.authenticationScheme);\n        // Start measurement for server calls with native brokering enabled\n        let fetchNativeAccountIdMeasurement;\n        if (isNativeBroker) {\n          fetchNativeAccountIdMeasurement = _this.performanceClient.startMeasurement(PerformanceEvents.FetchAccountIdWithNativeBroker, request.correlationId);\n        }\n        // Create acquire token url.\n        const navigateUrl = yield authClient.getAuthCodeUrl({\n          ...validRequest,\n          nativeBroker: isNativeBroker\n        });\n        // Create popup interaction handler.\n        const interactionHandler = new InteractionHandler(authClient, _this.browserStorage, authCodeRequest, _this.logger, _this.performanceClient);\n        // Show the UI once the url has been created. Get the window handle for the popup.\n        const popupParameters = {\n          popup,\n          popupName,\n          popupWindowAttributes\n        };\n        const popupWindow = _this.initiateAuthRequest(navigateUrl, popupParameters);\n        _this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, {\n          popupWindow\n        }, null);\n        // Monitor the window for the hash. Return the string value and close the popup when the hash is received. Default timeout is 60 seconds.\n        const responseString = yield _this.monitorPopupForHash(popupWindow);\n        const serverParams = invoke(deserializeResponse, PerformanceEvents.DeserializeResponse, _this.logger, _this.performanceClient, _this.correlationId)(responseString, _this.config.auth.OIDCOptions.serverResponseType, _this.logger);\n        // Remove throttle if it exists\n        ThrottlingUtils.removeThrottle(_this.browserStorage, _this.config.auth.clientId, authCodeRequest);\n        if (serverParams.accountId) {\n          _this.logger.verbose(\"Account id found in hash, calling WAM for token\");\n          // end measurement for server call with native brokering enabled\n          if (fetchNativeAccountIdMeasurement) {\n            fetchNativeAccountIdMeasurement.end({\n              success: true,\n              isNativeBroker: true\n            });\n          }\n          if (!_this.nativeMessageHandler) {\n            throw createBrowserAuthError(nativeConnectionNotEstablished);\n          }\n          const nativeInteractionClient = new NativeInteractionClient(_this.config, _this.browserStorage, _this.browserCrypto, _this.logger, _this.eventHandler, _this.navigationClient, ApiId.acquireTokenPopup, _this.performanceClient, _this.nativeMessageHandler, serverParams.accountId, _this.nativeStorage, validRequest.correlationId);\n          const {\n            userRequestState\n          } = ProtocolUtils.parseRequestState(_this.browserCrypto, validRequest.state);\n          return yield nativeInteractionClient.acquireToken({\n            ...validRequest,\n            state: userRequestState,\n            prompt: undefined // Server should handle the prompt, ideally native broker can do this part silently\n          });\n        }\n        // Handle response from hash string.\n        const result = yield interactionHandler.handleCodeResponse(serverParams, validRequest);\n        return result;\n      } catch (e) {\n        if (popup) {\n          // Close the synchronous popup if an error is thrown before the window unload event is registered\n          popup.close();\n        }\n        if (e instanceof AuthError) {\n          e.setCorrelationId(_this.correlationId);\n          serverTelemetryManager.cacheFailedRequest(e);\n        }\n        throw e;\n      }\n    })();\n  }\n  /**\n   *\n   * @param validRequest\n   * @param popupName\n   * @param requestAuthority\n   * @param popup\n   * @param mainWindowRedirectUri\n   * @param popupWindowAttributes\n   */\n  logoutPopupAsync(validRequest, popupName, popupWindowAttributes, requestAuthority, popup, mainWindowRedirectUri) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.logger.verbose(\"logoutPopupAsync called\");\n      _this2.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Popup, validRequest);\n      const serverTelemetryManager = _this2.initializeServerTelemetryManager(ApiId.logoutPopup);\n      try {\n        // Clear cache on logout\n        yield _this2.clearCacheOnLogout(validRequest.account);\n        // Initialize the client\n        const authClient = yield invokeAsync(_this2.createAuthCodeClient.bind(_this2), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, _this2.logger, _this2.performanceClient, _this2.correlationId)(serverTelemetryManager, requestAuthority);\n        try {\n          authClient.authority.endSessionEndpoint;\n        } catch {\n          if (validRequest.account?.homeAccountId && validRequest.postLogoutRedirectUri && authClient.authority.protocolMode === ProtocolMode.OIDC) {\n            void _this2.browserStorage.removeAccount(validRequest.account?.homeAccountId);\n            _this2.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Popup, validRequest);\n            if (mainWindowRedirectUri) {\n              const navigationOptions = {\n                apiId: ApiId.logoutPopup,\n                timeout: _this2.config.system.redirectNavigationTimeout,\n                noHistory: false\n              };\n              const absoluteUrl = UrlString.getAbsoluteUrl(mainWindowRedirectUri, getCurrentUri());\n              yield _this2.navigationClient.navigateInternal(absoluteUrl, navigationOptions);\n            }\n            if (popup) {\n              popup.close();\n            }\n            return;\n          }\n        }\n        // Create logout string and navigate user window to logout.\n        const logoutUri = authClient.getLogoutUri(validRequest);\n        _this2.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Popup, validRequest);\n        // Open the popup window to requestUrl.\n        const popupWindow = _this2.openPopup(logoutUri, {\n          popupName,\n          popupWindowAttributes,\n          popup\n        });\n        _this2.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, {\n          popupWindow\n        }, null);\n        yield _this2.monitorPopupForHash(popupWindow).catch(() => {\n          // Swallow any errors related to monitoring the window. Server logout is best effort\n        });\n        if (mainWindowRedirectUri) {\n          const navigationOptions = {\n            apiId: ApiId.logoutPopup,\n            timeout: _this2.config.system.redirectNavigationTimeout,\n            noHistory: false\n          };\n          const absoluteUrl = UrlString.getAbsoluteUrl(mainWindowRedirectUri, getCurrentUri());\n          _this2.logger.verbose(\"Redirecting main window to url specified in the request\");\n          _this2.logger.verbosePii(`Redirecting main window to: ${absoluteUrl}`);\n          yield _this2.navigationClient.navigateInternal(absoluteUrl, navigationOptions);\n        } else {\n          _this2.logger.verbose(\"No main window navigation requested\");\n        }\n      } catch (e) {\n        if (popup) {\n          // Close the synchronous popup if an error is thrown before the window unload event is registered\n          popup.close();\n        }\n        if (e instanceof AuthError) {\n          e.setCorrelationId(_this2.correlationId);\n          serverTelemetryManager.cacheFailedRequest(e);\n        }\n        _this2.browserStorage.setInteractionInProgress(false);\n        _this2.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Popup, null, e);\n        _this2.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);\n        throw e;\n      }\n      _this2.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);\n    })();\n  }\n  /**\n   * Opens a popup window with given request Url.\n   * @param requestUrl\n   */\n  initiateAuthRequest(requestUrl, params) {\n    // Check that request url is not empty.\n    if (requestUrl) {\n      this.logger.infoPii(`Navigate to: ${requestUrl}`);\n      // Open the popup window to requestUrl.\n      return this.openPopup(requestUrl, params);\n    } else {\n      // Throw error if request URL is empty.\n      this.logger.error(\"Navigate url is empty\");\n      throw createBrowserAuthError(emptyNavigateUri);\n    }\n  }\n  /**\n   * Monitors a window until it loads a url with the same origin.\n   * @param popupWindow - window that is being monitored\n   * @param timeout - timeout for processing hash once popup is redirected back to application\n   */\n  monitorPopupForHash(popupWindow) {\n    return new Promise((resolve, reject) => {\n      this.logger.verbose(\"PopupHandler.monitorPopupForHash - polling started\");\n      const intervalId = setInterval(() => {\n        // Window is closed\n        if (popupWindow.closed) {\n          this.logger.error(\"PopupHandler.monitorPopupForHash - window closed\");\n          clearInterval(intervalId);\n          reject(createBrowserAuthError(userCancelled));\n          return;\n        }\n        let href = \"\";\n        try {\n          /*\n           * Will throw if cross origin,\n           * which should be caught and ignored\n           * since we need the interval to keep running while on STS UI.\n           */\n          href = popupWindow.location.href;\n        } catch (e) {}\n        // Don't process blank pages or cross domain\n        if (!href || href === \"about:blank\") {\n          return;\n        }\n        clearInterval(intervalId);\n        let responseString = \"\";\n        const responseType = this.config.auth.OIDCOptions.serverResponseType;\n        if (popupWindow) {\n          if (responseType === ServerResponseType.QUERY) {\n            responseString = popupWindow.location.search;\n          } else {\n            responseString = popupWindow.location.hash;\n          }\n        }\n        this.logger.verbose(\"PopupHandler.monitorPopupForHash - popup window is on same origin as caller\");\n        resolve(responseString);\n      }, this.config.system.pollIntervalMilliseconds);\n    }).finally(() => {\n      this.cleanPopup(popupWindow);\n    });\n  }\n  /**\n   * @hidden\n   *\n   * Configures popup window for login.\n   *\n   * @param urlNavigate\n   * @param title\n   * @param popUpWidth\n   * @param popUpHeight\n   * @param popupWindowAttributes\n   * @ignore\n   * @hidden\n   */\n  openPopup(urlNavigate, popupParams) {\n    try {\n      let popupWindow;\n      // Popup window passed in, setting url to navigate to\n      if (popupParams.popup) {\n        popupWindow = popupParams.popup;\n        this.logger.verbosePii(`Navigating popup window to: ${urlNavigate}`);\n        popupWindow.location.assign(urlNavigate);\n      } else if (typeof popupParams.popup === \"undefined\") {\n        // Popup will be undefined if it was not passed in\n        this.logger.verbosePii(`Opening popup window to: ${urlNavigate}`);\n        popupWindow = this.openSizedPopup(urlNavigate, popupParams.popupName, popupParams.popupWindowAttributes);\n      }\n      // Popup will be null if popups are blocked\n      if (!popupWindow) {\n        throw createBrowserAuthError(emptyWindowError);\n      }\n      if (popupWindow.focus) {\n        popupWindow.focus();\n      }\n      this.currentWindow = popupWindow;\n      window.addEventListener(\"beforeunload\", this.unloadWindow);\n      return popupWindow;\n    } catch (e) {\n      this.logger.error(\"error opening popup \" + e.message);\n      this.browserStorage.setInteractionInProgress(false);\n      throw createBrowserAuthError(popupWindowError);\n    }\n  }\n  /**\n   * Helper function to set popup window dimensions and position\n   * @param urlNavigate\n   * @param popupName\n   * @param popupWindowAttributes\n   * @returns\n   */\n  openSizedPopup(urlNavigate, popupName, popupWindowAttributes) {\n    /**\n     * adding winLeft and winTop to account for dual monitor\n     * using screenLeft and screenTop for IE8 and earlier\n     */\n    const winLeft = window.screenLeft ? window.screenLeft : window.screenX;\n    const winTop = window.screenTop ? window.screenTop : window.screenY;\n    /**\n     * window.innerWidth displays browser window\"s height and width excluding toolbars\n     * using document.documentElement.clientWidth for IE8 and earlier\n     */\n    const winWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n    const winHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n    let width = popupWindowAttributes.popupSize?.width;\n    let height = popupWindowAttributes.popupSize?.height;\n    let top = popupWindowAttributes.popupPosition?.top;\n    let left = popupWindowAttributes.popupPosition?.left;\n    if (!width || width < 0 || width > winWidth) {\n      this.logger.verbose(\"Default popup window width used. Window width not configured or invalid.\");\n      width = BrowserConstants.POPUP_WIDTH;\n    }\n    if (!height || height < 0 || height > winHeight) {\n      this.logger.verbose(\"Default popup window height used. Window height not configured or invalid.\");\n      height = BrowserConstants.POPUP_HEIGHT;\n    }\n    if (!top || top < 0 || top > winHeight) {\n      this.logger.verbose(\"Default popup window top position used. Window top not configured or invalid.\");\n      top = Math.max(0, winHeight / 2 - BrowserConstants.POPUP_HEIGHT / 2 + winTop);\n    }\n    if (!left || left < 0 || left > winWidth) {\n      this.logger.verbose(\"Default popup window left position used. Window left not configured or invalid.\");\n      left = Math.max(0, winWidth / 2 - BrowserConstants.POPUP_WIDTH / 2 + winLeft);\n    }\n    return window.open(urlNavigate, popupName, `width=${width}, height=${height}, top=${top}, left=${left}, scrollbars=yes`);\n  }\n  /**\n   * Event callback to unload main window.\n   */\n  unloadWindow(e) {\n    this.browserStorage.cleanRequestByInteractionType(InteractionType.Popup);\n    if (this.currentWindow) {\n      this.currentWindow.close();\n    }\n    // Guarantees browser unload will happen, so no other errors will be thrown.\n    e.preventDefault();\n  }\n  /**\n   * Closes popup, removes any state vars created during popup calls.\n   * @param popupWindow\n   */\n  cleanPopup(popupWindow) {\n    if (popupWindow) {\n      // Close window.\n      popupWindow.close();\n    }\n    // Remove window unload function\n    window.removeEventListener(\"beforeunload\", this.unloadWindow);\n    // Interaction is completed - remove interaction status.\n    this.browserStorage.setInteractionInProgress(false);\n  }\n  /**\n   * Generates the name for the popup based on the client id and request\n   * @param clientId\n   * @param request\n   */\n  generatePopupName(scopes, authority) {\n    return `${BrowserConstants.POPUP_NAME_PREFIX}.${this.config.auth.clientId}.${scopes.join(\"-\")}.${authority}.${this.correlationId}`;\n  }\n  /**\n   * Generates the name for the popup based on the client id and request for logouts\n   * @param clientId\n   * @param request\n   */\n  generateLogoutPopupName(request) {\n    const homeAccountId = request.account && request.account.homeAccountId;\n    return `${BrowserConstants.POPUP_NAME_PREFIX}.${this.config.auth.clientId}.${homeAccountId}.${this.correlationId}`;\n  }\n}\nexport { PopupClient };\n//# sourceMappingURL=PopupClient.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}