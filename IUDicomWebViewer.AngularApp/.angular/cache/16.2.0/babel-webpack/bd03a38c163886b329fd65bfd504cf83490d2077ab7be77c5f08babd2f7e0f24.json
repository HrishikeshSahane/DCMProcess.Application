{"ast":null,"code":"/*! @azure/msal-browser v3.6.0 2023-12-01 */\n'use strict';\n\nimport _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { createClientAuthError, ClientAuthErrorCodes, ServerError, invokeAsync, PerformanceEvents } from '@azure/msal-common';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { TemporaryCacheKeys, ApiId } from '../utils/BrowserConstants.mjs';\nimport { emptyNavigateUri, userCancelled } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass RedirectHandler {\n  constructor(authCodeModule, storageImpl, authCodeRequest, logger, performanceClient) {\n    this.authModule = authCodeModule;\n    this.browserStorage = storageImpl;\n    this.authCodeRequest = authCodeRequest;\n    this.logger = logger;\n    this.performanceClient = performanceClient;\n  }\n  /**\n   * Redirects window to given URL.\n   * @param urlNavigate\n   */\n  initiateAuthRequest(requestUrl, params) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.logger.verbose(\"RedirectHandler.initiateAuthRequest called\");\n      // Navigate if valid URL\n      if (requestUrl) {\n        // Cache start page, returns to this page after redirectUri if navigateToLoginRequestUrl is true\n        if (params.redirectStartPage) {\n          _this.logger.verbose(\"RedirectHandler.initiateAuthRequest: redirectStartPage set, caching start page\");\n          _this.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, params.redirectStartPage, true);\n        }\n        // Set interaction status in the library.\n        _this.browserStorage.setTemporaryCache(TemporaryCacheKeys.CORRELATION_ID, _this.authCodeRequest.correlationId, true);\n        _this.browserStorage.cacheCodeRequest(_this.authCodeRequest);\n        _this.logger.infoPii(`RedirectHandler.initiateAuthRequest: Navigate to: ${requestUrl}`);\n        const navigationOptions = {\n          apiId: ApiId.acquireTokenRedirect,\n          timeout: params.redirectTimeout,\n          noHistory: false\n        };\n        // If onRedirectNavigate is implemented, invoke it and provide requestUrl\n        if (typeof params.onRedirectNavigate === \"function\") {\n          _this.logger.verbose(\"RedirectHandler.initiateAuthRequest: Invoking onRedirectNavigate callback\");\n          const navigate = params.onRedirectNavigate(requestUrl);\n          // Returning false from onRedirectNavigate will stop navigation\n          if (navigate !== false) {\n            _this.logger.verbose(\"RedirectHandler.initiateAuthRequest: onRedirectNavigate did not return false, navigating\");\n            yield params.navigationClient.navigateExternal(requestUrl, navigationOptions);\n            return;\n          } else {\n            _this.logger.verbose(\"RedirectHandler.initiateAuthRequest: onRedirectNavigate returned false, stopping navigation\");\n            return;\n          }\n        } else {\n          // Navigate window to request URL\n          _this.logger.verbose(\"RedirectHandler.initiateAuthRequest: Navigating window to navigate url\");\n          yield params.navigationClient.navigateExternal(requestUrl, navigationOptions);\n          return;\n        }\n      } else {\n        // Throw error if request URL is empty.\n        _this.logger.info(\"RedirectHandler.initiateAuthRequest: Navigate url is empty\");\n        throw createBrowserAuthError(emptyNavigateUri);\n      }\n    })();\n  }\n  /**\n   * Handle authorization code response in the window.\n   * @param hash\n   */\n  handleCodeResponse(response, state) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.logger.verbose(\"RedirectHandler.handleCodeResponse called\");\n      // Interaction is completed - remove interaction status.\n      _this2.browserStorage.setInteractionInProgress(false);\n      // Handle code response.\n      const stateKey = _this2.browserStorage.generateStateKey(state);\n      const requestState = _this2.browserStorage.getTemporaryCache(stateKey);\n      if (!requestState) {\n        throw createClientAuthError(ClientAuthErrorCodes.stateNotFound, \"Cached State\");\n      }\n      let authCodeResponse;\n      try {\n        authCodeResponse = _this2.authModule.handleFragmentResponse(response, requestState);\n      } catch (e) {\n        if (e instanceof ServerError && e.subError === userCancelled) {\n          // Translate server error caused by user closing native prompt to corresponding first class MSAL error\n          throw createBrowserAuthError(userCancelled);\n        } else {\n          throw e;\n        }\n      }\n      // Get cached items\n      const nonceKey = _this2.browserStorage.generateNonceKey(requestState);\n      const cachedNonce = _this2.browserStorage.getTemporaryCache(nonceKey);\n      // Assign code to request\n      _this2.authCodeRequest.code = authCodeResponse.code;\n      // Check for new cloud instance\n      if (authCodeResponse.cloud_instance_host_name) {\n        yield invokeAsync(_this2.authModule.updateAuthority.bind(_this2.authModule), PerformanceEvents.UpdateTokenEndpointAuthority, _this2.logger, _this2.performanceClient, _this2.authCodeRequest.correlationId)(authCodeResponse.cloud_instance_host_name, _this2.authCodeRequest.correlationId);\n      }\n      authCodeResponse.nonce = cachedNonce || undefined;\n      authCodeResponse.state = requestState;\n      // Add CCS parameters if available\n      if (authCodeResponse.client_info) {\n        _this2.authCodeRequest.clientInfo = authCodeResponse.client_info;\n      } else {\n        const cachedCcsCred = _this2.checkCcsCredentials();\n        if (cachedCcsCred) {\n          _this2.authCodeRequest.ccsCredential = cachedCcsCred;\n        }\n      }\n      // Acquire token with retrieved code.\n      const tokenResponse = yield _this2.authModule.acquireToken(_this2.authCodeRequest, authCodeResponse);\n      _this2.browserStorage.cleanRequestByState(state);\n      return tokenResponse;\n    })();\n  }\n  /**\n   * Looks up ccs creds in the cache\n   */\n  checkCcsCredentials() {\n    // Look up ccs credential in temp cache\n    const cachedCcsCred = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, true);\n    if (cachedCcsCred) {\n      try {\n        return JSON.parse(cachedCcsCred);\n      } catch (e) {\n        this.authModule.logger.error(\"Cache credential could not be parsed\");\n        this.authModule.logger.errorPii(`Cache credential could not be parsed: ${cachedCcsCred}`);\n      }\n    }\n    return null;\n  }\n}\nexport { RedirectHandler };\n//# sourceMappingURL=RedirectHandler.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}