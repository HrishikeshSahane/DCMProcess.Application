{"ast":null,"code":"/*! @azure/msal-common v14.5.0 2023-12-01 */\n'use strict';\n\nimport { AuthError } from './AuthError.mjs';\nimport { clientInfoDecodingError, clientInfoEmptyError, tokenParsingError, nullOrEmptyToken, endpointResolutionError, networkError, openIdConfigError, hashNotDeserialized, invalidState, stateMismatch, stateNotFound, nonceMismatch, authTimeNotFound, maxAgeTranspired, multipleMatchingTokens, multipleMatchingAccounts, multipleMatchingAppMetadata, requestCannotBeMade, cannotRemoveEmptyScope, cannotAppendScopeSet, emptyInputScopeSet, deviceCodePollingCancelled, deviceCodeExpired, deviceCodeUnknownError, noAccountInSilentRequest, invalidCacheRecord, invalidCacheEnvironment, noAccountFound, noCryptoObject, unexpectedCredentialType, invalidAssertion, invalidClientCredential, tokenRefreshRequired, userTimeoutReached, tokenClaimsCnfRequiredForSignedJwt, authorizationCodeMissingFromServerResponse, bindingKeyNotRemoved, endSessionEndpointNotSupported, keyIdMissing, noNetworkConnectivity, userCanceled, missingTenantIdError, nestedAppAuthBridgeDisabled, methodNotImplemented } from './ClientAuthErrorCodes.mjs';\nimport * as ClientAuthErrorCodes from './ClientAuthErrorCodes.mjs';\nexport { ClientAuthErrorCodes };\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * ClientAuthErrorMessage class containing string constants used by error codes and messages.\n */\nconst ClientAuthErrorMessages = {\n  [clientInfoDecodingError]: \"The client info could not be parsed/decoded correctly\",\n  [clientInfoEmptyError]: \"The client info was empty\",\n  [tokenParsingError]: \"Token cannot be parsed\",\n  [nullOrEmptyToken]: \"The token is null or empty\",\n  [endpointResolutionError]: \"Endpoints cannot be resolved\",\n  [networkError]: \"Network request failed\",\n  [openIdConfigError]: \"Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints.\",\n  [hashNotDeserialized]: \"The hash parameters could not be deserialized\",\n  [invalidState]: \"State was not the expected format\",\n  [stateMismatch]: \"State mismatch error\",\n  [stateNotFound]: \"State not found\",\n  [nonceMismatch]: \"Nonce mismatch error\",\n  [authTimeNotFound]: \"Max Age was requested and the ID token is missing the auth_time variable.\" + \" auth_time is an optional claim and is not enabled by default - it must be enabled.\" + \" See https://aka.ms/msaljs/optional-claims for more information.\",\n  [maxAgeTranspired]: \"Max Age is set to 0, or too much time has elapsed since the last end-user authentication.\",\n  [multipleMatchingTokens]: \"The cache contains multiple tokens satisfying the requirements. \" + \"Call AcquireToken again providing more requirements such as authority or account.\",\n  [multipleMatchingAccounts]: \"The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account\",\n  [multipleMatchingAppMetadata]: \"The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata\",\n  [requestCannotBeMade]: \"Token request cannot be made without authorization code or refresh token.\",\n  [cannotRemoveEmptyScope]: \"Cannot remove null or empty scope from ScopeSet\",\n  [cannotAppendScopeSet]: \"Cannot append ScopeSet\",\n  [emptyInputScopeSet]: \"Empty input ScopeSet cannot be processed\",\n  [deviceCodePollingCancelled]: \"Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true.\",\n  [deviceCodeExpired]: \"Device code is expired.\",\n  [deviceCodeUnknownError]: \"Device code stopped polling for unknown reasons.\",\n  [noAccountInSilentRequest]: \"Please pass an account object, silent flow is not supported without account information\",\n  [invalidCacheRecord]: \"Cache record object was null or undefined.\",\n  [invalidCacheEnvironment]: \"Invalid environment when attempting to create cache entry\",\n  [noAccountFound]: \"No account found in cache for given key.\",\n  [noCryptoObject]: \"No crypto object detected.\",\n  [unexpectedCredentialType]: \"Unexpected credential type.\",\n  [invalidAssertion]: \"Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515\",\n  [invalidClientCredential]: \"Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential\",\n  [tokenRefreshRequired]: \"Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired.\",\n  [userTimeoutReached]: \"User defined timeout for device code polling reached\",\n  [tokenClaimsCnfRequiredForSignedJwt]: \"Cannot generate a POP jwt if the token_claims are not populated\",\n  [authorizationCodeMissingFromServerResponse]: \"Server response does not contain an authorization code to proceed\",\n  [bindingKeyNotRemoved]: \"Could not remove the credential's binding key from storage.\",\n  [endSessionEndpointNotSupported]: \"The provided authority does not support logout\",\n  [keyIdMissing]: \"A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key.\",\n  [noNetworkConnectivity]: \"No network connectivity. Check your internet connection.\",\n  [userCanceled]: \"User cancelled the flow.\",\n  [missingTenantIdError]: \"A tenant id - not common, organizations, or consumers - must be specified when using the client_credentials flow.\",\n  [methodNotImplemented]: \"This method has not been implemented\",\n  [nestedAppAuthBridgeDisabled]: \"The nested app auth bridge is disabled\"\n};\n/**\n * String constants used by error codes and messages.\n * @deprecated Use ClientAuthErrorCodes instead\n */\nconst ClientAuthErrorMessage = {\n  clientInfoDecodingError: {\n    code: clientInfoDecodingError,\n    desc: ClientAuthErrorMessages[clientInfoDecodingError]\n  },\n  clientInfoEmptyError: {\n    code: clientInfoEmptyError,\n    desc: ClientAuthErrorMessages[clientInfoEmptyError]\n  },\n  tokenParsingError: {\n    code: tokenParsingError,\n    desc: ClientAuthErrorMessages[tokenParsingError]\n  },\n  nullOrEmptyToken: {\n    code: nullOrEmptyToken,\n    desc: ClientAuthErrorMessages[nullOrEmptyToken]\n  },\n  endpointResolutionError: {\n    code: endpointResolutionError,\n    desc: ClientAuthErrorMessages[endpointResolutionError]\n  },\n  networkError: {\n    code: networkError,\n    desc: ClientAuthErrorMessages[networkError]\n  },\n  unableToGetOpenidConfigError: {\n    code: openIdConfigError,\n    desc: ClientAuthErrorMessages[openIdConfigError]\n  },\n  hashNotDeserialized: {\n    code: hashNotDeserialized,\n    desc: ClientAuthErrorMessages[hashNotDeserialized]\n  },\n  invalidStateError: {\n    code: invalidState,\n    desc: ClientAuthErrorMessages[invalidState]\n  },\n  stateMismatchError: {\n    code: stateMismatch,\n    desc: ClientAuthErrorMessages[stateMismatch]\n  },\n  stateNotFoundError: {\n    code: stateNotFound,\n    desc: ClientAuthErrorMessages[stateNotFound]\n  },\n  nonceMismatchError: {\n    code: nonceMismatch,\n    desc: ClientAuthErrorMessages[nonceMismatch]\n  },\n  authTimeNotFoundError: {\n    code: authTimeNotFound,\n    desc: ClientAuthErrorMessages[authTimeNotFound]\n  },\n  maxAgeTranspired: {\n    code: maxAgeTranspired,\n    desc: ClientAuthErrorMessages[maxAgeTranspired]\n  },\n  multipleMatchingTokens: {\n    code: multipleMatchingTokens,\n    desc: ClientAuthErrorMessages[multipleMatchingTokens]\n  },\n  multipleMatchingAccounts: {\n    code: multipleMatchingAccounts,\n    desc: ClientAuthErrorMessages[multipleMatchingAccounts]\n  },\n  multipleMatchingAppMetadata: {\n    code: multipleMatchingAppMetadata,\n    desc: ClientAuthErrorMessages[multipleMatchingAppMetadata]\n  },\n  tokenRequestCannotBeMade: {\n    code: requestCannotBeMade,\n    desc: ClientAuthErrorMessages[requestCannotBeMade]\n  },\n  removeEmptyScopeError: {\n    code: cannotRemoveEmptyScope,\n    desc: ClientAuthErrorMessages[cannotRemoveEmptyScope]\n  },\n  appendScopeSetError: {\n    code: cannotAppendScopeSet,\n    desc: ClientAuthErrorMessages[cannotAppendScopeSet]\n  },\n  emptyInputScopeSetError: {\n    code: emptyInputScopeSet,\n    desc: ClientAuthErrorMessages[emptyInputScopeSet]\n  },\n  DeviceCodePollingCancelled: {\n    code: deviceCodePollingCancelled,\n    desc: ClientAuthErrorMessages[deviceCodePollingCancelled]\n  },\n  DeviceCodeExpired: {\n    code: deviceCodeExpired,\n    desc: ClientAuthErrorMessages[deviceCodeExpired]\n  },\n  DeviceCodeUnknownError: {\n    code: deviceCodeUnknownError,\n    desc: ClientAuthErrorMessages[deviceCodeUnknownError]\n  },\n  NoAccountInSilentRequest: {\n    code: noAccountInSilentRequest,\n    desc: ClientAuthErrorMessages[noAccountInSilentRequest]\n  },\n  invalidCacheRecord: {\n    code: invalidCacheRecord,\n    desc: ClientAuthErrorMessages[invalidCacheRecord]\n  },\n  invalidCacheEnvironment: {\n    code: invalidCacheEnvironment,\n    desc: ClientAuthErrorMessages[invalidCacheEnvironment]\n  },\n  noAccountFound: {\n    code: noAccountFound,\n    desc: ClientAuthErrorMessages[noAccountFound]\n  },\n  noCryptoObj: {\n    code: noCryptoObject,\n    desc: ClientAuthErrorMessages[noCryptoObject]\n  },\n  unexpectedCredentialType: {\n    code: unexpectedCredentialType,\n    desc: ClientAuthErrorMessages[unexpectedCredentialType]\n  },\n  invalidAssertion: {\n    code: invalidAssertion,\n    desc: ClientAuthErrorMessages[invalidAssertion]\n  },\n  invalidClientCredential: {\n    code: invalidClientCredential,\n    desc: ClientAuthErrorMessages[invalidClientCredential]\n  },\n  tokenRefreshRequired: {\n    code: tokenRefreshRequired,\n    desc: ClientAuthErrorMessages[tokenRefreshRequired]\n  },\n  userTimeoutReached: {\n    code: userTimeoutReached,\n    desc: ClientAuthErrorMessages[userTimeoutReached]\n  },\n  tokenClaimsRequired: {\n    code: tokenClaimsCnfRequiredForSignedJwt,\n    desc: ClientAuthErrorMessages[tokenClaimsCnfRequiredForSignedJwt]\n  },\n  noAuthorizationCodeFromServer: {\n    code: authorizationCodeMissingFromServerResponse,\n    desc: ClientAuthErrorMessages[authorizationCodeMissingFromServerResponse]\n  },\n  bindingKeyNotRemovedError: {\n    code: bindingKeyNotRemoved,\n    desc: ClientAuthErrorMessages[bindingKeyNotRemoved]\n  },\n  logoutNotSupported: {\n    code: endSessionEndpointNotSupported,\n    desc: ClientAuthErrorMessages[endSessionEndpointNotSupported]\n  },\n  keyIdMissing: {\n    code: keyIdMissing,\n    desc: ClientAuthErrorMessages[keyIdMissing]\n  },\n  noNetworkConnectivity: {\n    code: noNetworkConnectivity,\n    desc: ClientAuthErrorMessages[noNetworkConnectivity]\n  },\n  userCanceledError: {\n    code: userCanceled,\n    desc: ClientAuthErrorMessages[userCanceled]\n  },\n  missingTenantIdError: {\n    code: missingTenantIdError,\n    desc: ClientAuthErrorMessages[missingTenantIdError]\n  },\n  nestedAppAuthBridgeDisabled: {\n    code: nestedAppAuthBridgeDisabled,\n    desc: ClientAuthErrorMessages[nestedAppAuthBridgeDisabled]\n  }\n};\n/**\n * Error thrown when there is an error in the client code running on the browser.\n */\nclass ClientAuthError extends AuthError {\n  constructor(errorCode, additionalMessage) {\n    super(errorCode, additionalMessage ? `${ClientAuthErrorMessages[errorCode]}: ${additionalMessage}` : ClientAuthErrorMessages[errorCode]);\n    this.name = \"ClientAuthError\";\n    Object.setPrototypeOf(this, ClientAuthError.prototype);\n  }\n}\nfunction createClientAuthError(errorCode, additionalMessage) {\n  return new ClientAuthError(errorCode, additionalMessage);\n}\nexport { ClientAuthError, ClientAuthErrorMessage, ClientAuthErrorMessages, createClientAuthError };\n//# sourceMappingURL=ClientAuthError.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}