{"ast":null,"code":"\"use strict\";\n\n// node crypt, we use it for generate salt\n// eslint-disable-next-line node/no-unsupported-features/node-builtins\nconst {\n  randomFillSync\n} = require(\"crypto\");\n\n// generate CRC32 lookup table\nconst crctable = new Uint32Array(256).map((t, crc) => {\n  for (let j = 0; j < 8; j++) {\n    if (0 !== (crc & 1)) {\n      crc = crc >>> 1 ^ 0xedb88320;\n    } else {\n      crc >>>= 1;\n    }\n  }\n  return crc >>> 0;\n});\n\n// C-style uInt32 Multiply (discards higher bits, when JS multiply discards lower bits)\nconst uMul = (a, b) => Math.imul(a, b) >>> 0;\n\n// crc32 byte single update (actually same function is part of utils.crc32 function :) )\nconst crc32update = (pCrc32, bval) => {\n  return crctable[(pCrc32 ^ bval) & 0xff] ^ pCrc32 >>> 8;\n};\n\n// function for generating salt for encrytion header\nconst genSalt = () => {\n  if (\"function\" === typeof randomFillSync) {\n    return randomFillSync(Buffer.alloc(12));\n  } else {\n    // fallback if function is not defined\n    return genSalt.node();\n  }\n};\n\n// salt generation with node random function (mainly as fallback)\ngenSalt.node = () => {\n  const salt = Buffer.alloc(12);\n  const len = salt.length;\n  for (let i = 0; i < len; i++) salt[i] = Math.random() * 256 & 0xff;\n  return salt;\n};\n\n// general config\nconst config = {\n  genSalt\n};\n\n// Class Initkeys handles same basic ops with keys\nfunction Initkeys(pw) {\n  const pass = Buffer.isBuffer(pw) ? pw : Buffer.from(pw);\n  this.keys = new Uint32Array([0x12345678, 0x23456789, 0x34567890]);\n  for (let i = 0; i < pass.length; i++) {\n    this.updateKeys(pass[i]);\n  }\n}\nInitkeys.prototype.updateKeys = function (byteValue) {\n  const keys = this.keys;\n  keys[0] = crc32update(keys[0], byteValue);\n  keys[1] += keys[0] & 0xff;\n  keys[1] = uMul(keys[1], 134775813) + 1;\n  keys[2] = crc32update(keys[2], keys[1] >>> 24);\n  return byteValue;\n};\nInitkeys.prototype.next = function () {\n  const k = (this.keys[2] | 2) >>> 0; // key\n  return uMul(k, k ^ 1) >> 8 & 0xff; // decode\n};\n\nfunction make_decrypter( /*Buffer*/pwd) {\n  // 1. Stage initialize key\n  const keys = new Initkeys(pwd);\n\n  // return decrypter function\n  return function ( /*Buffer*/data) {\n    // result - we create new Buffer for results\n    const result = Buffer.alloc(data.length);\n    let pos = 0;\n    // process input data\n    for (let c of data) {\n      //c ^= keys.next();\n      //result[pos++] = c; // decode & Save Value\n      result[pos++] = keys.updateKeys(c ^ keys.next()); // update keys with decoded byte\n    }\n\n    return result;\n  };\n}\nfunction make_encrypter( /*Buffer*/pwd) {\n  // 1. Stage initialize key\n  const keys = new Initkeys(pwd);\n\n  // return encrypting function, result and pos is here so we dont have to merge buffers later\n  return function ( /*Buffer*/data, /*Buffer*/result, /* Number */pos = 0) {\n    // result - we create new Buffer for results\n    if (!result) result = Buffer.alloc(data.length);\n    // process input data\n    for (let c of data) {\n      const k = keys.next(); // save key byte\n      result[pos++] = c ^ k; // save val\n      keys.updateKeys(c); // update keys with decoded byte\n    }\n\n    return result;\n  };\n}\nfunction decrypt( /*Buffer*/data, /*Object*/header, /*String, Buffer*/pwd) {\n  if (!data || !Buffer.isBuffer(data) || data.length < 12) {\n    return Buffer.alloc(0);\n  }\n\n  // 1. We Initialize and generate decrypting function\n  const decrypter = make_decrypter(pwd);\n\n  // 2. decrypt salt what is always 12 bytes and is a part of file content\n  const salt = decrypter(data.slice(0, 12));\n\n  // 3. does password meet expectations\n  if (salt[11] !== header.crc >>> 24) {\n    throw \"ADM-ZIP: Wrong Password\";\n  }\n\n  // 4. decode content\n  return decrypter(data.slice(12));\n}\n\n// lets add way to populate salt, NOT RECOMMENDED for production but maybe useful for testing general functionality\nfunction _salter(data) {\n  if (Buffer.isBuffer(data) && data.length >= 12) {\n    // be aware - currently salting buffer data is modified\n    config.genSalt = function () {\n      return data.slice(0, 12);\n    };\n  } else if (data === \"node\") {\n    // test salt generation with node random function\n    config.genSalt = genSalt.node;\n  } else {\n    // if value is not acceptable config gets reset.\n    config.genSalt = genSalt;\n  }\n}\nfunction encrypt( /*Buffer*/data, /*Object*/header, /*String, Buffer*/pwd, /*Boolean*/oldlike = false) {\n  // 1. test data if data is not Buffer we make buffer from it\n  if (data == null) data = Buffer.alloc(0);\n  // if data is not buffer be make buffer from it\n  if (!Buffer.isBuffer(data)) data = Buffer.from(data.toString());\n\n  // 2. We Initialize and generate encrypting function\n  const encrypter = make_encrypter(pwd);\n\n  // 3. generate salt (12-bytes of random data)\n  const salt = config.genSalt();\n  salt[11] = header.crc >>> 24 & 0xff;\n\n  // old implementations (before PKZip 2.04g) used two byte check\n  if (oldlike) salt[10] = header.crc >>> 16 & 0xff;\n\n  // 4. create output\n  const result = Buffer.alloc(data.length + 12);\n  encrypter(salt, result);\n\n  // finally encode content\n  return encrypter(data, result, 12);\n}\nmodule.exports = {\n  decrypt,\n  encrypt,\n  _salter\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}