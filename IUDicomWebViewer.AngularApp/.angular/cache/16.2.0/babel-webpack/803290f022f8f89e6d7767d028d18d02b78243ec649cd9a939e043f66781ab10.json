{"ast":null,"code":"import _asyncToGenerator from \"D:/Hrishikesh/IUBH/Thesis/PoC/DICOMImageProcessing_Application/IUDicomWebViewer.AngularApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AbortController } from \"@azure/abort-controller\";\nimport { deserializeState, initOperation, pollOperation } from \"./operation\";\nimport { POLL_INTERVAL_IN_MS } from \"./constants\";\nimport { delay } from \"@azure/core-util\";\nconst createStateProxy = () => ({\n  /**\n   * The state at this point is created to be of type OperationState<TResult>.\n   * It will be updated later to be of type TState when the\n   * customer-provided callback, `updateState`, is called during polling.\n   */\n  initState: config => ({\n    status: \"running\",\n    config\n  }),\n  setCanceled: state => state.status = \"canceled\",\n  setError: (state, error) => state.error = error,\n  setResult: (state, result) => state.result = result,\n  setRunning: state => state.status = \"running\",\n  setSucceeded: state => state.status = \"succeeded\",\n  setFailed: state => state.status = \"failed\",\n  getError: state => state.error,\n  getResult: state => state.result,\n  isCanceled: state => state.status === \"canceled\",\n  isFailed: state => state.status === \"failed\",\n  isRunning: state => state.status === \"running\",\n  isSucceeded: state => state.status === \"succeeded\"\n});\n/**\n * Returns a poller factory.\n */\nexport function buildCreatePoller(inputs) {\n  const {\n    getOperationLocation,\n    getStatusFromInitialResponse,\n    getStatusFromPollResponse,\n    isOperationError,\n    getResourceLocation,\n    getPollingInterval,\n    getError,\n    resolveOnUnsuccessful\n  } = inputs;\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* ({\n      init,\n      poll\n    }, options) {\n      const {\n        processResult,\n        updateState,\n        withOperationLocation: withOperationLocationCallback,\n        intervalInMs = POLL_INTERVAL_IN_MS,\n        restoreFrom\n      } = options || {};\n      const stateProxy = createStateProxy();\n      const withOperationLocation = withOperationLocationCallback ? (() => {\n        let called = false;\n        return (operationLocation, isUpdated) => {\n          if (isUpdated) withOperationLocationCallback(operationLocation);else if (!called) withOperationLocationCallback(operationLocation);\n          called = true;\n        };\n      })() : undefined;\n      const state = restoreFrom ? deserializeState(restoreFrom) : yield initOperation({\n        init,\n        stateProxy,\n        processResult,\n        getOperationStatus: getStatusFromInitialResponse,\n        withOperationLocation,\n        setErrorAsResult: !resolveOnUnsuccessful\n      });\n      let resultPromise;\n      const abortController = new AbortController();\n      const handlers = new Map();\n      const handleProgressEvents = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* () {\n          return handlers.forEach(h => h(state));\n        });\n        return function handleProgressEvents() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      const cancelErrMsg = \"Operation was canceled\";\n      let currentPollIntervalInMs = intervalInMs;\n      const poller = {\n        getOperationState: () => state,\n        getResult: () => state.result,\n        isDone: () => [\"succeeded\", \"failed\", \"canceled\"].includes(state.status),\n        isStopped: () => resultPromise === undefined,\n        stopPolling: () => {\n          abortController.abort();\n        },\n        toString: () => JSON.stringify({\n          state\n        }),\n        onProgress: callback => {\n          const s = Symbol();\n          handlers.set(s, callback);\n          return () => handlers.delete(s);\n        },\n        pollUntilDone: pollOptions => resultPromise !== null && resultPromise !== void 0 ? resultPromise : resultPromise = _asyncToGenerator(function* () {\n          const {\n            abortSignal: inputAbortSignal\n          } = pollOptions || {};\n          const {\n            signal: abortSignal\n          } = inputAbortSignal ? new AbortController([inputAbortSignal, abortController.signal]) : abortController;\n          if (!poller.isDone()) {\n            yield poller.poll({\n              abortSignal\n            });\n            while (!poller.isDone()) {\n              yield delay(currentPollIntervalInMs, {\n                abortSignal\n              });\n              yield poller.poll({\n                abortSignal\n              });\n            }\n          }\n          if (resolveOnUnsuccessful) {\n            return poller.getResult();\n          } else {\n            switch (state.status) {\n              case \"succeeded\":\n                return poller.getResult();\n              case \"canceled\":\n                throw new Error(cancelErrMsg);\n              case \"failed\":\n                throw state.error;\n              case \"notStarted\":\n              case \"running\":\n                throw new Error(`Polling completed without succeeding or failing`);\n            }\n          }\n        })().finally(() => {\n          resultPromise = undefined;\n        }),\n        poll(pollOptions) {\n          return _asyncToGenerator(function* () {\n            if (resolveOnUnsuccessful) {\n              if (poller.isDone()) return;\n            } else {\n              switch (state.status) {\n                case \"succeeded\":\n                  return;\n                case \"canceled\":\n                  throw new Error(cancelErrMsg);\n                case \"failed\":\n                  throw state.error;\n              }\n            }\n            yield pollOperation({\n              poll,\n              state,\n              stateProxy,\n              getOperationLocation,\n              isOperationError,\n              withOperationLocation,\n              getPollingInterval,\n              getOperationStatus: getStatusFromPollResponse,\n              getResourceLocation,\n              processResult,\n              getError,\n              updateState,\n              options: pollOptions,\n              setDelay: pollIntervalInMs => {\n                currentPollIntervalInMs = pollIntervalInMs;\n              },\n              setErrorAsResult: !resolveOnUnsuccessful\n            });\n            yield handleProgressEvents();\n            if (!resolveOnUnsuccessful) {\n              switch (state.status) {\n                case \"canceled\":\n                  throw new Error(cancelErrMsg);\n                case \"failed\":\n                  throw state.error;\n              }\n            }\n          })();\n        }\n      };\n      return poller;\n    });\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\n//# sourceMappingURL=poller.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}